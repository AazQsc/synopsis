Материал отсюда:
https://metanit.com/sharp/tutorial/1.2.php
Вот так можно компилировтаь программы:
C:\Windows\Microsoft.NET\Framework\v4.0.30319\csc.exe name.cs

-----------------------------------------------------------------------------------------------------
РЕЗЮМИРУЯ:
1.  пиши имена методов с большой буквы
2.  используй сокращенную запись методов если в методе мы имеем только одну комманду
3.  ставь скобки похожие на пасть крокодила
4.  в foreach слово in вместо двоеточия
5.  можно писать методы, которые возвращают несколько параметров
6.  составные типы, это не просто объекты, а Структуры (передаются по значению, не поддерживают наследование)
7.  картежи всюду или нигде?
8.  свойства вместо геттеров и сеттеров
9.  используй константы, вместо файнал статиков и поля только для чтения.
10. в шарпе можно перегружать операторы, например сделать user(Миша) + user(Нина) = user(Мишанина)

-----------------------------------------------------------------------------------------------------
структура проекта в визуал студии: 
  1. узел Properties или Свойств (он хранит файлы свойств приложения и пока нам не нужен); 
  2. узел References - это узел содержит сборки dll, которые добавлены в проект по умолчанию.
     Эти сборки как раз содержат классы библиотеки .NET, которые будет использовать C#.
  3. исходный код
  4. файл конфигурации App.config

-----------------------------------------------------------------------------------------------------
BASE

1.
Консольный ввод:
	string name = Console.ReadLine(); (преобразует к типу String)
	= Convert.ToInt32() (преобразует к типу int)
	= Convert.ToDouble() (преобразует к типу double)
	= Convert.ToDecimal() (преобразует к типу decimal)

2.
int a = 33;
int b = 600;
byte c = checked((byte)(a + b));

При использовании ключевого слова checked приложение выбрасывает исключение о переполнении. Поэтому для его обработки в данном случае используется конструкция try...catch. 

3.
switch (number)
{
    case 1:
        Console.WriteLine("case 1");
        goto case 5; // переход к case 5
    case 3:
        Console.WriteLine("case 3");
        break;
    case 5:
        Console.WriteLine("case 5");
        break;
    default:
        Console.WriteLine("default");
        break;
}

4.
foreach (тип_данных название_переменной in контейнер)
{
    // действия
}

5.
Многомерные массивы:
int[,] nums1;
int[,] nums2 = new int[2, 3];
int[,] nums3 = new int[2, 3] { { 0, 1, 2 }, { 3, 4, 5 } };
int[,] nums4 = new int[,] { { 0, 1, 2 }, { 3, 4, 5 } };
int[,] nums5 = new [,]{ { 0, 1, 2 }, { 3, 4, 5 } };
int[,] nums6 = { { 0, 1, 2 }, { 3, 4, 5 } };

int[,] mas = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 }, { 10, 11, 12 } };
Но что если мы хотим отдельно пробежаться по каждой строке в таблице? В этом случае надо получить количество элементов в размерности. В частности, у каждого массива есть метод GetUpperBound(dimension), который возвращает индекс последнего элемента в определенной размерности. И если мы говорим непосредственно о двухмерном массиве, то первая размерность (с индексом 0) по сути это и есть таблица. И с помощью выражения mas.GetUpperBound(0) + 1 можно получить количество строк таблицы, представленной двухмерным массивом. А через mas.Length / rows можно получить количество элементов в каждой строке:

int rows = mas.GetUpperBound(0) + 1;
int columns = mas.Length / rows;

От многомерных массивов надо отличать массив массивов или так называемый "зубчатый массив":
int[][] nums = new int[3][];
nums[0] = new int[2] { 1, 2 };          // выделяем память для первого подмассива
nums[1] = new int[3] { 1, 2, 3 };       // выделяем память для второго подмассива
nums[2] = new int[5] { 1, 2, 3, 4, 5 }; // выделяем память для третьего подмассива

6.
Имена методов с большой буквы! 

7.
Сокращенная запись методов
	static void SayHello()
	{
	    Console.WriteLine("Hello");
	}

Это тоже самое что и:
	static void SayHello() => Console.WriteLine("Hello");

ещё пример:
	static string GetHello() => ("hello");

8.
Необязательные параметры
	static int OptionalParam(int x, int y, int z=5, int s=4)
	{
	    return x + y + z + s;
	}

	OptionalParam(2, 3);
    	OptionalParam(2,3,10);
	OptionalParam(y:2, x:3, s:10);

9.
Мы можем передавать примитивы по ссылке:
	// параметр x передается по ссылке
	static void Addition(ref int x, int y)
	{
	    x += y;
	}

10.
Пиши возвращаемые параметры для методов
	static void Sum(int x, int y, out int a)
	{
    	    a = x + y;
	}

	int x = 10;
    	int z;
    	Sum(x, 15, out z);
    	Console.WriteLine(z);

Прелесть:
	static void GetData(int x, int y, out int area, out int perim)
	{
	    area= x * y;
	    perim= (x + y)*2; 
	}

	int x = 10;
    	int area;
    	int perimetr;
    	GetData(x, 15, out area, out perimetr);
    	Console.WriteLine("Площадь : " + area);
    	Console.WriteLine("Периметр : " + perimetr);

11.
Можно передавать значения в метод и на лету формировать коллекцию или массив
	static void Addition(params int[] integers){}
	Addition(1, 2, 3, 4, 5);

12.
Картеж - это быстрый поджо:
	(string, int, double) person = ("Tom", 25, 81.23);  //передаются по значению
	
13.
Для блоков catch можно указывать условия:
	int x = 1;
	int y = 0;
	 
	try
	{
		int result = x / y;
	}
	catch(Exception ex) when (y==0)  // сработает этот блок
	{
		Console.WriteLine("y не должен быть равен 0");
	}
	catch(Exception ex)
	{
		Console.WriteLine(ex.Message);
	}


14. 
Инициализаторы.
Person tom = new Person { name = "Tom", age=31 };

При использовании инициализаторов следует учитывать следующие моменты:

    С помощью инициализатора мы можем установить значения только доступных из внешнего кода полей и свойств объекта. Например, в примере выше поля name и age имеют модификатор доступа public, поэтому они доступны из любой части программы.

    Инициализатор выполняется после конструктора, поэтому если и в конструкторе, и в инициализаторе устанавливаются значения одних и тех же полей и свойств, то значения, устанавливаемые в конструкторе, заменяются значениями из инициализатора.

15.
Типы данных:
	Типы значений:
		Целочисленные типы (byte, sbyte, char, short, ushort, int, uint, long, ulong)
		Типы с плавающей запятой (float, double)
		Тип decimal
		Тип bool
		Перечисления enum
		Структуры (struct)

	Ссылочные типы:
		Тип object
		Тип string
		Классы (class)
		Интерфейсы (interface)
		Делегаты (delegate)

16.
Модификаторы доступа:
	1. public: публичный, общедоступный класс или член класса. Такой член класса доступен из любого места в коде, а также из других программ и сборок.
	2. private: закрытый класс или член класса. Представляет полную противоположность модификатору public. Такой закрытый класс или член класса доступен только из кода в том же классе или контексте.
	3. protected: такой член класса доступен из любого места в текущем классе или в производных классах. При этом производные классы могут располагаться в других сборках.
	4. internal: класс и члены класса с подобным модификатором доступны из любого места кода в той же сборке, однако он недоступен для других программ и сборок (как в случае с модификатором public).
	5. protected internal: совмещает функционал двух модификаторов. Классы и члены класса с таким модификатором доступны из текущей сборки и из производных классов.
	6. private protected: такой член класса доступен из любого места в текущем классе или в производных классах, которые определены в той же сборке.

    int a; // все равно, что private int a;
    private int b; // поле доступно только из текущего класса
    protected int c; // доступно из текущего класса и производных классов
    internal int d; // доступно в любом месте программы
    protected internal int e; // доступно в любом месте программы и из классов-наследников
    public int f; // доступно в любом месте программы, а также для других программ и сборок
    protected private int g; // доступно из текущего класса и производных классов, которые определены в том же проекте

17.
При использовании модификаторов в свойствах следует учитывать ряд ограничений:
	- Модификатор для блока set или get можно установить, если свойство имеет оба блока (и set, и get)
	- Только один блок set или get может иметь модификатор доступа, но не оба сразу
	- Модификатор доступа блока set или get должен быть более ограничивающим, чем модификатор доступа свойства. Например, если свойство имеет модификатор public, то блок set/get может иметь только модификаторы protected internal, internal, protected, private
	
	class Account
	{
	    private int sum;
	    public int Sum 
	    {
	        get {return sum;}
	        set
	        {
	            if (value > 0)
	            {
	                sum=value;
	            }
	        }
	    }
	}

18. 
Автоматические свойства
	class Person
	{
	    public string Name { get; set; }
	    public int Age { get; set; }
         
	    public Person(string name, int age)
	    {
		Name = name;
	        Age = age;
	    }
	}

Инициализация:
	class Person
	{
    		public string Name { get; set; } = "Tom";
    		public int Age { get; set; } = 23;
	}

Свойство доступное только для чтения:
	public string Name { get;} = "Tom"

19.
Есть константы!
	const double PI = 3.14;

и поля только для чтения
public readonly double K = 23;  // можно так инициализировать

- Константы должны быть определены во время компиляции, а поля для чтения могут быть определены во время выполнения программы.
Соответственно инициализировать константу можно устанновить только при ее определении.
Поле для чтения можно инициализировать либо при его определении, либо в конструкторе класса.
- Константы не могут быть статическими. Поля для чтения могут быть статическими.

20.
Оператор ??

object x = null;
object y = x ?? 100;  // равно 100, так как x равен null
 
object z = 200;
object t = z ?? 44; // равно 200, так как z не равен null


User user = new User();
string companyName = user?.Phone?.Company?.Name ?? "не установлено";   // ?. это проверка на null
Console.WriteLine(companyName);











