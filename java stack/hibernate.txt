Hebernate - это ORM (Object-Relational Mapping : объектно-реляционное отображение) — технология программирования, которая связывает 
базы данных с концепциями объектно-ориентированных языков программирования, создавая «виртуальную объектную базу данных».

HIBERNATE - Relational Persistence for Idiomatic Java (doc):
https://docs.jboss.org/hibernate/core/3.3/reference/en/html/index.html

Является реализацией спецификации JPA.

Одна из возможностей JPA – это создание таблиц в базе данных на основе существующий классов сущностей.

============================================================================
Для функционирования Hibernate нужны:
  1. Главный конфигурационный файл, в котором описываются параметры соединения к БД.
  2. Mapping (сопоставление, проецирование) Java-классов с таблицами базы данных осуществляется с помощью конфигурационных 
     XML-файлов или Java-аннотаций. 

Элементы конфигурационного файла:
  1. hibernate.connection.driver_class - указываем класс драйвера
  2. show_sql - если установим в true, в консоль будут выводиться SQL-запросы, которые скрыты за Hibernate-кодом
  3. dialect - диалект общения с БД
  4. hibernate.hbm2ddl.auto - свойство, которое указывается что нужно сделать со схемой БД при инициализации. 
     Может принимать такие значения:
	- update - сверяет схему БД с имеющимися конфигурациями классов, если мы внесли какие-то изменения, они автоматически 
	  занесуться в БД. При этом данные, которые были занесены в базу не изменятся - даже, если мы решили удалить некоторые поля 
	  из таблицы, они все одно останутся; 
	- create - каждый раз при запуске приложения, схема БД будет создаваться заново. Все данные, которые были занесены раньше, 
	  будут удалены;
	- create-drop - каждый раз при запуске приложения, схема БД будет создаваться наново, а при завершении - удаляться. Все данные,
	  которые были занесены во время работы приложения, будут удалены по завершению приложения;
	- validate - при инициализации будет совершена проверка соответствуют ли конфигурации классов и схема БД. 
	  Если мы внесли изменение в конфигурацию какого-то класса, а схема в БД не была изменена, выбросится исключение;
  5. указываем файлы в которых находятся конфигурации классов
  
============================================================================
POJO - Plain Old Java Object — «старый добрый Java-объект», простой Java-объект, не унаследованный от какого-то специфического 
объекта и не реализующий никаких служебных интерфейсов сверх тех, которые нужны для бизнес-модели.

Состояния сущностей:
   1. transient(new) — экземпляр сущности был создан, но не связан с persistence context. 
      Сущность не сохранёна в базе данных и обычно не имеет идентификатора. Нет подключения к сессии.
ID 2. persistent(managed) — сущность связана с persistence context и имеет связанный с ней идентификатор. 
      Сущность может как существовать в базе данных, так и пока отсутствовать в ней. Есть подключение к сессии.
ID 3. detached — с сущностью связан идентификатор, но она больше не связана с persistence context (обычно из-за того, 
      что persistence context был закрыт, либо экземпляр был удалён из него). Было подключение к сессии.
ID 4. removed — сущность имеет идентификатор и связана с persistence context, но она запланирована к удалению из базы данных.

Передвижение объекта из одного состояния в другое выполняется вызовом некоторых методов:
  .persist() из new в managed
  .find() минуя new в managed
  .merge() из detached в managed
  .merge() из new в managed
  .save() из new в managed
  .saveOrUpdate() из new в managed
  .saveOrUpdate() из detached в managed
  .update() из detached в managed
  .close() из managed в detached 
  .clear() из managed в detached <- если сделать clear до того как данные попадут из кеша в бд - они могу быть утеряны
  .remove() ... в removed
  неплохо бы разбить по граппам эти методы, где чьи..

Persistence context - набор ентити, управляемый EntityManager'ом

Flush происходит в трех ситуациях:
  -Когды вы делает commit транзакции Hibernate
  -До того как выполняется запрос в БД
  -Когда вы вызываете entityManager.flush()

Lazy loading
Ленивая загрузка определяет будет ли дочерний объект загружен при загрузке объекта-родителя.
Она настраивается свойством Lazy для дочернего объектв в файле маппинга объекта-родителя. 
По-умолчанию это свойство и так стоит в true. Hibernate не поддерживает ленивую загрузку для объектов не в сессии.

============================================================================
ВИДЫ ЗАПРОСОВ

1) JPQL / HQL
	преимущество: легко можно перейти между БД (единые запросы)
	
2) Native
	с версии 4.3.0 делается flush перед выполнением нативных запросов

	SQLQuery sql = session.createSQLQuery("update author ...");
	sql.addSynchronizedEntityClass(Author.class);			// синхронизировать БД и Кеш
	sqlQuery.executeUpdate();

3) Criteria API
	удобно выполнять динамические запросы к бд, но в целом механизм не доконца доработан.
	
============================================================================
проблема N + 1 SELECT

Есть связь one-to-many, например есть вложенные коллекции. 
Нужно осуществить их перебор.
Вопрос: как ограничить количество запросов к БД к минимуму?

решается с помощью JOIN FETCH (ключевое слово для HQL, ставим перед коллекцией объектов, связанных с нашим объектом)
hibernate получае т ассоциированные объекты и коллекции одним SELECT используя OUTER JOIN; 
помни - JOIN FETCH и пагинация не работают единовременно  
	 	
============================================================================
.get() & .load()

session.get(Book.class, bookId) - будет обращаться к БД (ну или найдет объект в кеше) и вернет инициализированный прокси. 
Если объект не будет найден, вернется null. Когда мы обращаемся к ленивым полям, они загружаются.

session.load(Book.class, bookId) - вернется неинициализированный прокси, обращения к базе вообще не будет.

============================================================================
CASH

Уровни

1. First Level Cache
   Уровень сессии.
   Это кэш сессии, является обязательным.
   Сохраняет сущности в persistence context.

2. Second level Cache
   Уровень фабрики сессии.
   Является необзательным (опциональным). Его нужно включать и настраивать явно (есть разные реализации).
   Данные кешируются среди entity manager.
   Популярные реализации: EHCache, OSCache, SwarmCache, JBoss TreeCache
   
   Информация храниться в виде массивов строк, чисел и т. д. И идентификатор объекта выступает указателем на эту информацию.
   Концептуально это нечто вроде Map, в которой id объекта — ключ, а массивы данных — значение. 
   Приблизительно можно представить себе это так:
   1 -> { "Pupkin", 1, null , {1,2,5} }
   
   Чтение из кеша второго уровня происходит только в том случае, если нужный объект не был найден в кеше первого уровня.

3. Query Cache
   Кеш запросов.
   Ключ: запрос и параметры которые переданы в запрос
   Значание: результат запроса (не объекты а их id, а сами данные в кеше второго и первого уровня).
   
   Как включить?
   <property name="hibernate.cache.use_query_cache" value="true"/>
   
   Пример использования:
   Query query = session.createQuery("from SharedDoc doc where doc.name = :name");
   query.setCacheable(true);
   
--- --- --- 
   
Стратегии кеширования:
   - Read-only
   - Read-write
   - Nonstrict-read-write
   - Transactional
   
--- --- --- 

-> Cache region - это логический разделитель памяти вашего кеша. Для каждого региона можна настроить свою политику 
   кеширования. Если регион не указан, то используется регион по умолчанию, который имеет полное имя вашего класса 
   для которого применяется кеширование.
   Пример:
   @Cache(usage = CacheConcurrencyStrategy.READ_WRITE, region = "STATIC_DATA")
   
-> Flush policy - о том когда и как мы отправляем инфу в бд (по-умолчанию auto то есть - как вздумается hibery).

-> у persistence context есть метод refresh() с помощью которого можно согласовать данные между бд и нашим приложением.

-> Несколько методов сессии для работы с кешем:
	flush() — синхронизирует объекты сессии с БД и в то же время обновляет сам кеш сессии.
	evict() — нужен для удаления объекта из кеша cессии.
	contains() — определяет находится ли объект в кеше сессии или нет.
	clear() — очищает весь кеш

-> Настройки для фабрики сессии для того, чтобы  увидеть действительно ли кешируются те или иные запросы:
	<property name="hibernate.show_sql" value="true"/>
	<property name="hibernate.format_sql" value="true"/>

-> Фабрика сессий может генерировать и сохранять статистику использования всех объектов, регионов, зависимостей в кеше:
	<property name="hibernate.generate_statistics" value="true"/>
	<property name="hibernate.cache.use_structured_entries" value="true"/>
   
============================================================================
ОБЪЕКТЫ

       /**
         * SessionFactory - это глобальная фабрика, ответственная за конкретную базу данных.
         *  её основная задача: создание сессий. Нужно позаботиться о том, что-бы этот объект
         *  создавался в единственном экземпляре (singleton, static).
         *
         * Configuration - используется для создания объекта SessionFactory
         *  и конфигурирует сам Hibernate с помощью конифигурационного XML-файла
         */
        sessionFactory = new Configuration().configure().buildSessionFactory();

        /**
         * Session - исползуется для получения физического соединения с БД.
         *  Cоздание, чтение, изменение и удаление объектов происходит через объект Session.
         *
         * Transaction - единица  работы с БД, транзакции обрабатываются менеджером транзакций.
         *
         * Алгоритм работы:
         * - открыли сессию
         * - создали транзакцию
         * - выполнили необходимое действие с бд
         * - завершаем транзакцию
         * - закрываем сессию
         */
        session = sessionFactory.openSession();

	Transaction transaction = session.beginTransaction();
	...	//действия над БД 
	transaction.commit();

	session.close();
        sessionFactory.close();
		
============================================================================
ЭНТИТИ	
		
/**
 * '@Entity'
 * Эта аннотация указывает Hibernate, что
 * данный класс является сущностью (entity bean).
 * <p>
 * '@Table'
 * Указывает с какой именно таблицей необходимо связать (map) данный класс.
 * эта Аннотация имеет различные аттрибуты, с помощью которых мы можем указать
 * имя таблицы, каталог, БД и уникальность столбцов в таблец БД.
 */
@Entity
@Table(name = "HIBERNATE_DEVELOPERS")
public class AnnotationDeveloper {
    /**
     * '@Id'
     * Указывает первичный ключ (Primary Key) данного класса.
     * '@GeneratedValue'
     * Эта аннотация используется вместе с аннотацией @Id и
     * определяет такие паметры, как strategy и generator.
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    /**
     * '@Column'
     * Определяет к какому столбцу в таблице БД относится конкретное поле класса (аттрибут класса).
     *
     * Наиболее часто используемые аттрибуты аннотации @Column:
     * name - Указывает имя столбца в таблице
     * unique - Определяет, должно ли быть данноезначение уникальным
     * nullable - Определяет, может ли данное поле быть NULL, или нет.
     * length - Указывает, какой размер столбца (например колчиство символов, при использовании String).
     * */
    @Column(name = "DEVELOPER_ID")
    private int id;
    @Column(name = "NAME")
    private String name;
    @Column(name = "EXPERIENCE")
    private int experience;

    /**
     * В POJO обязательно должен быть явно инициализирован
     * конструктор по-умолчанию
     */
    public AnnotationDeveloper() {
    }

    public AnnotationDeveloper(String name, int experience) {
        this.name = name;
        this.experience = experience;
    }

    /*
     * Getters and Setters; toString; hashcode; equals and etc
     */
    '''
}

----------------------------------------------------------------------------
Аннотации для установления связей выгледят так:
@OneToOne(cascade = CascadeType.ALL)
@JoinColumn(name = "address_id", referencedColumnName = "id")
private Address address;

============================================================================
ЛОГИ

Вопрос логгирования при использовании hibbernate неабходимо раскрыть лучше...

show_sql (см. конфигурационнный файл)
Log4JDBC (библиотека)

============================================================================
ЗАМЕТКИ


1. equals и hashcode
Для этих методов важен контекст..

Для каждой сущности нужно определить "уникальный бизнес ключ"
Но как?! id нельзя(он генерится сам), а уникальность определяется набором полей, а значение полей может менятся... 

Включать ли дочерние колекции?! (нагрузка на цпу - декартово выражение)  

РЕШЕНИЕ: 	- реализовать сравнение сущностей, на уроне гибернейт.
		- рандомизировать ключ


2. Mutable objects (все поля final)
А нельзя сделать мьютбл! Нужен конструктор по умолчанию! Хм...


3. DTO pattern должен решить эту (читай выше) проблему, но этот паттерн только делает проблему шире. 
То есть это надстройка над проблемой, а не её решение. Добавляет дубликаты.


4. LazyInitializationException
- Либо всё медленно, либо мучаемся с ошибкой.
- Персистентные коллекции не сериализуется!


5. Criteria API или HQL
- Criteria API и HQL не взаимозаменяемы.
- Делаем паттерн билдер для HQL и получаем... свою критериа!
- HQL не понимает NULL


6. Чтобы обновить одно поле нужно прочитать всю энтити или используй HQL... но зачем тогда hibernate?..


7. Для апдейта и делета hibernate создаёт временные таблицы!


8. Композитные ключи требуют создания отдельного класса?


9. Flush + try-cath = не упадёт по констрейнту (он проверятся на коммите!)


10. Документация слишком проста а устройство hibernate слишком сложнО


11. Hibernate сам в БД не ходит, он работает через JDBC! Да.


============================================================================
Links:

Босиком по граблям, - отличный доклад от Николая Алименкова
https://www.youtube.com/watch?v=YzOTZTt-PR0

Вячеслав Круглов — Введение в Hibernate: что, зачем, и где стандартные ловушки
https://www.youtube.com/watch?v=C-wEZjEOhWc&t=2s











