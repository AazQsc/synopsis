ОСНОВЫ БД:
- используй индексы
	реализации:
	hash
	B-tree
- соблюдай требования ACID:
	атомарность
	согласованность
	изолированность
	надёжность (долговечность)
- проблемы транзакций:
	потеренное обновление
	грязное чтение (чтение незакомиченной транзакции + rollback)
	не повторяющееся чтение (несколько чтений данных, которые находится в состоянии обновления)
	фантомное чтение (несколько чтений данных, которые находится в состоянии 'дозаписывания')
- решаются уровнями изоляции
	сериалайзбл
	репитбл рид
	рид комитед
	анрепитбл рид
============================================================================
Hebernate - это ORM (Object-Relational Mapping : объектно-реляционное отображение) — технология программирования, которая связывает базы данных с концепциями объектно-ориентированных языков программирования, создавая «виртуальную объектную базу данных».
============================================================================
Для функционирования Hibernate нужны:
1. Главный конфигурационный файл, в котором описываются параметры соединения к БД.
2. Mapping (сопоставление, проецирование) Java-классов с таблицами базы данных осуществляется с помощью конфигурационных XML-файлов или Java-аннотаций. 

Элементы конфигурационного файла:
	1. hibernate.connection.driver_class - указываем класс драйвера
	2. show_sql - если установим в true, в консоль будут выводиться SQL-запросы, которые скрыты за Hibernate-кодом
	3. dialect - диалект общения с БД
	4. hibernate.hbm2ddl.auto - свойство, которое указывается что нужно сделать со схемой БД при инициализации. 
		Может принимать такие значения:
- update - сверяет схему БД с имеющимися конфигурациями классов, если мы внесли какие-то изменения, они автоматически занесуться в БД. При этом данные, которые были занесены в базу не изменятся - даже, если мы решили удалить некоторые поля из таблицы, они все одно останутся 
- create - каждый раз при запуске приложения, схема БД будет создаваться наново. Все данные, которые были занесены раньше, будут удалены 
- create-drop - каждый раз при запуске приложения, схема БД будет создаваться наново, а при завершении - удаляться. Все данные, которые были занесены во время работы приложения, будут удалены по завершению приложения 
- validate - при инициализации будет совершена проверка соответствуют ли конфигурации классов и схема БД. Если мы внесли изменение в конфигурацию какого-то класса, а схема в БД не была изменена, выбросится исключение
	5. указываем файлы в которых находятся конфигурации классов
============================================================================
entity
POJO
Plain Old Java Object — «старый добрый Java-объект», простой Java-объект, не унаследованный от какого-то специфического объекта и не реализующий никаких служебных интерфейсов сверх тех, которые нужны для бизнес-модели.

Должен иметь пустой конструктор!

Одной из возможностей JPA – это создание таблиц в базе данных на основе существующий классов сущностей.
============================================================================
Состояния сущностей:
1. transient — экземпляр сущности был создан, но не связан с persistence context. Он не сохранён в базе данных и обычно не имеет идентификатора.

2. persistent — сущность связана с persistence context и имеет связанный с ней идентификатор. Она может как существовать в базе данных, так и пока отсутствовать в ней.

3. detached — с сущностью связан идентификатор, но она больше не связана с persistence context (обычно из-за того, что persistence context был закрыт, либо экземпляр был удалён из него)

4. removed — сущность имеет идентификатор и связана с persistence context, но она запланирована к удалению из базы данных.

Передвижение объекта из одного состояния в другое выполняется вызовом методов EntityManager:
persist()
merge()
remove()

Flush происходит в трех ситуациях:
	-Когды вы делает commit транзакции Hibernate
	-До того как выполняется запрос в БД
	-Когда вы вызываете entityManager.flush()

Lazy loading
Ленивая загрузка определяет будет ли дочерний объект загружен при загрузке объекта-родителя. Она настраивается свойством Lazy для дочернего объектв в файле маппинга объекта-родителя. По-умолчанию это свойство и так стоит в true.
Hibernate не поддерживает ленивую загрузку для объектов не в сессии.

============================================================================
ЗАПРОСЫ
1) JPQL / HQL
	преимущество: легко можно перейти между БД (единые запросы)
2) Native
	с версии 4.3.0 делается flush перед выполнением нативных запросов

SQLQuery sql = session.createSQLQuery("update author ...");
sql.addSynchronizedEntityClass(Author.class);			// синхронизировать БД и Кеш
sqlQuery.executeUpdate();

3) Criteria API
	удобно выполнять динамические запросы к бд
============================================================================
N + 1 SELECT
one-to-many (вложенные коллекции) и их перебор
= как ограничить количество запросов к БД к минимуму?
решается с помощью JOIN FETCH = hibernate получает ассоциированные объекты и коллекции одним SELECT используя OUTER JOIN
		JOIN FETCH и пагинация не работают единовременно
	 	
============================================================================
get() & load()

session.get(Book.class, bookId) - будет обращаться к БД (ну или найдет объект в кеше) и вернет инициализированный прокси. Если объект не будет найден, вернется null. Когда мы обращаемся к ленивым полям, они загружаются.

session.load(Book.class, bookId) - вернется неинициализированный прокси, обращения к базе вообще не будет.
============================================================================
CASH

(First Level Cache)
это кэш сессии, является обязательным.
Данные кешируются в persistence context.

(Second level Cache)
Является необзательным (опциональным). Его нужно включать явно (есть разные реализации).
Данные кешируются среди entity manager

(Query Cache)
Кеш запросов.
============================================================================
@Embedded	денормализация БД
@Embeddable
============================================================================
ОБЪЕКТЫ

       /**
         * SessionFactory - это глобальная фабрика, ответственная за конкретную базу данных.
         *  её основная задача: создание сессий. Нужно позаботиться о том, что-бы этот объект
         *  создавался в единственном экземпляре (singleton, static).
         *
         * Configuration - используется для создания объекта SessionFactory
         *  и конфигурирует сам Hibernate с помощью конифигурационного XML-файла
         */
        sessionFactory = new Configuration().configure().buildSessionFactory();

        /**
         * Session - исползуется для получения физического соединения с БД.
         *  Cоздание, чтение, изменение и удаление объектов происходит через объект Session.
         *
         * Transaction - единица  работы с БД, транзакции обрабатываются менеджером транзакций.
         *
         * Алгоритм работы:
         * - открыли сессию
         * - создали транзакцию
         * - выполнили необходимое действие с бд
         * - завершаем транзакцию
         * - закрываем сессию
         */
        session = sessionFactory.openSession();

	Transaction transaction = session.beginTransaction();
	...	//действия над БД 
	transaction.commit();

	session.close();
        sessionFactory.close();
		
============================================================================
ЭНТИТИ	
		
/**
 * '@Entity'
 * Эта аннотация указывает Hibernate, что
 * данный класс является сущностью (entity bean).
 * <p>
 * '@Table'
 * Указывает с какой именно таблицей необходимо связать (map) данный класс.
 * эта Аннотация имеет различные аттрибуты, с помощью которых мы можем указать
 * имя таблицы, каталог, БД и уникальность столбцов в таблец БД.
 */
@Entity
@Table(name = "HIBERNATE_DEVELOPERS")
public class AnnotationDeveloper {
    /**
     * '@Id'
     * Указывает первичный ключ (Primary Key) данного класса.
     * '@GeneratedValue'
     * Эта аннотация используется вместе с аннотацией @Id и
     * определяет такие паметры, как strategy и generator.
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    /**
     * '@Column'
     * Определяет к какому столбцу в таблице БД относится конкретное поле класса (аттрибут класса).
     *
     * Наиболее часто используемые аттрибуты аннотации @Column:
     * name - Указывает имя столбца в таблице
     * unique - Определяет, должно ли быть данноезначение уникальным
     * nullable - Определяет, может ли данное поле быть NULL, или нет.
     * length - Указывает, какой размер столбца (например колчиство символов, при использовании String).
     * */
    @Column(name = "DEVELOPER_ID")
    private int id;
    @Column(name = "NAME")
    private String name;
    @Column(name = "EXPERIENCE")
    private int experience;

    /**
     * В POJO обязательно должен быть явно инициализирован
     * конструктор по-умолчанию
     */
    public AnnotationDeveloper() {
    }

    public AnnotationDeveloper(String name, int experience) {
        this.name = name;
        this.experience = experience;
    }

    /*
     * Getters and Setters
     */
    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getExperience() {
        return experience;
    }

    public void setExperience(int experience) {
        this.experience = experience;
    }

    @Override
    public String toString() {
        return "Developer id=" + id +
                ", name='" + name +
                ", experience=" + experience;
    }
}

============================================================================
ЛОГИ

show_sql (см. конфигурационнный файл)
Log4JDBC (библиотека)

============================================================================
для 3.6 версии
https://www.youtube.com/watch?v=YzOTZTt-PR0
Босиком по граблям.

1. equals и hashcode
Для этих методов важен контекст.

Для каждой сущности нужно определить "уникальный бизнес ключ"
Но как?! id нельзя(он генерится сам), а уникальность определяется набором полей, а значение полей может менятся... 

Включать ли дочерние колекции?! (нагрузка на цпу - декартово выражение)  

РЕШЕНИЕ: 	- реализовать сравнение сущностей, на уроне гибернейт.
		- рандомизировать ключ

2. Mutable objects (все поля final)
А нельзя сделать мьютбл! Нужен конструктор по умолчанию.

3. DTO pattern должен решить эту проблему, но этот паттерн только делает проблему шире. Тоесть это надстройка над проблемой, а не её решение. Добавляет дубликаты.

4. LazyInitializationException
-Либо всё медленно, либо мучаемся с ошибкой.
-Персистентные коллекции не сериализуется!

5. Criteria API или HQL
-C-API и HQL не взаимозаменяемы.
-Делаем паттерн билдер для HQL и получаем... свою критериа!!!
-HQL не понимает NULL

6. Чтобы обновить одно поле нужно прочитать всю энтити
или используй HQL... но зачем тогда hibernate

7.  Для апдейта и делета hibernate создаёт временные таблицы!

8. Композитные ключи требуют создания отдельного класса?

9. parent-child почему можно менеджить только с одной стороны... и тут проблема 2

10. Flush + try-cath = не упадёт по констрейнту (он проверятся на коммите!!!)
ну и вообще это разделение... (entity changes are persisted)

11. Работа с грязными сущностями. И их невалидная вставка

12. Документация слишком проста устройство слишком сложнО

13. Hibernate сам в БД не ходит, он работает через JDBC! Да.

