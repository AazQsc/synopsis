НЕКОТОРЫЕ ЗАМЕТКИ ПО JAVA

-------------- Оглавление --------------
- PROFILING
- SERIALIZATION
- JMM
- Java HotSpot VM
- Размер объекта в java
- DEBUG
- GENERICS
- CLASSLOADING
- ENUM
- STATIC
- REFLECTION 
- EXCEPTIONS
-
----------------------------------------

 
================================================================================================================
PROFILING

Java Visual VM <--- можно подключаться к существующим java-процессам и получать о них некоторую информацию.


================================================================================================================
SERIALIZATION

Свойства класса помеченные модификатором transient или static не сериализуются*.

Способы применения:
- обычно в таких полях хранится промежуточное состояние объекта, которое, к примеру, проще вычислить, чем сериализовать, 
  а затем десериализавать. 
- ссылка на экземпляр объекта, который не требует сериализации или не может быть сериализован.

* есть мы определяем методы readObject и writeObject, то такие поля сериализовать можно; можно и при Externalization

----------------------------------------------------------------------------------------------------------------
Для построения родителей объекта, если они не были отмечены как Serializable, будет вызываться конструктор.

----------------------------------------------------------------------------------------------------------------
Любой реализующий интерфейс Externalizable класс обязан иметь public конструктор без параметров!
Такие объекты при десериализации строятся путем вызова конструкторов.
Объекты сериализованные с использованием Serializable будут строиться через механизм reflection.

----------------------------------------------------------------------------------------------------------------
Использование readExternal/writeExternal сильно выигрывает в производительности над writeObject/readObject.

----------------------------------------------------------------------------------------------------------------
Безопасность данных:

Правило 1. 
После десериализации объекта необходимо проверить его внутреннее состояние (инварианты) на правильность, 
точно так же, как и при создании с помощью конструктора. Если объект не прошел такую проверку, необходимо 
инициировать исключение java.io.InvalidObjectException.

Правило 2. 
Если в составе класса A присутствуют объекты, которые не должны быть доступными для изменения извне, 
то при десериализации экземпляра класса A необходимо вместо этих объектов создать и сохранить их копии.

----------------------------------------------------------------------------------------------------------------
Для того чтобы запретить сериализацию можно переопределить метод:
Object readResolve() throws ObjectStreamException
и выбрасывать в нём:
throw new InvalidObjectException

----------------------------------------------------------------------------------------------------------------
полезная ссылка: http://www.skipy.ru/technics/serialization.html


================================================================================================================
JMM

В рунтайме jvm может иметь 6-ть областей памяти (jmm java 8). 

Области уникальные для каждого потока: 
  1. pc (program counter) - разные указатели и мета-информация о потоке 
  2. jvm stack - то что мы и привыкли называть стеком, здесь хранятся фреймы (инфа о текущем запущенном методе) 
  3. Native Method Stacks - отдельный стек для нативных методов 
Общие области: 
  4. Heap - хранилище объектов и область владения сборщика мусора 
  5. Method Area - хранит структуры каждого класса, такие как пул постоянной времени ( run-time constant pool) выполнения, 
  данные полей и методов, а также код методов и конструкторов, включая специальные методы, используемые при инициализации класса и
  экземпляра и инициализации интерфейса. И самое интересное: Method Area может как обрабатываться сборщиком, так и нет! 
  Если нет она будет очищена после инициализации классов и запуска программы. 
  6. Run-Time Constraut Pool (как часть Method Area).

HEAP
 _____________________________
| 
| Method Area
|  ___________________________
| |
| | Run-Time Constraut Pool
| |  ___________________________
| | |
| | | 


Путаница возникает когда начинают смешивать понятия "область памяти" и "области работы сборщика мусора".
Основная область обитания GC - heap, именно пространство хипа он условно делит для себя на young и tenured дженерэйшен. 
И вот тут фокус покус: если мы разрешаем GC лезть в область Method Area от GC ставит галочку для себя мол это отдельное пространство 
за которым он должен следить и для себя он отмечает это отдельное пространство как Methaspace или иначе - Class Metadata. 
В Class Metadata кроме Method Area, ещё входит информация о том что находится в Run-Time Constraut Pool. И в целом говорить о том, 
что heap делится там на tenured и young дженерэйшн не совсем корректно. Heap не на что не делится. А вот при работе с 'неделимым' 
хипом GC помечает для себя отдельные области (т.е. это GC для себя делит хип). Точно также Methaspace - это некий термин который мы 
используем когда говорим о маркёрах GC. А области памяти такой нет. Поправьте если я что-то неправильно понимаю. 
----------------------------------------------------------------------------------------------------------------
links:
https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5 
https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/generations.html#sthref16 
https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/considerations.html#sthref62

================================================================================================================
Java HotSpot VM

Гипотеза о поколениях - вероятность смерти как функция от возраста снижается очень быстро. То есть - почти все умрут сразу, но если 
ты сразу не умер то вероятность того что ты выживешь будет возрастать со временем. Подавляющее большинство объектов создаются на очень 
короткое время, они становятся ненужными практически сразу после их первого использования.

Некоторые следствия:
- при очистке мусора нужно сосредоточиться на проверке и удалении объектов, которые были созданы совсем недавно;
- работа с молодым поколением и старым поколением должна быть организована по разному (физическое расположение в памяти,
  алгоритм очистки мусора и.т.п.);
  
Критерии оценки GC:
- Максимальная задержка — максимальное время, на которое сборщик приостанавливает выполнение программы для выполнения одной сборки. 
  Такие остановки называются stop-the-world (или STW).
- Пропускная способность — отношение общего времени работы программы к общему времени простоя, вызванного сборкой мусора, 
  на длительном промежутке времени.
- Потребляемые ресурсы — объем ресурсов процессора и/или дополнительной памяти, потребляемых сборщиком.
- Количество и время жизни promptness (проворных) объектов - объект так называется от момента, когда объект стал нам не нужен, 
  до момента его фактического удаления из памяти.

Java HotSpot VM предоставляет разработчикам на выбор четыре различных сборщика мусора:
- Serial (последовательный) -XX:+UseSerialGC
- Parallel (параллельный) -XX:+UseParallelGC
- Concurrent Mark Sweep (CMS) -XX:+UseConcMarkSweepGC
- Garbage-First (G1) -XX:+UseG1GC

Обалденный цикл статей про сборщиков мусора в java:
part 1 https://habr.com/ru/post/269621/
part 2 https://habr.com/ru/post/269707/
part 3 https://habr.com/ru/post/269863/


================================================================================================================
Размер объекта в java.

Из чего состоит объект:
 1. Заголовок объекта (8 байт для 32 разрядных систем, 16 байт для 64 разрядных)
 2. Память для примитивных типов (размер примитивных типов известен из документации)
 3. Память для ссылочных типов (+ размер ссылки: в 32-х разрядных JVM обычно 4 байта, в 64-х разрядных - 8 байт)
 4. Смещение/выравнивание* ** — по сути, это несколько неиспользуемых байт, что размещаются после данных самого объекта. 
 Это сделано для того, чтобы адрес в памяти всегда был кратным машинному слову, для ускорения чтения из памяти + уменьшения количества
 бит для указателя на объект + предположительно для уменьшения фрагментации памяти. В java размер любого объекта кратен 8 байтам.

*Смешение не учитывается при сериализации, то есть сериализованный объект может занимать меньше места.
Кроме того при сериализации может будыть добавлен иной header, размер которого будет отличаться в зависимости от того какую jvm мы 
используем, разрядности системы, и (при записи в файл) от OC.

Размер объекта в оперативной памяти != результирующующей длинне потока бит при сериализации.
Вот ещё почему это не верно:
String в памяти ~ это массив чар (каждый char не менее 2 байтов)
String при сериализации String кодируются UTF-8, поэтому любое содержимое ASCII занимает в два раза меньше места.

** Пример: если объем потребляемой памяти на заголовок, память для примитивных типов, память для ссылочных 
типов равен 60 байт, то размер блока смещения будет - 4 байта

----------------------------------------------------------------------------------------------------------------
Пример 1

создаём - new String(«a»)

Поля в слассе String:
    private final char value[];
    private final int offset;
    private final int count;
    private int hash;

new String()
 Заголовок: 16 байт
 Поля int: 4 байта * 3 == 12 байт
 Ссылочная переменная на объект массива: 8 байт
 Выравнивание для кратности 8 : 4 байта
 Итого: 40 байта

new char[1]
 Заголовок: 16 байт + 8 байта на длину массива == 24 байт
 Примитивы char: 2 байта * 1 == 2 байта
 Выравнивание для кратности 8 : 6 байт
 Итого: 32 байта

Итого, new String("a") == 72 байта (в 64 разрядной системе)

Важно помнить что было использовано 10 байт для выравнывания кратности.
То есть теоритический объект содержащий строку и ещё одно поле типа int, также будет иметь размер 72 байта
И ещё останется 6 байт зарезервированыых для выравнивания кратности.

----------------------------------------------------------------------------------------------------------------
Пример 2

Дано:	объект - new Man()
	объект содержит поля int и String
	int i = 1
	String s = "a"
	
	размер этого объекта = 72 байта (включая 6 байт зарезервированыых для выравнивания кратности)

	Зададим новое значение переменной типа String
	s = "mynewa"

	добавив 5 символов мы изменили размер на 2 * 5 = 10 байт

	Считаем новый размер: 72 - 6(резерв.) + 10 = 76 байт ---> Выравнивание для кратности 8 ---> + 4 байта
	итого, новый размер объекта 80 байт.
	
----------------------------------------------------------------------------------------------------------------
links:
https://habrahabr.ru/post/134102/
https://www.javaworld.com/article/2077408/core-java/sizeof-for-java.html


----------------------------------------------------------------------------------------------------------------
Как программно узнать размер объекта а java?

Есть несколько способов:
	Решения "из коробки"
	 1. Использовать jdk.nashorn.internal.ir.debug.ObjectSizeCalculator
	 2. Использовать java.lang.instrument.Instrumentation
	"Самописные" решения
	 3. Использовать Java Reflection API - алгоритм работы аналогичен нашим вычислениям в примерах к теории.
	 4. Использовать разницу Runtime.totalMemory() - Runtime.freeMemory()

----------------------------------------------------------------------------------------------------------------
1. ObjectSizeCalculator

	import jdk.nashorn.internal.ir.debug.ObjectSizeCalculator;

	Man man = new Man();
	ObjectSizeCalculator.getObjectSize(man); // вернёт long - размер в байтах

Сигнатура метода:
	public static long getObjectSize(Object obj){ ... }

----------------------------------------------------------------------------------------------------------------
2. public interface Instrumentation

Для реализации этого интерфейса необходимо указать класс который его использует как premain-class (Manifest.mf)
И использовать как jar

	public class ObjectSizeFetcher {
	    private static Instrumentation instrumentation;

	    public static void premain(String args, Instrumentation inst) {
		instrumentation = inst;
	    }

	    public static long getObjectSize(Object o) {
		return instrumentation.getObjectSize(o);
	    }
	}

	public class C {
	    private int x;
	    private int y;

	    public static void main(String [] args) {
		System.out.println(ObjectSizeFetcher.getObjectSize(new C()));
	    }
	}

link:
https://docs.oracle.com/javase/7/docs/api/java/lang/instrument/Instrumentation.html

--------------------------------------------------------------------------------
3. Использовать Java Reflection API

Алгоритм работы аналогичен нашим вычислениям в примерах к теории.

	Размер заголовка
	Считаем замер полей
	Считаем размер ссылок
	Не забываем про выравнивания для кратности.

Пример с использованием sun.misc.Unsafe:
https://stackoverflow.com/questions/9368764/calculate-size-of-object-in-java

--------------------------------------------------------------------------------
4. Использовать разницу Runtime
Далеко не универсальный способ, но, когда он подходит, хорошо работает.

Алгоритм

	1. Создаем группу объектов
	2. Получаем разницу Runtime.totalMemory() - Runtime.freeMemory() = firstSize
	3. Удаляем объекты, вызвав gc
	4. Получаем разницу Runtime.totalMemory() - Runtime.freeMemory() = secondSize
	5. SizeOfObj = (firstSize - secondSize) / n

пример:
https://www.javaworld.com/article/2077496/testing-debugging/java-tip-130--do-you-know-your-data-size-.html

--------------------------------------------------------------------------------
links (размер объектов, как программно узнать размер объекта а java):
  Аналогичные проблемы (это переводы, оригинальные ссылки на stackoverflow)
    http://qaru.site/questions/15149/calculate-size-of-object-in-java
    http://qaru.site/questions/15105/in-java-what-is-the-best-way-to-determine-the-size-of-an-object
  Библиотеки
    https://sourceforge.net/projects/sizeof/
    http://openjdk.java.net/projects/code-tools/jol/


================================================================================================================
DEBUG

Пример настроек для дебага

 -Xdebug ^
 -Xnoagent ^
 -Xrunjdwp:transport=dt_socket,address=18766,server=y,suspend=y ^


================================================================================================================
GENERICS 

Generic - средство обобщенного программирования в джава, позволяющее работать с обобщенными типами.
		-  гарантируют type save.
		
Generic Type - сласс или тип параметризованный типом.

tutorial: https://docs.oracle.com/javase/tutorial/java/generics/index.html
habr: https://habr.com/ru/post/207360/
и вот habr: https://habr.com/ru/company/sberbank/blog/416413/

<? extends Number>			- Upper Bounded Wildcards - тип выше по иерархии чем Number (например Integer). Covariance.
<?>					- Unbounded Wildcards - по сути обозначение того, что тип неизвестен
<? super Integer>			- Lower Bounded Wildcards - тип ниже по иерархии чем Integer (например Number). Contravariance.
  
принцип PECS (Producer Extends Consumer Super)*:
1)	Covariance <? extends E> - выступает как Producer
	Из ковариантной структуры можно производить чтение, но нельзя производить запись
2)	Contravariance <? super E> - выступает как Consumer
	Контравариантная структура работает наоборот - запись разрешена, чтение запрещено
*(подробнее: конспект по Дж. Блоху ст. №28)

На память: очевидно, что мы не можем копировать отсюда <? extends E> сюда <? extends E>... вам очевидно? Подумай. Нарисуй.
Вот вам и PECS. = )

--------------------------------------------------------------------------------
Нельзя параметризовать:
- Классы, имеющие в предках Throwable
- Анонимные классы
- Enum

--------------------------------------------------------------------------------
Пример циклического дженерика:

	BaseStream<T, S extends BaseStream<T,S>> {
		S sequential()
		S parallel()
	}
	
	Stream<T> extends BaseStream<T, Stream<T>>

Нам может пригодиться этот паттерн в том случае, если нужно будет вызывать из родительского класса метода, так
будто они вызваны не из родительского, а из производного класса.

================================================================================================================
CLASSLOADING

classloading - процес динамической загрузки байт-кода в jvm, во время runtime.

Для того, чтобы получить работающий в JVM код, необходимо выполнить три этапа:
 1. Загрузка байт-кода из ресурсов и создание экземпляра класса Class
	Иерархия загрузчиков:
	> Bootstrap – базовый загрузчик, также называется Primordial ClassLoader - загружает стандартные классы JDK из архива rt.jar
	> Extension ClassLoader – загрузчик расширений - загружает классы расширений (находятся в каталоге jre/lib/ext, но могут быть 
	  заданы системным свойством java.ext.dirs)
	> System ClassLoader – системный загрузчик - загружает классы приложения, определенные в переменной среды окружения CLASSPATH
	> Пользовательский ClassLoader, если он есть...
 2. Связывание (linking)
	Три стадии связывания:
	1 - Verification, происходит проверка корректности полученного байт-кода (синтаксис?).
	2 - Preparation, выделение оперативной памяти под статические поля и инициализация их значениями по умолчанию.
	3 - Resolution, разрешение символьных ссылок типов, полей и методов.
 3. Инициализация полученного объекта
	- явная инициализация полей нашими значениями происходит тут.   

в Java реализована отложенная (или ленивая, Lazy) загрузка классов. Загрузка классов ссылочных полей загружаемого класса 
не будет выполняться до тех пор, пока в приложении не встретится явное к ним обращение.
 
Здоровая статься по ClassLoader: http://java-online.ru/java-classloader.xhtml


================================================================================================================
ENUM - перечисление (как правило, это логический связанные константы)

Некоторые методы enum:
- values() - возвращает массив всех констант перечисления
- ordinal() - возвращает порядковый номер определенной константы


================================================================================================================
STATIC

Как понять, что нам нужно сделатть метод статическим?
Спросите себя: "Имеет ли смысл вызывать этот метод, даже если Obj еще не построен?". Если да, то метод вполне может быть статическим.


================================================================================================================
REFLECTION 

Рефлексия (от позднелат. reflexio — обращение назад) — это механизм исследования данных о программе во время её выполнения. 
Рефлексия позволяет исследовать информацию о полях, методах, аннотациях, конструкторах классов и т. п..

Тот самый пример в котором мы получаем доступ к приватному полю:
  Field field = myClass.getClass().getDeclaredField("name");
  field.setAccessible(true);
  field.set(myClass, (String) "new value");

Тот самый пример в котором мы вызываем приватный метод:
  Method method = myClass.getClass().getDeclaredMethod("printData");
  method.setAccessible(true);
  method.invoke(myClass);

Тот самый пример в котором мы создаем экземпляр класса через рефлексию:
  Class clazz = Class.forName(MyClass.class.getName());
  MyClass myClass = (MyClass) clazz.newInstance();			//нужен конструктор по-умолчанию

Тот самый пример в котором мы создаем экземпляр клкласса используя кастомный конструктор через рефлеексию:
  Class clazz = Class.forName(MyClass.class.getName());
  Class[] params = {int.class, String.class};
  MyClass myClass = (MyClass) clazz.getConstructor(params).newInstance(1, "default2");


================================================================================================================
EXCEPTIONS

+ в ситуации consumer-produser (например, написание библиотеки) produser часто не знает как должна обрабатываться исключительная ситуация,
  но он может сгенерировать исключение в котором будет описана проблема и делегировать consumer'у обработку;
+ программист явно видит полный и правильный список исключений, которые могут возникнуть в данном месте программы, и может написать на 
  каждое из них осмысленный обработчик вместо того, чтобы создавать «на всякий случай» общий обработчик всех исключений, одинаково 
  реагирующий на все нештатные ситуации
+ использование исключений в целях контроля ошибок повышает читаемость кода, так как позволяет отделить обработку 
  ошибок от самого алгоритма;
+ обработка ошибок может быть централизована в аспектах;
+ компилятор может следить за обработкой исключений - обязывать их обработку;

- нельзя передавать исключения между частями программы, написанными на разных языках;
- поддержка исключений усложняет язык и компилятор;
- снижает скорость работы программы(так как стоимость обработки исключения, как правило, выше стоимости обработки кода ошибки);
- корректная реализация исключений может быть затруднительной в языках с автоматическим вызовом деструкторов;
- код, рассчитанный на работу с исключениями, теряет линейность и предсказуемость (Джоэл Спольски)
- возможны нагромождения операторов;
- компилятор может обязать обработать исключение с которым разработчик на своем уровне ничего сделать не может;

Альтернативой для системы обработки исключений будет использование кодов ответов.





