
	+++++++++++++++++++++++++++++++++++++++
	+++ СОЗДАНИЕ И УНИЧТОЖЕНИЕ ОБЪЕКТОВ +++
	+++++++++++++++++++++++++++++++++++++++

_______________________________________________________________________________________
Статья 1. Рассмотрите возможность замены конструкторов статическими фабричными методами

 + 1е преимущество стат. фабричного метода состоит в том, что, в отличие от конструкторов, он имеет НАЗВАНИЕ.
 + 2е преим-во стат. фабр. методов заключается в том, что, в отличие от конструкторов, они НЕ ОБЯЗАНЫ при каждом вызове СОЗДАВАТЬ новый ОБЪЕКТ.*
 + 3е преим-во стат. фабр. метода заключается в том, что, в отличие от конструктора, он может возвратить объект, который соответствует не только заявленному типу возвращаемого значения, но и любому его подтипу.
 + 4е преи-во стат. фабр. методов заключается в том, что они уменьшают многословие при создании экземпляров параметризованных типов.**

 - 1й недостаток использования только стат. фабр. методов - классы, не имеющие открытых или защищённых конструкторов, не могут иметь подклассов.
 - 2й недостаток стат. фабр. методов состоит в том, что их трудно отличить от других статических методов.

 некоторые типичные имена статических фабричных методов:
	• valueOf — возвращает экземпляр, который, грубо говоря, имеет то же значение,
	что и его параметры. Статические фабричные методы с таким названием
	фактически являются операторами преобразования типов.
	• of — более краткая альтернатива для valueOf , популяризированная классом
	EnumSet (статья 32).
	• getInstance — возвращает экземпляр, который описан параметрами, однако
	говорить о том, что он будет иметь то же значение, нельзя. В случае с синглтоном
	этот метод возвращает единственный экземпляр данного класса. Это название
	является общепринятым в системах с предоставлением услуг.
	• newInstance — то же, что и getInstance , только newInstапсе даёт гарантию, что
	каждый экземпляр отличается от всех остальных.
	• getType — то же, что и getInstance , но используется, когда фабричный
	метод находится в другом классе. Туре обозначает тип объекта, возвращённого
	фабричным методом.
	• newType — то же, что и newInstance , но используется, когда фабричный
	метод находится в другом классе. Туре обозначает тип объекта, возвращённого
	фабричным методом.
 
 * Возможно создать класс с контролем экземпляров (instance-controlled).
 ** уже не так актуально (после java 7 только один раз указываем, чем параметризуем а компилятор всё сделает за нас)


_______________________________________________________________________________________________________________
Статья 2. Используйте шаблон Builder*, когда приходится иметь дело с большим количеством параметров конструктора**

   Альтернативы:
	1. шаблон “телескопический конструктор”  - нормально работает, но становится трудно писать код программы-клиента, 
	когда имеется много параметров, а ещё труднее этот код читать.
	2. Пустой конструктор + сеттеры (JavaBeans использует такой подход). Но JavaBean может находиться в неустойчивом состоянии во время создания.
 	А ещё шаблон JavaBeans исключает возможность сделать класс неизменяемым!

 + Это потокобезопасно и легко читается. И нет сложностей с "промежуточным" объектом.
 + Шаблон билдера имитирует именованные дополнительные параметры, имеющиеся в таких языках, как Ada и Python.

 - Для создания объекта вам надо сначала создать его билдер.

 * Билдер является статическим внутренним классом в классе, который он создаёт.
 ** Более четырёх.


________________________________________________________________________________________________________
Статья 3. Обеспечивайте уникальность синглтонов с помощью закрытого конструктора или перечислимого типа*

 + лучшим решением для реализации синглтона является перечислимый тип с одним элементом

 - Превращение класса в синглтон может создать сложности в тестировании его клиентов, так как невозможно заменить синглтон на фиктивную реализацию.

 * ещё можно через статику 


____________________________________________________________________________________________
Статья 4. Используйте закрытый конструктор* для предотвращения создания экземпляров класса**

 * нельзя создать наследника, final - избыточно, но рекомендуют сделать эту пометку (см. java.lang.Math).
 ** возможно мы имеем дело с классом утилитой и он содержит только статические поля и методы 


_______________________________________________
Статья 5. Избегайте создания ненужных объектов*

	Но помни !
	Явная и красивая структура при которой мы создадим несколько лишних объектов, наверняка лучше
	запутанной и сложной структуры, в которой мы имеем только самые необходимые объекты.
	Это связано с тем, что часто мы не так уж и сильно ограничены в рессурсах, а ещё современные jvm хороши.
	
	- immutable - всегда можно использовать повторно
	- пулы соединений, потоков... - только для очень ресурсоемких по созданию объектов
	- Внутри метода часто создаются тронг ссылки, например new LocalDate? - вместо них статический блок инициализации.
	- предпочитайте примитивные типы классам-обёрткам и избегайте непреднамеренного автоупаковывания.

 * переиспользование объектов может быть и изящнее, и быстрее.


__________________________________________________________
Статья 6. Уничтожайте устаревшие ссылки на объекты* ** ***

 Когда?
	 1. Как только какой-либо класс начинает управлять своей памятью, программист должен озаботиться предотвращением утечек памяти.
	 2. Кеши (легко утерять там ссылку)
	 3. обработчики событий (listeners) и прочие обратные вызовы.

 + NullPointerException вместо неккоректного продолжения работы.
	
 * это означает, что нужно быть внимательным, и в тот момент, когда есть вероятность непреднамеренного сохранения объекта (unintentional object retention)
   нужно явно обнулять ссылку на него.
 ** Обнуление ссылок на объекты должно быть не нормой, а исключением. Иначе мы получим очень заграможденный код.
 *** используй heap profiler


_________________________________________
Статья 7. Остерегайтесь методов finalize*

 Используй методы явного закрытия + блоки try-finally

 Начиная с Java 7, желательно реализовывать в классах, требующих явного закрытия, интерфейс AutoCloseable или один из его подинтерфейсов, например,
 Closeable. Это позволит применять объекты такого класса в блоке try с ресурсами, гарантируя вызов метода close при любом завершении блока — как нормальном, 
 так и по исключению.

 FileInputStream , FileOutputStream , Timer и Connection имею метод finalize как страховочную сетку (лучше поздно, кидает исключение).

 Если мы переопределяем метод finalize то необходимо явно вызвать finalize предка, иначе он не будет вызван.

 * в методе finalize нельзя выполнять никаких операций, критичных по времени.
   производительность просто ужасающим образом понижается при использовании методов finalize!




	++++++++++++++++++++++++++++++++++++++
	+++ МЕТОДЫ ОБЩИЕ ДЛЯ ВСЕХ ОБЪЕКТОВ +++
	++++++++++++++++++++++++++++++++++++++


___________________________________________________________________
Статья 8. Переопределяя метод equals, соблюдайте его общий контракт

 Когда не надо?
	точно знаем, что все объекты разные
	перечисления
	есть контроль типов (?)
	хотим запретить (кидаем ошибку)
 
 Метод equals реализует отношение эквивалентности (equivalence relation). 
 Это означает, что он должен обладать следующими свойствами:
	• Рефлексивность: Для любой ненулевой ссылки х выражение x.equals(x) должно
	возвращать true .
	• Симметричность: Для любых ненулевых ссылок х и у выражение x.equals(y)
	должно возвращать true тогда и только тогда, когда у.equals(x) возвращает
	true.
	• Транзитивность: Для любых ненулевых ссылок х , у и z , если х.equals(y)
	возвращает true и у.equals(z) возвращает true , то и выражение х.equals(z)
	должно возвращать true.
		Фундаментальная проблема отношений эквивалентности в объектно-ориентированных языках:
		не существует способа расширить класс, порождающий экземпляры, и добавить к нему компонент значения,
		сохранив при этом контракт метода equals.
 		 Если сделать проверку на равенство классов, нарушим принцип подстановки Барбары Лисков
		 Отчасти проблему решает абстрактный родитель.
	• Непротиворечивость: Для любых ссылок х и у , если несколько раз вызвать
	х.equals(y) , постоянно будет возвращаться значение true либо постоянно будет
	возвращаться значение false при условии, что никакая информация, которая
	используется при сравнении объектов, не поменялась.
		Не ставьте метод equals в зависимость от ненадёжных ресурсов!
	• Отличие от null. Для любой ненулевой ссылки х выражение х.equals(null) должно возвращать false.
		Мы проверяем на равенство классов, явная проверка на null не нужна

 Рецепт для создания высококачественного метода equals:
  1. Используйте оператор == для проверки, является ли аргумент ссылкой на тот же объект.
  2. Используйте оператор instanceof для проверки, имеет ли аргумент правильный тип.
  3. Приведите аргумент к правильному типу.
  4. Пройдитесь по всем «значимым» полям класса и убедитесь в том,
     что значение этого поля в аргументе и значение того же поля в объекте соответствуют друг другу.
	• Для float и double используй Float.compare & Double.compare. Особая процедура обработки полей float и double нужна потому,
	что существуют особые значения Float.NaN , -0.0f , а также аналогичные значения для типа double.
	• Для полей которые могут иметь null:
	(field == null ? о.field == null : field.equals(o.field))
	или (появился метод в java 7)!
	Objects.equals(a, b)
	• Не следует сравнивать поля, которые не являются частью логического состояния объекта.
	• Не ставьте метод equals в зависимость от ненадёжных ресурсов.
  5. Закончив написание собственного метода equals , задайте себе три вопроса:
	является ли он симметричным, является ли транзитивным и является ли непротиворечивым?
	и напиши тест :)

 И ещё!
 	• Переопределяя метод equals , всегда переопределяйте метод hashCode
	• Объявляя метод equals , не указывайте вместо Object другой тип. Используй аннотацию @Override.


______________________________________________________________________
Статья 9. Переопределяя метод equals, всегда переопределяйте hashCode*

 Контракт:
	• Если во время работы приложения несколько раз обратиться к одному и тому же
	объекту, метод hashCode должен постоянно возвращать одно и то же целое число,
	показывая тем самым, что информация, которая используется при сравнении
	этого объекта с другими (метод equals ), не поменялась. Однако, если приложение
	остановить и запустить снова, это число может стать другим.
	• Если метод equals(Object) показывает, что два объекта равны друг другу, то,
	вызвав для каждого из них метод hashCode , вы должны получить в обоих случаях
	одно и то же целое число.
	• Если метод equals(Object) показывает, что два объекта друг другу не равны,
	вовсе не обязательно, что метод hashCode возвратит для них разные числа. Между
	тем программист должен понимать, что генерация разных чисел для неравных
	объектов может повысить эффективность хэш-таблиц.

 Обрати внимание на метод Objects.hash(val1, ..., valN) который появился в java 7:
 @Override 
 public int hashCode() {
 	return Objects.hash(поле1, поле2, поле3);
 }

 И помни!
 Повышение производительности не стоит того, чтобы при вычислении хэш-кода игнорировать значимые части объекта.

 * иначе нарушим второй пункт контракта


________________________________________________
Статья 10. Всегда переопределяйте метод toString

 • Когда это осуществимо на практике, стоит включать в метод toString всю полезную информацию, которая содержится в объекте.
 • Или строка может быть какой-то сводкой, если объект очень сложный.
 • В идеале полученная строка не должна требовать разъяснений.
 • Если нужно соблюсти какой-то формат, помни об этом. Будете вы документировать формат или нет, вы должны чётко обозначить свои намерения.


___________________________________________________________________
Статья 11. Соблюдайте осторожность при переопределении метода clone

 • На практике ожидается, что в классе, реализующем интерфейс Cloneable , должен быть правильно работающий открытый метод clone.
 • Вызывай метод клон рекурсивно
 • При неглубоком клонировании копируются ссылки, будь с этим аккуратнее.
 • архитектура клонирования несовместима с обычным использованием полей final , содержащих ссылки на изменяемые объекты

 Изящный подход к копированию объектов — создание конструктора копии (copy constructor) или фабрики копий (copy factory). 
 Конструктор копии — это всего лишь конструктор, единственный аргумент которого имеет тип, соответствующий классу, где
 находится этот конструктор, например:

 	public Yum(Yum yum);

 Небольшое изменение — и вместо конструктора имеем статический фабричный метод:

 	public static Yum newInstance(Yum yum);


__________________________________________________________________
Статья 12. Подумайте о том, чтобы реализовать интерфейс Comparable

 Этот метод добавляет интерфейс java.lang.Comparable
 Реализуя интерфейс Comparable , класс показывает, что его экземпляры обладают естественным порядком (natural ordering).

 Практически все классы значений в библиотеках платформы Java реализуют интерфейс Comparable. 
 И если вы пишете класс значений с очевидным свойством естественного упорядочивания — алфавитным, числовым либо хронологическим, — вы должны
 хорошо подумать о том, не реализовать ли этот интерфейс.

 Общий контракт для метода comparеTo имеет тот же характер, что и контракт для метода equals:
 Выполняет сравнение текущего и указанного объекта и определяет их очерёдность.
 Возвращает отрицательное целое число, ноль или положительное целое число, в зависимости от того, 
 меньше ли текущий объект, равен или, соответственно, больше указанного объекта. 
 Если тип указанного объекта не позволяет сравнивать его с текущим объектом, выбрасывается исключение ClassCastException.

 В следующем описании запись sgn (выражение) обозначает математическую функцию signum, которая, по определению,
 возвращает -1, О или 1, в зависимости от того, является ли значение выражения отрицательным, равным нулю или положительным:

	• Разработчик должен гарантировать тождество sgn(x.comparеТо(у)) == -sgn(y.
	comparеТо(х)) для всех х и у. (Это подразумевает, что выражение х.comparеТо(у)
	должно выбрасывать исключение тогда и только тогда, когда это делает у.comparеТо(х) .)
	• Разработчик должен также гарантировать транзитивность отношения:
	(х.comparеТо(у) > 0 && у.comparеTo(z) > 0) подразумевает х.comparеTo(z) > 0 
	• Наконец, разработчик должен гарантировать, что из тождества х.comparеТо(у) == 0 вытекает
	тождество sgn(x.comparеTo(z)) == sgn(y.comparеTo(z)) для всех z 
	• Настоятельно (хотя и не безусловно) рекомендуется выполнять условие
	(х.comparеTo(у) == 0) == (х.equals(y)). Вообще говоря, для любого класса,
	который реализует интерфейс Comparable , но нарушает это условие, этот
	факт должен быть чётко оговорён. Рекомендуется использовать следующую
	формулировку: «Примечание: данный класс имеет естественный порядок, не согласующееся с equals».

 Компараторы работают хоть и похоже на эквалс, но есть фундаментальные отличия: там где эквалс укажет на то что два объекта различны, компаратор нашедший 
 равенство будет утверждать об обратном (помни про TreeSet и HashSet при работе с BigDecimal. Кинем BD("1.0"), а затем BD("1.00"), что будет? :) )

 А вот крутой пример из java 8

	public class PhoneNumber implements Comparable<PhoneNumber> {
	    private static final Comparator<PhoneNumber> COMPARATOR =
		Comparator.comparingInt(pn -> pn.areaCode)
		    .thenComparingInt(pn -> pn.prefix)
		    .thenComparingInt(pn -> pn.lineNumber);
	    <...>

	    @Override
	    public int comparеTo(PhoneNumber pn) {
		return COMPARATOR.compare(this, pn);
	    }
	}




	+++++++++++++++++++++++++++
	+++ КЛАССЫ И ИНТЕРФЕЙСЫ +++
	+++++++++++++++++++++++++++


_____________________________________________________________
Статья 13. Сводите к минимуму доступность классов и их членов

  • Access control на максималки --> cделай интерфейс частью пакета (package private), если это возможно и логично.
  • Поля экземпляра никогда не должны быть открытыми --> private поля
     Классы с открытыми изменяемыми полями не являются потокобезопасными.
  • public static final --> константы
  • Практически никогда нельзя объявлять поле массива как public static final; недопустимо также создавать метод доступа, 
	возвращающий ссылку на внутренний массив.

	// Потенциальная дыра в системе безопасности!
	public static final Thing[] VALUES = { ... };

	Решение 1:
	private static final Thing[] PRIVATE_VALUES = { ... };
	public static final List<Thing> VALUES =
		Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));

	Решение 2:
	private static final Thing[] PRIVATE_VALUES = { ... };
	public static final Thing[] values() {
		return PRIVATE_VALUES.clone();
	}


____________________________________________________________________________
Статья 14. В открытых классах используйте методы доступа, а не открытые поля
	
	Но, не стоит для каждого метода get писать метод set.


____________________________________________
Статья 15. Предпочитайте неизменяемые классы

  Неизменяемый класс (immutable) — это просто такой класс, экземпляры которого нельзя изменять. Вся информация, которая содержится в любом его экземпляре, 
записывается в момент его создания и остаётся неизменной в течение всего времени существования этого объекта.

  Если класс невозможно сделать неизменяемым, вы должны ограничить его изменяемость, насколько это возможно.
	
	1. Не создавай методов мутаторов (изменяют состояние класса)
	2. Методы объяви final
	3. Поля объяви final
	4. Сделай все поля private
	5. Если есть ссылочные поля:
		5.1 нельзя чтобы клиенты получили на них ссылки
		5.2 нельзя получать эти ссылки от клиентов
		5.3 в конструкторах, методах доступа к полям и методах readObject (статья 76) 
		    создавайте защитные копии (defensive copies, статья 39).
	6. Опционально: запретить наследование.

	Используй функциональный подход (functional approach), при работе с неизменяемыми классами:
	public Object method(Object o) {
		...
		return new Object(...); 	// то есть мы не изменяем объект и возвращаем его, а возвращаем новый объект, - продукт функции.
	}
	
	Если мы меняем состояние клиента то мы имеем дело с процедурным(императивным, procedural or imperative approach) подходом.


 + Неизменяемые объекты просты. Изменяемые имеют широкое пространство состояний, что сильно усложняет работу с ними.
 + Неизменяемые объекты по своей сути потокобезопасны (thread-safe): им не нужна синхронизация.
 + Нам не нужны копии (резервные) - мы всегда имеем дело с тем же самым объектом. <-- речь о совместном использовании
 + Можно совместно использовать не только неизменяемый объект, но и его содержимое (BigIntegeг и ссылка на массив int внутри).
 + Неизменяемые объекты образуют хорошие строительные блоки для остальных объектов (прочная база для построения сложных объектов)

 - Единственный настоящий недостаток неизменяемых классов заключается в том, что для каждого уникального значения им нужен отдельный объект.
   То есть в определённых условиях будут проблемы с производительностью.


________________________________________________
Статья 16. Предпочитайте композицию наследованию

  Почему? Мы нарушаем принцип инкапсуляции.
  Правильное функционирование подкласса зависит от деталей реализации его суперкласса.

  наследование:
  + Наследование можно безопасно использовать внутри пакета, где реализация и подкласса, и суперкласса 
находится под контролем одних и тех же программистов.
  + Столь же безопасно пользоваться наследованием, когда расширяемые классы специально созданы и 
документированы для последующего расширения (статья 17).
  + Наследование уместно только в тех случаях, когда подкласс действительно является подтипом (subtype) суперкласса.

  Шаблон ДЕКОРАТОР
  композиция:
  1 Создай закрытую ссылку на экземпляр класса(К) функционал которого ты хочешь расширить.
  2 Реализуй одноименные методы в которые К дилегирует отвественность за выполнение своих методов.
  3 Ты получил класс-оболочку(wrapper), произведя переадресацию (forwarding), а методы называются - методы переадресации (forwarding methods).

 - не работают с callback'ами (проблема самоидентификации (SELF problem))


____________________________________________________________________________________
Статья 17. Проектируйте и документируйте классы для наследования либо запрещайте его

  Для класса должно быть документировано, какие из переопределяемых методов он использует сам (self-use): для каждого открытого или защищённого метода, каждого конструктора в документации должно быть указано, какие переопределяемые методы он вызывает, в какой последовательности, а также каким образом результаты их вызова влияют на дальнейшую обработку.

  Java 8
  @implSpec - Implementation Requirements

Но разве это не нарушает авторитетное мнение, что хорошая документация API должна описывать, что делает данный метод, а не то, как он это делает? Конечно, нарушает! Это печальное следствие того обстоятельства, что наследование нарушает принцип инкапсуляции.

 Ещё о наследовании!
 - Конструкторы класса не должны вызывать переопределяемые методы.
 - Единственный способ протестировать класс, спроектированный для наследования — это написать подклассы.
 - избегай интерфейсов Cloneable и Serializable в суперклассе (аналоги конструкторов)
 
 А как быть со всеми остальными классами?
 Люди захотят сделать наследника любого вашего годного класса.
 Наилучшим решением этой проблемы является запрет на создание подклассов для тех классов, которые не были специально разработаны и 
не имеют требуемого описания для безопасного выполнения этой операции.


_______________________________________________________
Статья 18. Предпочитайте интерфейсы абстрактным классам

 + Интерфейсы идеально подходят для создания примесей (mixins).
 + Интерфейсы позволяют создавать структуры типов без иерархии.

 - Берегись комбинаторного взрыва (combinatorial explosion)!

 Единственными ограничениями интерфейсов, из-за которых иногда всё-таки имеет смысл использовать абстрактные классы, является невозможность объявлять в интерфейсах поля экземпляра и конструкторы, а также объявлять методы как final , private или protected.

 А в Java 9 в интерфейсах можно объявлять и private -методы, хотя все остальные ограничения остаются в силе!


______________________________________________________________
Статья 19. Используйте интерфейсы только для определения типов

  Если класс реализует интерфейс, то этот интерфейс должен служить неким типом, который можно использовать для ссылки на экземпляры этого класса. То, что класс реализует некий интерфейс, должно говорить нечто о том, что именно клиент может делать с экземплярами этого класса. Создавать интерфейс для каки-либо иных целей неправомерно!!!

  Шаблон интерфейса констант представляет собой неудачный вариант использования интерфейсов.
  Это ведет к утечке информации через API!
  Если же интерфейс констант реализуется наследуемым классом, константами из этого интерфейса будет засорено пространство имён всех его подклассов.
  (java.io.ObjectStreamConstants).

  А чтоже делать!
  - Используй перечисления
  - Используй классы утилиты (можно вместе со статическим импортом)


___________________________________________________________
Статья 20. Предпочитайте иерархии классов классам с метками

  Классы с метками слишком многословны, чреваты ошибками и неэффективны.


__________________________________________________________________
Статья 21. Используйте объекты-функции для представления стратегий

    1. интерфейс стратегии (strategy interface) <--- это функциональный интерфейс (только один абстрактный метод)
    2. Делаем несколько реализаций стратегий.
    3. Создаем класс в котором будем выбирать стратегию, там должно быть поле strategy interface
    4. В зависимости от ситуации вызываем ту стратегию, которая нам нажна.
       Если подходящей стратегии нет, - реализуем стратегию на лету.

    Начиная с Java 8, интерфейсы с единственным абстрактным методом (функциональные интерфейсы) можно реализовывать лямбда-выражениями:
	Arrays.sort(stringArray, (s1, s2) -> s1.length() - s2.length());
    или даже, ещё лучше:
	Arrays.sort(stringArray, Comparator.comparingInt(String::length));
    JVM оптимизирует обращения к лямбда-выражениям без состояния, переиспользуя один и тот же объект на каждый вызов, так что нет необходимости в ручном кэшировании объекта, как в случае с обычным или анонимным классом.
    

_______________________________________________________________
Статья 22. Предпочитайте статические классы-члены нестатическим

  Класс называется вложенным (nested), если он определён внутри другого класса.

  Существует четыре категории вложенных классов: 
	статический класс-член (static member class), 		просто объявленный внутри, - обычно это такие helper class'ы
	нестатический класс-член (nonstatic member class), 	часто используются для определения адаптера (самая редкая категория и часто ненужная, лучше static)
	анонимный класс (anonymous class) и 			тот который "...на лету", - 
									обычно используется для создания объекта-функции (function object) - компаратор
									или объекта процесса (process object) - Thread , Runnable
									но в java 8 на смену всему этому приходят лямбды
	локальный класс (local class).				- самые редкие из всех, в поле класса на лету варганим класс.



	++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	+++ СРЕДСТВА ОБОБЩЁННОГО ПРОГРАММИРОВАНИЯ (GENERICS) +++
	++++++++++++++++++++++++++++++++++++++++++++++++++++++++


_________________________________________________
Статья 23. Не используйте сырые типы в новом коде

        List strings = new ArrayList();			// плохо, сырой тип
	List<String> strings = new ArrayList<>();	// хорошо

	кроме:
	1. Вы обязаны использовать сырые типы в классовых литералах:
				List<String>.class	// нельзя!
				List.class		// можно!
	2. Вот как предпочтительнее использовать оператор instanceof с обобщёнными типами:
			if (о instanceof Set) { 	// Raw type
			    Set<?> m = (Set<?>) o;	// Wildcard type
			    ...
			}


____________________________________________________________________________
Статья 24. Избавляйтесь от предупреждений о непроверенных операциях с типами

	@SuppressWarnings("unchecked") добавляйте комментарий, в котором объясняйте, почему так делать в данном случае безопасно.


________________________________________
Статья 25. Предпочитайте списки массивам
	
  List<E> лучше чем E[]

1.
  Массивы - ковариантны (covariant) -  если Sub является подтипом Super , тогда тип массива Sub[] является подтипом Supeг[].
  Списки - инвариантны.

2.
  Массивы - реифицированы (reified) - массивы знают и проверяют тип своих элементов при выполнении.
  Списки - реализуются стиранием (erasure) - проверка на этапе компиляции



________________________________________
Статья 26. Предпочитайте обобщённые типы

	@Плохо:
	public class Stack {
		Object[] elements;

		public Stack() {
			elements = new E[DEFAULT_INITIAL_CAPACITY];
		}
	}

	@Хорошо:
	public class Stack<T> {
		T[] elements;

		@SuppressWaгnings("unchecked")
		public Stack() {
			elements = (E[]) new Object[DEFAULT_INITIAL_CAPACITY];
		}
	}


	А если можно сделать без приведений, то вообще круто!


__________________________________________
Статья 27. Предпочитайте обобщённые методы

	@Плохо:
	public static Set union(Set s1, Set s2) {
		Set result = new HashSet(sl);
		result.addAll(s2);
		return result;
	}

	@Хорошо:
	public static <Е> Set<E> union(Set<E> s1, Set<E> s2) {
		Set<E> result = new HashSet<E>(s1);
		result.addAll(s2);
		return result;
	}


___________________________________________________________________________________
Статья 28. Используйте ограниченные подстановочные типы для увеличения гибкости API

	Обобщенные типы - инвариантны, чтобы сделать их более гибкими добавь ограничение..
	Может показаться что обобщенный тип станет менее гибким но нет!

	<? extends E> гибче чем <E>

 Covariance <? extends E> --- <? это предок E>
  Из ковариантной структуры можно производить чтение, но нельзя производить запись
  List<? extends Number> myNums = new ArrayList<Integer>();
  List<? extends Number> myNums = new ArrayList<Float>();
  List<? extends Number> myNums = new ArrayList<Double>();

  Number n = myNums.get(0);	// ок
  myNumst.add(45L); 		//compiler error

 Contravariance <? super E> --- <? является родителем для E>
  Контравариантная структура работает наоборот - запись разрешена, чтение запрещено
  List<Object> myObjs = new List<Object>();
  myObjs.add("Luke");
  myObjs.add("Obi-wan");

  List<? super Number> myNums = myObjs;
  myNums.add(10);
  myNums.add(3.14);

  Number myNum = myNums.get(0); //compiler-error
  ___   ___   ___   ___   ___   ___   ___   ___   ___   ___   ___

  @КОМБО-ВОМБО! (producer — extends , consumer — super )
  public static void copy(List<? extends Number> source, List<? super Number> destiny) {
      for(Number number : source) {
          destiny.add(number);
      }
  }

 Не используйте подстановочный тип в качестве возвращаемого типа.
 Если пользователь класса должен думать о подстановочных типах, значит, что-то не так с API класса.

 Объекты Comparable всегда являются потребителями, так что всегда следует использовать Comparable<? super Т> вместо Comparable<T>.
 То же самое относится и к компараторам, так что вы всегда должны использовать Comparator<? super T> вместо Comparator<T>.



________________________________________________________________________________________
Статья 29. Рассмотрите возможность использования типобезопасных неоднородных контейнеров

  // Шаблон типобезопасного неоднородного контейнера - API
  public class Favorites {
  	  public <T> void putFavorite(Class<T> type, T instance);
	  public <T> T getFavorite(Class<T> type);
  }

  //инстанс
  public class Favorites {
      private Map<Class<?>, Object> favorites = new HashMap<Class<?>, Object>();

      public <T> void putFavorite(Class<T> type, T instance) {
          if (type == null)
              throw new NullPointerException("Type is null");
          favorites.put(type, instance);
      }

      public <T> T getFavorite(Class<T> type) {
 	  return type.cast(favorites.get(type));
      }
  }

	Метод cast — это динамический аналог оператора приведения типа языка Java. Он
	просто проверяет, что его аргумент является экземпляром типа, представленного
	объектом Class.

  // Шаблон типобезопасного неоднородного контейнера - клиент
  public static void main(String[] args) {
	  Favorites f = new Favorites();

	  f.putFavorite(String.class, "Java");
	  f.putFavorite(Integer.class, 0xcafebabe);
	  f.putFavorite(Class.class, Favorites.class);

	  String favoriteString = f.getFavorite(String.class);
	  int favoriteInteger = f.getFavorite(Integer.class);
	  Class<?> favoriteClass = f.getFavorite(Class.class);

	  System.out.printf("%s %x %s%n", favoriteString, favoriteInteger, favoriteClass.getName());
  }

  Если закинуть сюда сырой Class то это сломает наш код.
  Такой код не может использоваться с нереифицируемыми типами (статья 25). Другими словами, 
 вы можете хранить избранный экземпляр String или String[], но не List<String>.




	+++++++++++++++++++++++++++++++++++++
	+++ ПЕРЕЧИСЛИМЫЕ ТИПЫ И АННОТАЦИИ +++
	+++++++++++++++++++++++++++++++++++++


____________________________________________________________
Статья 30. Используйте перечислимые типы вместо констант int

  Для ассоциации данных с перечислимыми константами объявите поля экземпляра и напишите конструктор, который принимает данные и сохраняет их в полях.

	public enum Planet {
		MERCURY(3.302e+23, 2.439e6),
		VENUS (4.869e+24, 6.052e6),

		private final double mass;
		private final double radius;

		Planet(double mass, double radius) {
			this.mass = mass;
			this.radius = radius;
		}
	}

  Используй, чтобы создать уникальное поведение для членов перечисления!
  Константоспецифичные реализации методов (constant-specific method implementations)


	Смесь двух перечислений (PayType - тоже енам)
	enum PayrollDay {
		MONDAY(РауТуре.WEEKDAY), TUESDAY(РауТуре.WEEKDAY),
		WEDNESDAY(РауТуре.WEEKDAY), THURSDAY(РауТуре.WEEKDAY),
		FRIDAY(РауТуре.WEEKDAY),
		SATURDAY(РауТуре.WEEKEND), SUNDAY(РауТуре.WEEKEND);
		
		PayrollDay(PayType payType) {
			this.payType = payType;
		}

		double pay(double hoursWorked, double payRate) {
			return payType.pay(hoursWorked, payRate); // крутой подход!
		}
	}


_______________________________________________________________
Статья 31. Используйте поля экземпляра вместо числовых значений

	Используй поля перечислимого типа.


___________________________________________________
Статья 32. Используйте EnumSet вместо битовых полей

	// EnumSet - современная замена битовым полям
	public class Text {
		public enum Style { BOLD, ITALIC, UNDERLINE, STRIKETHROUGH }

		// Any Set could be passed in, but EnumSet is clearly best
		public void applyStyles(Set<Style> styles) { ... }
	}

	// используем
	text.applyStyles(EnumSet.of(Style.BOLD, Style.ITALIC));


__________________________________________________________________________
Статья 33. Используйте ЕnumМар вместо индексирования по порядковому номеру

	Редко возникает ситуация, когда имеет смысл использовать
	ordinal для индексирования массивов: вместо этого надо использовать EnumMap.


_________________________________________________________________________
Статья 34. Имитируйте расширяемые перечислимые типы с помощью интерфейсов

	енам api наследуется от интерфейса, который диктует логику енам
	пользователь может сделать свою имплиментацию этого интерфейса, таким образом расширив енам


______________________________________________________
Статья 35. Предпочитайте аннотации шаблонам именования

	без аннотации получим ошибку компиляции
	с немправильным именем получим некорректное поведение 


_________________________________________________________
Статья 36. Используйте аннотацию Override последовательно

	нужно использовать аннотацию Override для объявления каждого
	метода, который должен переопределять метод суперкласса.


_________________________________________________________________
Статья 37. Используйте маркерные интерфейсы для определения типов

	+ маркерные интерфейсы определяют тип, который реализуется экземплярами
	  маркированного класса, а маркерные аннотации — нет.
	
	- нельзя маркировать поля и методы (используй маркеры аннотации)

	В некотором смысле эта статья — противоположность статьи 19, в которой говорится:
	«Если вы не хотите определять тип, не используйте интерфейс». В первом приближении
	эта статья говорит: «Если вы действительно хотите определить тип, используйте
	интерфейс».




	++++++++++++++
	+++ МЕТОДЫ +++
	++++++++++++++


_____________________________________________
Статья 38. Проверяйте правильность параметров
	
	Ещё аничения, используйте тег @throws генератора документации Javadoc.
	Если по какой-то причине в методе проверку выполнить мы не можем, например критична производительность метода, 
	 нужно сделать эту проверку до того как аргумент попадет в метод


______________________________________________________
Статья 39. При необходимости создавайте защитные копии

	Вы должны писать программы с защитой, исходя из предположения, что клиенты вашего класса будут предпринимать все возможное для того, 
	 чтобы разрушить его инварианты.

	для каждого изменяемого параметра конструктор должен создавать защитную копию (defensive сору)

	// плохой конструктор
	public Period(Date start, Date end) {
		if (start.compareTo(end) > 0)
			throw new IllegalArgumentException(start + " after " + end);
		this.start = start;
		this.end = end;
	}


	// Исправленный конструктор: для представленных параметров создаёт
	// защитные копии
	public Period(Date start, Date end) {
		this.start = new Date(start.getTime());
		this.end = new Date(end.getTime());
		if (this.start.compareTo(this.end) > 0)
			throw new IllegalArgumentException(start + " after " + end);
	}

	// Исправленные методы доступа: создаются защитные копии
	// внутренних полей
	public Date start() {
		return new Date(start.getTime());
	)
	
	Но это же так ресурсно!

	Если мы в рамках пакета что-то делаем можно обойтись без защитного копирования. 
	При подобных обстоятельствах в документации к классу должно быть чётко объяснено, что вызывающий не должен менять задействованные 
	 параметры или возвращаемые значения.


__________________________________________________
Статья 40. Тщательно проектируйте сигнатуру метода
	
	1. название
	2. не создавай методов, существование которых не оправданно
	3. избегай длинного списка параметров (особенно одного и тогоже типа) ----> используй билдер
	4. тип интерфейса побеждает тип класса
	5. Предпочитайте использовать двухэлементные перечислимые типы вместо параметров boolean.


_____________________________________________________
Статья 41. Соблюдайте осторожность, перегружая методы

	Выбор перегруженных методов осуществляется статически, тогда как выбор переопределённых методов — динамически.

	Безопасная, умеренная политика предписывает никогда не предоставлять два варианта перегрузки с одним и тем же числом параметров.
	тоесть при перегрузке мы уточняем метод добавив параметр


___________________________________________________________________________________________
Статья 42. Соблюдайте осторожность при использовании методов с переменным числом параметров


___________________________________________________________________
Статья 43. Возвращайте массивы и коллекции нулевой длины, а не null

	это ведет к избыточности при обработке null'ов


_____________________________________________________________________
Статья 44. Пишите комментарии Javadoc для всех открытых элементов API

	+ пиши что, а не как
	+ В doc-комментарии необходимо перечислить все предусловия (preconditions), т.е. утверждения, которые должны быть истинными для того, 
	   чтобы клиент мог вызвать этот метод, и постусловия (postconditions), т.е. утверждения, которые будут истинными после успешного завершения вызова.

	  Обычно предусловия неявно описываются тегами @throws для непроверяемых исключений. Каждое непроверяемое исключение соответствует нарушению 
	   некоего предусловия. Предусловия также могут быть указаны вместе с параметрами, которых они касаются, в соответствующих тегах @param.

	+ Помимо пред- и постусловий для методов должны быть также документированы любые побочные эффекты. 
	  Побочный эффект (side effect) — это видимое извне изменение состояния системы, которое не является очевидным требованием для достижения постусловия. 
	  Например, если метод запускает фоновый поток, это должно быть отражено в документации.

	+ Комментарии к документации должны описывать потокобезопасность (thread safety) класса.

	+ В целях полного описания контракта doc-комментарий метода должен включать в себя: тег @param для каждого параметра, тег @return, 
	   если только метод не объявлен как void, и тег @throws для каждого исключения.

	  По соглашению, текст, который следует за тегом @param или @return , представляет собой фразу, описывающую значение данного параметра или 
	   возвращаемое значение. Текст, следующий за тегом @throws , должен состоять из слова “if” и фразы, описывающей условия, при которых
	   инициируется данное исключение. Иногда вместо словесных описаний используются арифметические выражения. 
	  По соглашению содержимое тегов @param и @return не заканчивается точкой.

		/**
		 * Возвращает элемент по заданной позиции в данном списке.
		 * <р>
		 * Этот метод нe даёт гарантии выполнения за константное время. В
		 * некоторых реализациях он выполняется за время, пропорциональное
		 * позиции элемента.
		 *
		 * @param index индекс элемента, который нужно возвратить; индекс
		 * 		должен быть меньше размера списка и неотрицательным.
		 * @return элемент, занимающий в списке указанную позицию
		 * @throws IndexOutOfBoundsException, если индекс лежит вне диапазона
		 * 			({@code index < 0 || index >= this.size()})
		 */
		E get(int index);

	+ пример кода: <pre>{@code и заканчиваться символами }</рге>
	
	+ чтобы сгенерить «Неравенство треугольника - это |х + у| < |х| + |у|.», используй литерал

		/**
		 * Неравенство треугольника - это {@literal |x + y| < |x| + |у|}.
		 */

	+ Первым предложением любого doc-комментария является общее описание (summary description) того элемента, к которому этот комментарий относится.
	   никакие два члена или конструктора в одном классе или интерфейсе не должны иметь одинакового общего описания.

	+ Особое внимание удели средствам обобщённого программирования, перечислимым типам и аннотациям.

	!+ Для сложных API, состоящих из множества взаимосвязанных классов, комментарии к документации часто требуется дополнять внешним документом, 
	    описывающим общую архитектуру этого API. Если такой документ существует, то комментарии к документации в соответствующем классе или пакете
	    должны на него ссылаться.




	++++++++++++++++++++++++++++++++++++++
	+++ ОБЩИЕ ВОПРОСЫ ПРОГРАММИРОВАНИЯ +++
	++++++++++++++++++++++++++++++++++++++


____________________________________________________________________
Статья 45. Сводите к минимуму область видимости локальных переменных

	Самый сильный приём сужения области видимости локальной переменной заключается в объявлении ее в том месте, где она впервые используется.
	for-each > for-i > while

_______________________________________________________________
Статья 46. Предпочитайте циклы for-each традиционным циклам for


_______________________________________________
Статья 47. Изучите библиотеки и пользуйтесь ими


_____________________________________________________________________________________
Статья 48. Если требуются точные ответы, избегайте использования типов float и double

	Правильный путь решения задачи заключается в том, чтобы применять для денежных расчётов типы BigDecimal , int или long .


_______________________________________________________________________
Статья 49. Предпочитайте примитивные типы упакованным примитивным типам


__________________________________________________________________
Статья 50. Не используйте строку там, где более уместен другой тип

	Строки — плохая замена перечислениям. ---> лучше enum
	Строки — плохая замена составным типам (aggregate types). ---> лучше класс
	Строки — плохая замена мандатам (capabilities, неподделываемый ключ). ---> лучше класс


______________________________________________________________________
Статья 51. При конкатенации строк опасайтесь потери производительности

	используйте StringBuilder!

	STREAM
	.collect(Collectors.joining()); // использует sb внутри себя


_______________________________________________________
Статья 52. Используйте интерфейсы для ссылок на объекты


_____________________________________________
Статья 53. Предпочитайте интерфейсы рефлексии

	• Вы лишаетесь всех преимуществ проверки типов на этапе компиляции,
	в том числе проверки исключений. Если программа попытается вызвать
	несуществующий или недоступный метод с помощью рефлексии, то в случае
	отсутствия специальных мер предосторожности произойдёт сбой программы во
	время выполнения.
	• Программный код, необходимый для рефлексии классов, неуклюж и
	многословен. Его тяжело писать и трудно читать.
	• Страдает производительность. Рефлексивный вызов метода выполняется намного
	медленнее обычного вызова. Насколько медленнее — сложно точно сказать,
	потому что на его работу влияет много факторов.

	 Кроме того, не следует применять System.exit в серверных приложениях, исполняющихся внутри контейнеров сервлетов или серверов приложений Java EE,
 	поскольку при вызове System.exit завершит работу весь контейнер вместе со всеми исполняющимися в нём приложениями. Ключевое правило здесь такое: 
	если процесс инициализировали не вы, не вам его и завершать.


____________________________________________________________________________
Статья 54. Соблюдайте осторожность при использовании машинозависимых методов


__________________________________________________
Статья 55. Соблюдайте осторожность при оптимизации

	• Во имя эффективности (но при этом не обязательно достигая её) программисты
	допускают больше грехов, чем по каким-либо иным причинам, включая 
	непроходимую тупость.
	— Уильям Вульф (William А. Wulf) [Wulf72]

	• Нам нужно забыть о мелких усовершенствованиях, скажем, в 97% случаев:
	преждевременная оптимизация — корень всех зол.
	— Дональд Кнут (Donald Е. Knuth) [Knuth74]

	• При оптимизации мы следуем двум правилам:
	Правило 1. Не делайте оптимизаций.
	Правило 2 (только для экспертов). Не делайте оптимизаций до поры до времени
	— то есть пока у вас нет абсолютно чёткого неоптимизированного решения.
	— М. А. Джексон (М. А. Jackson) [Jackson75]


	Искажать API ради улучшения производительности — очень плохая идея.


__________________________________________________________________
Статья 56. При выборе имён придерживайтесь общепринятых соглашений





	++++++++++++++++++
	+++ ИСКЛЮЧЕНИЯ +++
	++++++++++++++++++


_________________________________________________________________
Статья 57. Используйте исключения лишь в исключительных ситуациях


_________________________________________________________________________________________________________________________________
Статья 58. Применяйте проверяемые исключения для восстановления, для программных ошибок используйте исключения времени выполнения

	ошибки зарезервированы в JVM для сигнализации о дефиците
	ресурсов, нарушении инвариантов и других условияях, делающие невозможным
	дальнейшее выполнение программы

	Поскольку эти соглашения
	признаны практически повсеместно, лучше вообще не создавать новых подклассов
	класса Error . Все реализуемые вами непроверяемые исключения должны прямо или
	косвенно наследовать класс RuntimeException .

	Для ситуаций, когда можно обработать ошибку и продолжить
	исполнение, используйте проверяемые исключения


___________________________________________________________________
Статья 59. Избегайте ненужного использования проверяемых исключений

	Роль лакмусовой бумажки в данном
	случае играет вопрос: как программист будет обрабатывать исключение? Является ли
	это решение лучшим


_______________________________________________
Статья 60. Предпочитайте стандартные исключения

	
______________________________________________________________
Статья 61. Выбрасывайте исключения, соответствующие абстракции


____________________________________________________________________________
Статья 62. Для каждого метода документируйте все выбрасываемые им исключения

	Для описания каждого непроверяемого исключения, которое может быть выброшено
	методом, используйте тег Javadoc @throws , но не включайте непроверяемые
	исключения в объявление метода с помощью ключевого слова throws


_____________________________________________________________
Статья 63. В описание исключения добавляйте информацию о сбое


_______________________________________________________________
Статья 64. Добивайтесь атомарности методов по отношению к сбоям

	Вообще говоря, вызов
	метода, завершившийся сбоем, должен оставлять обрабатываемый объект в том же
	состоянии, в каком тот был перед вызовом. Метод, обладающий таким свойством,
	называют атомарным по отношению к сбоям (failure atomic).


____________________________________
Статья 65. Не игнорируйте исключения

	Блок catch обязан содержать, по крайней мере, комментарий, объясняющий, почему данное
	исключение следует игнорировать.




	+++++++++++++++++++++++
	+++ МНОГОПОТОЧНОСТЬ +++
	+++++++++++++++++++++++


____________________________________________________________________________________
Статья 66. Синхронизируйте доступ потоков к совместно используемым изменяемым данным

	Использование ключевого слова synchronized даёт гарантию, что в данный момент
	времени некий оператор или блок будет выполняться только в одном потоке.

	Когда несколько потоков совместно работают с изменяемыми
	данными, каждый поток, который читает или записывает эти данные, должен
	пользоваться синхронизацией.

	// Правильно синхронизированное совместное завершение потока
	public class StopThread {
		private static boolean stopRequested;

		private static synchronized void requestStop() {
			stopRequested = true;
		}

		private static synchronized boolean stopRequested() {
			return stopRequested;
		}

		public static void main(String[] args) throws InterruptedException {
			Thread backgroundThread = new Thread(() -> {
				int i = 0;
				while (!stopRequested())
					i++;
			});

			backgroundThread.start();
			TimeUnit.SECONDS.sleep(1);
			requestStop();
		}
	}

	Заметим, что и метод записи ( requestStop ), и метод чтения ( stopRequested )
	синхронизированы. Синхронизировать только метод записи недостаточно. На самом
	деле синхронизация не имеет эффекта, если не синхронизированы операции как
	записи, так и чтения.

	ОПТИМИЗАЦИЯ:

	// Совместное завершение потоков с помощью поля volatile
	public class StopThread {
		private static volatile boolean stopRequested;

		public static void main(String[] args) throws InterruptedException {
			Thread backgroundThread = new Thread(() -> {
				int i = 0;
				while (!stopRequested)
				i++;
			});

			backgroundThread.start();
			TimeUnit.SECONDS.sleep(1);
			stopRequested = true;
		}
	}

	если бы это был инт ---> или ключевое синхронайзед ножно использовать или, лучше тип атомик

	Лучший способ избежать проблем, описанных в этой статье — не делать общими
	изменяемые данные. Либо делайте общими неизменяемые данные (статья 15), либо
	вообще не разделяйте никаких данных между потоками. Другими словами, не
	допускайте видимости изменяемых данных несколькими потоками.


_____________________________________________
Статья 67. Избегайте избыточной синхронизации

	В зависимости от ситуации избыточная синхронизация
	может приводить к снижению производительности приложения, взаимной блокировке
	потоков или даже к непредсказуемому поведению программы.

	Для исключения ошибок живучести и безопасности никогда не передавайте управление
	клиенту внутри синхронизированного метода или блока.

	Как правило, вам нужно выполнять как можно меньше действий внутри
	синхронизируемой области.

	Если вам требуется
	выполнение длительных действий, найдите способ переместить эти действия за
	пределы синхронизируемой области, не нарушая инструкций из статьи 66.

	Вам следует сделать неизменяемый класс потокобезопасным (статья 70), если
	предполагается его параллельное использование и вы можете достичь большей
	параллелизации, выполняя синхронизацию изнутри, чем путём блокирования всего
	объекта извне.
	Если вы сомневаетесь, то не синхронизируйте свой класс, а укажите в документации, что он не
	потокобезопасен (статья 70).

	! Если вы синхронизируете класс изнутри, вы можете пользоваться различными
	приёмами для достижения высокой параллелизации, такими, как разделение
	блокировки, распределение блокировки и контроль параллельности без блокировки.
	Эти приёмы выходят за рамки этой книги, но описываются другими [Goetz06, Lee00].

	Если метод изменяет статическое поле, он обязан иметь внутреннюю синхронизацию,
	даже если обычно применяется только с одним потоком.


___________________________________________________________________________________
Статья 68. Предпочитайте Executor Framework непосредственному использованию потоков

	ExecutorService executor = Executors.newSingleThreadExecutor();
	executor.execute(runnable);
	// завершить работу:
	executor.shutdown();

_____________________________________________________________________
Статья 69. Предпочитайте утилиты параллельности методам wait и notify

	Используй ConcurrentHashMap.
	Наиболее часто используемые синхронизаторы — это CountDownLatch и Semaphore.

	CountDownLatch — это одноразовые барьеры, которые позволяют
	одному или более потокам ждать, когда один или более поток что-то сделает.
	Единственный конструктор для CountDownLatch принимает int , который задаёт
	количество вызовов метода countDown , которые должны произойти, прежде чем всем
	ожидающим потокам будет разрешено продолжить.

	прим.:
	Для измерения интервалов времени всегда лучше использовать
	System.nanoTime , чем System.currentTimeMillis . Метод System.nanoTime и более
	точен, и обладает большей разрешающей способностью; кроме того, на него не влияют
	настройки системного времени.


____________________________________________________
Статья 70. Документируйте уровень потокобезопасности

	Уровни потокобезопасности:
	• Неизменяемый (immutable). Экземпляры такого класса выглядят для своих
	клиентов как константы. Никакой внешней синхронизации не требуется.
	Примерами являются String , Integer и BigInteger (статья 13).
	• Безусловно потокобезопасный (unconditionally thread-safe). Экземпляры такого
	класса могут изменяться, однако все методы имеют довольно надёжную
	внутреннюю синхронизацию, чтобы эти экземпляры могли параллельно
	использовать несколько потоков безо всякой внешней синхронизации. Примеры:
	Random и ConcurrentHashMap .
	• Условно потокобезопасный (conditionally thread-safe). То же, что и с поддержкой
	многопоточности, за исключением того, что некоторые методы требуют внешней
	синхронизации для безопасного использования в многопоточной среде. Примеры:
	Hashtable и Vector , чьи итераторы требуют внешней синхронизации.
	• Не потокобезопасный (not thread-safe). Экземпляры такого класса изменяемы, и
	чтобы их можно безопасно использовать в нескольких потоках одновременно,
	каждый вызов метода (а в некоторых случаях каждую последовательность
	вызовов) необходимо окружить внешней синхронизацией. Среди примеров
	можно назвать реализации коллекций общего назначения, такие как ArrayList
	и HashMap .
	• Несовместимый с многопоточностью (thread-hostile). Этот класс небезопасен
	при параллельной работе с несколькими потоками, даже если вызовы всех
	методов окружены внешней синхронизацией. Обычно такая несовместимость
	с модификацией статических данных без синхронизации. Никто не пишет
	несовместимые с многопоточностью классы намеренно; такие классы
	появляются из-за того, что их разработчик не задумывался о многопоточном
	использовании класса. К счастью, в библиотеках платформы Java лишь очень
	немногие классы и методы несовместимы с многопоточностью. Так, метод
	System.runFinalizersOnExit несовместим с многопоточностью и признан
	устаревшим.


__________________________________________________________________________
Статья 71. Соблюдайте осторожность при использовании ленивой инициализации

	Если для повышения производительности вам требуется ленивая инициализация
	поля экземпляра, используйте идиому двойной проверки


________________________________________________
Статья 72. Не полагайтесь на планировщик потоков

	Любая программа, чья корректность или производительность зависит от планировщика
	потоков, скорее всего, переносимой не будет.


___________________________________________
Статья 73. Не используйте класс ThreadGroup

 	Группы потоков устарели.
	Если вы проектируете класс, который работает с логическими
	группами потоков, вам нужно, вероятнее всего, использовать пулы потоков из Executor Framework




	++++++++++++++++++++
	+++ СЕРИАЛИЗАЦИЯ +++
	++++++++++++++++++++


_________________________________________________________________________
Статья 74. Соблюдайте осторожность при реализации интерфейса Serializable

	Значительная доля затрат на реализацию интерфейса Serializable связана с тем, что
	это решение уменьшает возможность изменения реализации класса в последующих версиях.

	Второе неудобство от реализации интерфейса Serializable заключается в том,
	что повышается вероятность появления ошибок и дыр в защите. Объекты обычно
	создаются с помощью конструкторов, сериализация же представляет собой внеязыковой
	(extralinguistic) механизм создания объектов.
	+ нужно гарантировать создание всех инвариантов (нет конструктора)

	Третье неудобство реализации интерфейса Serializable связано с тем, что выпуск
	новой версии класса сопряжён с большой работой по тестированию.

	Классы, предназначенные для наследования (статья 17), обычно не должны
	реализовывать Serializable , а интерфейсы обычно не должны его расширять.

	для несериализуемого класса, который
	предназначен для наследования, вы должны рассмотреть возможность добавления
	к нему конструктора без параметров. Это ганантия создания инвариантов, вроде

	Внутренние классы (статья 22) не должны реализовывать интерфейс Serializable .


_________________________________________________________________________________________
Статья 75. Рассмотрите возможность использования специализированной сериализованной формы


_________________________________________________________
Статья 76. Включайте защитные проверки в метод readObject

	При десериализации объекта крайне
	важно создать защитные копии для всех полей, содержащих ссылки на объекты,
	которые не должны попасть в распоряжение клиентов.

	Не используйте методы writeUnshared
	и readUnshared . Они обычно быстрее, чем защитное копирование, но они не
	обеспечивают должных гарантий.


______________________________________________________________________________________
Статья 77. Для контроля экземпляров предпочитайте перечислимые типы методу readResolve

	// Метод readResolve для контроля экземпляров - можно сделать лучше!
	private Object readResolve() {
		// Возвращает единственного истинного Элвиса и даёт возможность
		// сборщику мусора избавиться от Элвиса-самозванца
		return INSTANCE;
	}

	На самом деле, если вы полагаетесь на метод readResolve для контроля экземпляров,
	все поля со ссылками на объекты должны быть объявлены как transient .

	лучшим решением будет сделать Elvis единственным элементом перечислимого типа


_______________________________________________________________________________________________________________
Статья 78. Рассмотрите возможность использования прокси-классов сериализации вместо сериализованных экземпляров


1	внутри сериализуемого класса создайте закрытый статический вложенный класс, который в
	точности представляет собой логическое состояние экземпляра внешного класса.

	Этот вложенный класс, известный как прокси-класс сериализации (serialization proxy),
	должен иметь единственный конструктор, типом параметра которого является
	внешний класс.

2	И внешний класс, и его прокси-класс сериализации должны быть объявлены как implements Serializable .

3	Затем добавьте метод writeReplace к внешнему классу. Пусть он вернет новый прокси:
	private Object writeReplace() {
		return new SerializationProxy(this);
	}

4	Добавьте метод риадОбджект (защита от аттак подменой)
	// Метод readObject для шаблона прокси-класса сериализации
	private void readObject(ObjectInputStream stream)
		throws InvalidObjectException {
		throw new InvalidObjectException("Proxy required");
	}

5	Наконец, добавьте в класс SerializationProxy метод readResolve , который возвратит
	логически эквивалентный экземпляр внешнего класса. Присутствие этого метода
	приводит к тому, что система сериализации преобразует экземпляр прокси-класса
	сериализации обратно в экземпляр внешнего класса при десериализации.
	Этот метод readResolve создаёт экземпляр внешнего класса, используя только
	открытый API, и в этом и заключается вся красота шаблона.
	private Object readResolve() {
		return new Period(start, end); // Uses public constructor
	}







	       /
	      /\     /
	  ___/  \_  /|
	 / 	  \/ /
	< O <<       =>
	 \___  ___/\ \
	     \/     \|
	      \	     \


	       
	       /     /
	      /\    /|
	  ___/  \__/ /
	 /O          =>
	 \_//  ___/\ \
	     \/     \|
	      \	     \



			     /    
			__ _/\__  /
			\_O_<<__==|
			    \/    \
			     \    


Заметки:
 ~ java.time - в java 8 появился крутой пакет работы со временем (+ класс Period)
 ~ foreach игнорирует null и проходит чисто по элементам
 ~ callback - объект передаёт другому объекту ссылку на самого себя для последующего вызова (callback — «обратный вызов»)















