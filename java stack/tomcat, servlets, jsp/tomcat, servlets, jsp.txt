ApacheTomcat сервер – это основанный на платформе Java контейнер для веб-приложений. 
Сервер создан для запуска веб-приложений, основанных на сервлетах и JavaServerPages (JSP)

Apache Tomcat в состав входит:
	Catalina for tomcat -  контейнер сервлетов
	Coyote - компонент стека HTTP
	Jasper - механизм JSP

Apache Tomcat
	/bin – содержит startup, shutdown и другие исполняемые файлы;
	/conf – содержит конфигурационные файлы, в частности конфигурационный файл контейнера сервлетов server.xml;
	/server – помещаются классы;
	/logs – помещаются log-файлы;
	/webapps – в этот каталог помещаются папки, содержащие сервлеты и другие компоненты приложения. (сюда будем кидать war)
		/testApp
			/WEB-INF
				/classes – содержит класс сервлета FirstServlet.class;
				/lib – содержит библиотеки классов (если они есть), упакованные в JAR-файлы (архивы java);
				/src – содержит исходный файл сервлета FirstServlet.java;
				web.xml – конфигурационный файл приложения.

Команды управления:
catalina start 		– запускает Tomcat как новый процесс.
catalina stop 		- останавливает Tomcat.
catalina debug 		– запуск Tomcat в режиме отладки.
catalina version 	– выводверсииTomcat.
catalina configtest 	– проверяет, что текущая конфигурация Tomcat правильна. Скрипт пытается запустить Tomcat и загрузить все
			  конфигурационные файлы, а затем аккуратно выйти, если сервер настроен, верно. Если какие-либо файлы
			  конфигурации настроены не верно, то скрипт выдаст отчет об ошибки.
catalina jpdastart 	– Запускает Tomcat в Java Platform Debugging Architecture (JPDA) отладочном режиме.
Можно расширить опцией 	– security любую команду скриптов catalina. С Помощью этой опции Tomcat запускается в режиме включенного
			  менеджера безопасности (securitymanagerenabled). Режим включенного менеджера безопасности – это механизм
			  защиты ресурсов, управляемых JVM от несанкционированного доступа. 

Для того, что бы быть уверенным, что JVM читает все файлы используя кодировку UTF-8, мы можем добавить стандартный параметр
file.encoding к переменной JAVA_OPTS: set JAVA_OPTS="-Dfile.encoding=utf-8"

Добавление больше памяти Tomcat процессу:
set CATALINA_OPTS=" –Xms256m -Xmx1g -XX:MaxPermSize=256m"

server.xml  - основной конфигурационный файл 
Context.xml - конфигурация содержит настройки по умолчанию, которые могут быть использованы всеми контекстами Tomcat.

==========================================================================================
Контейнер сервлетов  — программа, представляющая собой сервер, который занимается системной поддержкой сервлетов и обеспечивает 
их жизненный цикл в соответствии с правилами, определёнными в спецификациях.

Известные реализации:Apache Tomcat, Jetty, JBoss, GlassFish, IBM WebSphere, Oracle Weblogic.

==========================================================================================
SERVLET
Сервлеты – это компоненты приложений Java 2 Platform Enterprise Edition(J2EE), выполняющиеся на стороне сервера, способные обрабатывать
клиентские запросы и динамически генерировать ответы на них.

Жизненный цикл сервлетов:

1 - В случае отсутствия сервлета в контейнере.
    Класс сервлета загружается контейнером.
    Контейнер создает экземпляр класса сервлета.
    Контейнер вызывает метод init(). Этот метод инициализирует сервлет и вызывается в первую очередь, до того, как сервлет сможет
    обслуживать запросы.
2 - Обслуживание клиентского запроса. Каждый запрос обрабатывается в своем отдельном потоке. 
    Контейнер вызывает метод service() для каждого запроса. Этот метод определяет тип пришедшего запроса и распределяет его в
    соответствующий этому типу метод для обработки запроса. Если поступил запрос, метод для которого не реализован, вызывается метод
    родительского класса и обычно завершается возвращением ошибки инициатору запроса.
	2.1 Параметры запроса упаковываются в объект ServletRequest
	2.2 Выходные данные в процессе формирования ответа клиенту упаковываются в объект ServletResponse
	2.3 Если нужно избежать множественных запросов, сервлет должен реализовать интерфейс SingleThreadModel (сервлет обслуживает
	    запросы поочерёдно)
3 - В случае если контейнеру необходимо удалить сервлет, он вызывает метод destroy(), который снимает сервлет из эксплуатации. 
    Подобно методу init(), этот метод тоже вызывается единожды за весь цикл сервлета.

=== Методы ServletRequest:
		getCharacterEncoding() - символьная кодировка запроса
		getContentType() - информация о MIME-типе пришедшего запроса: название
			MIME type:
				application
				audio
				example
				image
				message
				model
				multipart
				text
				video
		getProtocol() - информация о MIME-типе пришедшего запроса: версия
		getServerName() - имя сервера принявшего запрос
		getServerPort() - порт на котором принят запрос
		getRemoteAddr() - IP-адрес машины клиента
		getRemoteHost() - имя клиента
		getRequestURI() - URI
		
			получить доступ к пришедшим данным:
		getInputStream() - возвращает ссылку на объект класса ServletInputStream
		getReader() - возвращает ссылку на BufferedReader
			
			разбор параметров и выдача их значений:
		getParameter(String name) - возвращает значение параметра по его имени
		getParameterValues() - возвращает массив строк, а именно все значения параметра по его имени, 
				       причем параметр может иметь несколько значений
		getParameterNames() - возвращает Enumeration, позволяющий узнать имена всех присланных параметров
				      что добавляет HttpServletRequest?
		getCookies() - массив cookies, полученный с запросом и содержащий информацию о клиенте
		getMethod() - узнать о методе доступа к ресурсам, на основе которого построен запрос
		getQueryString() - строка запроса HTTP
		getRemoteUser() - имя пользователя выполневшего запрос
		setAttribute(String name, Object ob) - устанавливаются значения атрибутов компонентов, являющиеся внутренними
						       параметрами для передачи информации между компонентами приложения, например от
						       сервлета к странице JSP или другому сервлету.
						       
			Извлечь переданную компонентом информацию позволяют методы:
		getAttributeNames()
		getAttribute(String name)

=== Методы ServletResponse:
		setContentType() - задать MIME-тип
		getOutputStream() - возвращает ссылку на поток ServletOutputStream
		getWriter() - вернет ссылку на поток типа PrintWriter
			что добавляет HttpServletResponse?
		addCookie() - переслать cookie на клиентскую станцию
		endError(int sc, String msg) - сообщение и код ошибки
		setDateHeader() - добавить параметры в заголовок ответа

=== Методы ServletConfig:
		getServletName()
		getInitParameterNames() - enum
		getServletContext()		возвращает ServletContext
		getServerInfo()
		getRealPath()
		getContentType()

=== Методы Servlet
		init()
		service()
		destroy()

		getLastModified() - long

		doGet()
		doPost()
		doPut()
		doDelete()
		doOptions()
		doTrace()
		doHead()


=== Интерфейс RequestDispatcher используется для передачи запроса другому ресурсу 
    (это может быть HTML, JSP или другой сервлет в том же приложении)
например:
request.getRequestDispatcher("/pages/calculator.jsp").forward(request, response);


Работая с сервлетами нужно помнить о том, что каждый пользователь работает с сервлетом, как отдельный поток
thread-safe: использовать локальные переменные и атрибуты сессии
not-thr-safe: глобальные переменные

COOKIE - небольшой фрагмент данных, отправленный веб-сервером и хранимый на компьютере пользователя.
Билы придуманы как решение проблемы прерываемости соединения с пользователем. Куки передаются при каждом запросе клиента(если они есть).

Проблемы:
1.Неточная идентификация - куки идентифицируют не человека, а сочетание учётной записи, компьютера, и браузера. 
  Таким образом, любой человек, который использует несколько учётных записей, компьютеров или браузеров, имеет несколько наборов куки.
2.Кража куки - Куки легко перехватить и подменить (например, для получения доступа к учетной записи), если пользователь использует
  нешифрованное соединение с сервером.
3.Подмена куки - пользователь может отправить другие куки, вместо тех что сохранённы.
4.Межсайтовые куки - Каждый сайт должен иметь свои собственные куки, и сайт example.com не должен изменять или устанавливать куки
  другого сайта example.org Хотя это возможно.
5.Нестабильность между клиентом и сервером - Куки могут вызвать противоречия между клиентом и сервером. 
  Если пользователь получает куки, а затем нажимает кнопку «Назад» в браузере, то состояние браузера уже другое по сравнению с моментом
  получения куки. Для примера возьмем электронный магазин с корзиной покупок, основанной на применении куки: пользователь добавляет
  покупку в корзину, затем нажимает кнопку «Назад», но покупка остаётся в корзине, хотя пользователь, возможно, хотел отменить покупку.
  Это может привести к путанице и ошибкам. Веб-разработчики должны помнить об этом и принимать меры для решения таких ситуаций.


Порядок работы с cookie:
1. Получить объект cookie из request:
      request.isRequestedSessionIdFromCookie() - есть ли куки?
      request.getCookies() - возвращает массив куки
2. Работаем с полученными значениями:
      cookie.getValue() & cookie.setValue()
3. Отправляем cookie клиенту:
      response.addCookie()

прим. полезные методы cookie
 .setComment(String)
 .setMaxAge(int)      // время жизни cookie в секундах


==========================================================================================
JSP (JavaServer Pages) — технология, созданная для облегчения создания динамических компонентов веб-страниц.
JSP не является подобием HTML страницы! При первом обращении JSP преобразуется в сервлет и работает уже как сервлет.

Некоторые плюсы и минусы:
+ простой способ реализации динамических компонентов веб-страниц;
+ не нужен отдельный веб-разработчик для создание веб-интерфеса приложения;
- сложно реализовать по принципу "one server for all app" (один сервер для браузера, мобильного приложения, другого приложения);
- в некоторой мере происходит совмещение серверной логики и логики интерфейса, 
  в результате чего может получится достаточно запутанный, сложный в поддержке код;
- динамическая работы страницы достигается за счет обновления всей страницы, а не какого-то отдельного её компонета.

Процессы, выполняемые с файлом JSP при первом вызове или при его изменении:
	1. Браузер делает запрос к странице JSP.
	2. JSP-engine анализирует содержание файла JSP.
	3. JSP-engine создает временный сервлет с кодом, основанным на исходном тексте файла JSP, при этом контейнер транслирует
	   операторы Java в метод _jspService(). Если нет ошибок компиляции, то этот метод вызывается для непосредственной обработки
	   запроса. Полученный сервлет ответствен за исполнение статических элементов JSP, определенных во время разработки в 
	   дополнение к созданию динамическихэлементов.
	4. Полученный текст компилируется в файл *.class.
	5. Вызываются методы init() и service() (doGet() или doPost()), и сервлет логически исполняется.
	6. Сервлет установлен. Комбинация статического HTML и графики вместе с динамическими элементами, определенными в оригинале JSP,
	   пересылаются браузеру через выходной поток объекта ответа ServletResponse.

Последующие вызовы файла JSP просто вызовут сервисный метод сервлета.
Сервлет используется до тех пор, пока сервер не будет остановлен и сервлет не будет выгружен вручную либо пока не будет изменен файл
JSP.
 

Скриптовые элементы:
	<%@ директива %>		- Директивы используются для установки параметров серверной страницы JSP
	<%! объявление %>		- Блок объявлений содержит переменные Java и методы, которые вызываются в expression-блоке
	<% скриптлет %>			- вживление Java-кода, все они будут объединены и помещены в метод _jspServlet()
	<%= вычисляемое выражение %>	- результат вычисления преобразуется в строку String и посылается в поток out
	<%-- JSP-комментарий --%>

Стандартные элементы action:
эти действия JSP используют конструкции с синтаксисом XML для управления работой движка сервлета

JSP-страница всегда имеет доступ ко многим функциональным возможностям
сервлета, создаваемым Web-контейнером по умолчанию. Неявный объект:
								request
								responce
								pageContext
								session
								out
								exception
								application
								page (this)

	jsp:declaration — Объявление, аналогичен тегу <%! … %>;
	jsp:scriptlet — Скриптлет, аналогичен тегу <% … %>;
	jsp:expression — Выражение, аналогичен тегу <%= … %>;

	jsp:useBean – позволяет использовать экземпляр компонента JavaBean.
			ПРИМЕР:
			<jsp:useBean id="имя" class="пакет.class" />
			ИЛИ:
			<jsp:useBean ...> 
				d — даёт имя переменной, которая ссылается на bean.
				class — задаёт полное имя пакета bean;
				scope — задаёт область, в которой bean должен быть доступен.
				type — указывает тип переменной, которая ссылается на объект.
			</jsp:useBean>
beanName — даёт имя bean, которое будет использовано методом instantiate. Можно задать type и beanName, и опустить атрибут class.
	jsp:setProperty – позволяет устанавливать значения полей указанного в атрибуте name объекта
	jsp:getProperty – получает значения полей указанного объекта, преобразует его в строку и отправляет в неявный объект out
	jsp:include – позволяет включать файлы в генерируемую страницу при запросе страницы
	jsp:forward – позволяет передать запрос другой странице
	jsp:plugin – замещается тэгом <OBJECT> или <EMBED>, в зависимости от типа броузера, в котором будет выполняться подключаемый
		     апплет или Java Bean.
	jsp:params – группирует параметры внутри тега jsp:plugin
	jsp:param – добавляет параметры в объект запроса, например в элементах forward, include, plugin
	jsp:fallback – указывает содержимое, которое будет использоваться клиентом, если подключаемый модуль не запуститься.
		       Используется внутри элемента plugin
	jsp:text – содержит текстовую информацию

ПРИМЕРЫ:
jsp принимает форму другой jsp
    <% request.setCharacterEncoding("UTF-8");%>
    <%= request.getParameter("likeWeather") %>

==========================================================================================
JSTL - JavaServer Pages Standard Tag Library
Это расширение спецификации JSP, добавляющее библиотеку JSP тегов.
Является альтернативой такому виду встроенной в JSP логики, как скриплеты, то есть прямые вставки Java кода.

Как подключить?
1. Поместить библиотеки в WEB-INF/lib/ 	taglibs-standard-impl-1.2.5.jar
					taglibs-standard-jstlel-1.2.5.jar
					taglibs-standard-spec-1.2.5.jar	
2. Добавить путь к данным библиотекам в структуре проекта (add modules).
3. Объявить в jsp:
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>

пример:
Объявляем переменную value и проверяем её на null
<c:set var="value" scope="session" value="${someValue}" />
<c:if test="${value == null}">
        <p>Value is null</p>
</c:if>







