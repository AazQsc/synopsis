
 
 ++++++++++++++++++++++
 +++ ОБЩИЕ СВЕДЕНИЯ +++
 ++++++++++++++++++++++

 Процесс - единица исполнения операционной системы (1 процесс может содержать в себе несколько потоков).
 Поток - единица исполнения программы.
 
 В java процесс завершается тогда, когда завершается его последний обычный поток.
 Кроме обычных потоков существуют потоки-демоны. Потоки-демоны - это потоки обслуживающие обычные потоки. 
 Как правило, это различные фоновые и служебные задачи. Если в процессе остались только потоки-демоны, он завершится.
 В java, чтобы сделать поток потоком-демоном, нужно вызвать его метод setDaemon(true) . 

 Потоки выполняются асинхронно.
 Асинхронность означает то, что нельзя утверждать, что какая-либо инструкция одного потока, выполнится раньше или позже инструкции другого.

 В языке java поток представляется в виде объекта-потомка класса Thread.

 Запустить поток в java можно тремя способами:
  1. Создать потомка класса Thread и переопределить его метод run() .
  2. Имплиментировать целевому объекту интерфейс Runnable, таким образом добавив в этот объект метод run() .
     Создать объект класса Thread, передав ему в конструкторе этот объект.
  3. Еще можно через новый интерфейс java.util.concurrent.Callable
     Callable представляет асинхронное вычисление, которое в конечном итоге возвращает объект.
     Future хранит результат асинхронного вычисления. Вы можете запустить вычисление, предоставив кому-либо объект Future, и забыть о нем. 
     Владелец объекта Future может получить результат, когда он будет готов.

 Класс ThreadGroup
 Все потоки находятся в группах, представляемых экземплярами класса ThreadGroup. Группа указывается при создании потока. 
 Если группа не была указана, то поток помещается в ту же группу, где находится поток, породивший его.
 Методы activeCount() и enumerate() возвращают количество и полный список, соответственно, всех потоков в группе.


 Методы Thread:
  setName(String)  		- задать имя потоку.
  setPriority(int от 1 до 10)	- задать приоритет потока 1 - min, 10 - max. Возможные значения priority — MIN_PRIORITY, NORM_PRIORITY и MAX_PRIORITY.
  setDaemon(boolian)		- сделать поток потоком-демоном.
  interrupt()			- (флаг)вывести поток у которого вызвали этот метод из состояния паузы (sleep(), wait() и join()).
  isAlive()  			- возвращает true если поток выполняется и false если поток еще не был запущен или был завершен.
  getId() 			- возвращает идентификатор потока. Идентификатор – уникальное число, присвоенное потоку.
  static yield()		- временно приостанавливает свою работу, пока другие потоки не отработают.
  static currentThread()	- позволяет в любом месте кода получить ссылку на объект класса Thread, представляющий текущий поток исполнения.
  static sleep(long)		- приостанавливает выполнение текущего потока на указанное количество миллисекунд. Требует обработки InterruptedException.

 Методы класса Object:
  wait()			- Любой поток может вызвать метод wait() любого объекта и таким образом попасть в его wait-set. 
				  При этом выполнение такого потока приостанавливается.
  notify()			- запустить один случайный завэйченый поток.
  notifyAll()		- запустить все завейченные потоки.
  join()			-  позволяет одному потоку ждать завершения выполнения другого. Например, чтобы главный поток подождал завершения побочного потока myThready, необходимо выполнить инструкцию myThready.join() в главном потоке

 Методы обджекта работают с wait-set, набором потоков исполнения.
 Применение этих методов связано с одним важным ограничением. Любой из них может быть вызван потоком у объекта только после установления блокировки на этот объект. 
 То есть либо внутри synchronized-блока (аргумент - ссылка на этот объект), либо обращения к методам должны быть в синхронизированных методах класса самого объекта.
 Лучше использовать собственную логику управления потоками, чем методы обджекта.
 Паттерн shared wait-set:
			1. объект shared
			2. кидаем ссылку на этот объект в потоки, в которым мы работаем с wait-set
			3. wait-notify вызываем синхронизировавшись на этом объекте.

 Запустили, отлично! Как теперь его остановить?
 Раньше в джава существовали методы позволяющие завершить поток принудительно. (стоп и суспэнд)
 Теперь Вместо принудительного завершения потока применяется схема, в которой каждый поток сам ответственен за своё завершение.
 
 run.return;		//Завершение потока

 +++++++++++++++++++++
 +++ СИНХРОНИЗАЦИЯ +++
 +++++++++++++++++++++

 В основном хранилище для каждого объекта поддерживается блокировка ( lock ), над которой можно произвести два действия – установить ( lock ) и снять ( unlock ). 
 Только один поток в один момент времени может установить блокировку на некоторый объект. Если до того, как этот поток выполнит операцию unlock, 
 другой поток попытается установить блокировку, его выполнение будет приостановлено до тех пор, пока первый поток не отпустит ее.

 Каждый объект в java имеет ассоциированный с ним монитор. Этот монитор и есть сущьность которая поддерживает работу блокировок.
 В java для того, чтобы воспользоваться механизмом блокировок, существует ключевое слово synchronized. Оно может быть применено в двух вариантах:
  1. synchronized - блок ---> установить замок на каком-то конкретном объекте
  2. модификатор метода ---> поток устанавливает замок на объект, у которого был вызван данный метод. 

 deadlock – взаимная блокировка. 
  Если один поток заблокировал один ресурс и пытается заблокировать второй, а другой поток заблокировал второй и пытается заблокировать первый, 
  то такие потоки уже никогда не выйдут из состояния ожидания.

 ++++++++++++++++++++++++++++++
 +++ ВЗАИМОДЕЙСТВИЕ ПОТОКОВ +++
 ++++++++++++++++++++++++++++++

 volatile - это ключевое слово означает, что значение этой переменной может изменяться другими потоками. 
 Как следствие заприщаются локальные копии, внутренние операции оптимизации, кеширование данных, перестановки в инициализации переменных.
 Операции над этими переменными можно считать синхронизированными для атомарных операций.
 Чтение volatile-переменной и запись в volatile-переменную синхронизированы, а неатомарные операции ― нет.

 Локальные переменные потока, - это глобальные переменные в рамках текущего потока.
 private ThreadLocal myThreadLocal = new ThreadLocal();
 			 	
 ++++++++++++++++++++++++++++
 +++ java.util.concurrent +++
 ++++++++++++++++++++++++++++
 
  https://habrahabr.ru/company/luxoft/blog/157273/
   
  - Concurrent Collections	— набор коллекций, для работы в многопоточной среде.
  - Queues			— неблокирующие и блокирующие очереди с поддержкой многопоточности.
  - Synchronizers		— вспомогательные утилиты для синхронизации потоков.
  - Executors			— фрейморки для создания пулов потоков, планирования работы асинхронных задач с получением результатов. 
  - Locks			— альтернативные и более гибкие механизмы синхронизации потоков по сравнению с базовыми synchronized, wait, notify, notifyAll.
  - Atomics			— классы с поддержкой атомарных операций над примитивами и ссылками.


☣ Concurrent Collections — набор коллекций, для работы в многопоточной среде. Вместо базового враппера Collections.synchronizedList с блокированием доступа 
   ко всей коллекции используются блокировки по сегментам данных или же оптимизируется работа для параллельного чтения данных по wait-free алгоритмам.

  Содержит:
  - CopyOnWrite коллекции
  - Scalable Maps (масштабируемые)

  CopyOnWrite коллекции:
  Все операции по изменению коллекции (add, set, remove) приводят к созданию новой копии внутреннего массива. Из массива в массив копируются ссылки!
  Использовать когда мы имеем дело с небольшим количеством операций записи.
  1. CopyOnWriteArrayList<E> — Потокобезопасный аналог ArrayList, реализованный с CopyOnWrite алгоритмом.
  2. CopyOnWriteArraySet<E> — Имплементация интерфейса Set, использующая за основу CopyOnWriteArrayList.


   CopyOnWriteArrayList ---> CopyOnWriteArraySet


  Scalable Maps:
  1. ConcurrentMap<K, V> 		— Интерфейс, расширяющий Map несколькими дополнительными атомарными операциями.
  2. ConcurrentHashMap<K, V> 		— В отличие от Hashtable и блоков synhronized на HashMap, данные представлены в виде сегментов, разбитых по hash'ам ключей. 
   					   В результате, для доступ к данным лочится по сегментам, а не по одному объекту.
  3. ConcurrentNavigableMap<K,V> 	— Расширяет интерфейс NavigableMap и вынуждает использовать ConcurrentNavigableMap объекты в качестве возвращаемых значений.
  4. ConcurrentSkipListMap<K, V>	— Является аналогом TreeMap с поддержкой многопоточности. Данные также сортируются по ключу и гарантируется усредненная
    					   производительность log(N) для containsKey, get, put, remove и других похожих операций.
  5. ConcurrentSkipListSet<E>		— Имплементация Set интерфейса, выполненная на основе ConcurrentSkipListMap.


   (i)ConcurrentMap ---> ConcurrentHashMap
	 	    ---> (i)ConcurrentNavigableMap ---> ConcurrentSkipListMap
					           ---> ConcurrentSkipListSet


☣ Queues — неблокирующие и блокирующие очереди с поддержкой многопоточности. 

   Неблокирующие очереди заточены на скорость и работу без блокирования потоков. 
   Блокирующие очереди используются, когда нужно «притормозить» потоки «Producer» или «Consumer», если не выполнены какие-либо условия, 
    например, очередь пуста или перепонена, или же нет свободного «Consumer»'a.

 Non-Blocking Queues:
  1. ConcurrentLinkedQueue<E>   	— В имплементации используется wait-free алгоритм от Michael & Scott, адаптированный для работы с garbage collector'ом. 
					   Этот алгоритм довольно эффективен и, что самое важное, очень быстр, т.к. построен на CAS. 
					   Метод size() может работать долго, т.ч. лучше постоянно его не дергать.
  2. ConcurrentLinkedDeque<E>   	— Deque расшифровывается как Double ended queue и читается как «Deck». Это означает, что данные можно добавлять и
					   вытаскивать с обоих сторон. Соответственно, класс поддерживает оба режима работы: FIFO и LIFO. На практике, CLD стоит
					   использовать только, если обязательно нужно LIFO, т.к. за счет двунаправленности нод данный класс проигрывает по
					   производительности на 40% по сравнению с ConcurrentLinkedQueue.

 Blocking Queues:
  1. BlockingQueue<E>   		— Интерфейс... добавляет queue возможностью задать размер очереди или блокировки по условиям, добавляет новые методы, которые
					   реагируют по-разному на незаполнение или переполнение queue. 
					   Не поддерживают null значения, т.к. это значение используется в методе poll как индикатор таймаута. 
  2. ArrayBlockingQueue<E>   		— Класс блокирующей очереди, построенный на классическом кольцевом буфере. 
					   Доступна возможность управлять «честностью» блокировок. 
					   Если fair=false (по умолчанию), то очередность работы потоков не гарантируется. 
					   Более подробно о «честности» можно посмотреть в описании ReentrantLock'a.
  3. DelayQueue<E extends Delayed>   	— Довольно специфичный класс, который позволяет вытаскивать элементы из очереди только по прошествии некоторой задержки,
					   определенной в каждом элементе через метод getDelay интерфейса Delayed.
  4. LinkedBlockingQueue<E>    		— Блокирующая очередь на связанных нодах, реализованная на «two lock queue» алгоритме: один лок на добавление, 
					   другой на вытаскивание элемента. По сравнению с ArrayBlockingQueue, производительность выше, но и расход памяти у него выше.
  5. PriorityBlockingQueue<E>   	— Является многопоточной оберткой над PriorityQueue. При вставлении элемента в очередь, его порядок определяется в соответствии с 
				           логикой Comparator'а или имплементации Comparable интерфейса у элементов. Первым из очереди выходит самый наименьший элемент.
  6. SynchronousQueue<E>   		— Эта очередь работает по принципу один вошел, один вышел.
  7. BlockingDeque<E>   		— Интерфейс, описывающий дополнительные методы для двунаправленной блокирующей очереди.
  8. LinkedBlockingDeque<E>  		— Двунаправленная блокирующая очередь на связанных нодах, реализованная как простой двунаправленный список с одним локом.
  9. TransferQueue<E>   		— Интерфейс, при добавлении элемента в очередь существует возможность заблокировать вставляющий «Producer» поток до тех пор, пока 						   другой поток «Consumer» не вытащит элемент из очереди. Блокировка может быть как с таймаутом, так и вовсе может быть заменена
					   проверкой на наличие ожидающих «Consumer»ов. Тем самым появляется возможность реализации механизма передачи сообщений с
					   поддержкой как синхронных, так и асинхронных сообщений.
  10. LinkedTransferQueue<E>   		— Реализация TransferQueue на основе алгоритма Dual Queues with Slack. 
					   Активно использует CAS и парковку потоков, когда они находятся в режиме ожидания.

  (i)BlockingQueue ---> ArrayBlockingQueue
		   ---> DelayQueue
		   ---> LinkedBlockingQueue
		   ---> PriorityBlockingQueue
		   ---> SynchronousQueue
		   ---> (i)BlockingDequ	 ---> LinkedBlockingDeque
		   --->	(i)TransferQueue ---> LinkedTransferQueue
	

☣ Synchronizers — вспомогательные утилиты для синхронизации потоков. Представляют собой мощное оружие в «параллельных» вычислениях.

 Semaphore — Семафоры чаще всего используются для ограничения количества потоков при работе с аппаратными ресурсами или файловой системой. 
	     Доступ к общему ресурсу управляется с помощью счетчика. Если он больше нуля, то доступ разрешается, а значение счетчика уменьшается. 
	     Если счетчик равен нулю, то текущий поток блокируется, пока другой поток не освободит ресурс. 
	     Количество разрешений и «честность» освобождения потоков задается через конструктор.

 CountDownLatch — Позволяет одному или нескольким потокам ожидать до тех пор, пока не завершится определенное количество операций, выполняющих в других потоках.
		  Классический пример с драйвером довольно неплохо описывает логику класса: Потоки, вызывающие драйвер, будут висеть в методе await (с таймаутом или
 		  без), пока поток с драйвером не выполнит инициализацию с последующим вызовом метода countDown. Этот метод уменьшает счетчик count down на единицу. 
		  Как только счетчик становится равным нулю, все ожидающие потоки в await продолжат свою работу, а все последующие вызовы await будут проходить 
		  без ожиданий. Счетчик count down одноразовый и не может быть сброшен в первоначальное состояние.

 CyclicBarrier — Может использоваться для синхронизации заданного количества потоков в одной точке. Барьер достигается когда N-потоков вызовут метод await(...) и
		 заблокируются. После чего счетчик сбрасывается в исходное значение, а ожидающие потоки освобождаются. 
		 Дополнительно, если нужно, существует возможность запуска специального кода до разблокировки потоков и сброса счетчика. 
		 Для этого через конструктор передается объект с реализацией Runnable интерфейса.

 Exchanger<V> — Как видно из названия, основное предназначение данного класса — это обмен объектами между двумя потоками. 
		При этом, также поддерживаются null значения, что позволяет использовать данный класс для передачи только одного объекта или же просто как синхронизатор
	  	двух потоков. Первый поток, который вызывает метод exchange(...) заблокируется до тех пор, пока тот же метод не вызовет второй поток. 
		Как только это произойдет, потоки обменяются значениями и продолжат свою работу.

 Phaser — Улучшенная реализация барьера для синхронизации потоков, которая совмещает в себе функционал CyclicBarrier и CountDownLatch, вбирая в себя самое лучшее из них.
  	  Так, количество потоков жестко не задано и может динамически меняться. Класс может повторно переиспользоваться и сообщать о готовности потока без его блкрвки.


☣ Executors — содержит в себе отличные фрейморки для создания пулов потоков, планирования работы асинхронных задач с получением результатов. 
 
   Разделы:
	- Future and Callable 		-- работа с асинхронными задачами
	- Executor Services		-- сервис для запуска Runnable или Callable задач
	- ThreadPoolExecutor & Factory	-- мощные средства управления потоками 
	- Fork Join			-- фреймворк для решения рекурсивных задач, работающих по алгоритмам разделяй и влавствуй или Map Reduce. 
	- Completion Service		-- работа с выполненными задачами


	FUTURE AND CALLABLE:

 Future<V> — Интерфейс для получения результатов работы асинхронной операции. Ключевым методом здесь является метод get, который блокирует текущий поток 
	     (с таймаутом или без) до завершения работы асинхронной операции в другом потоке. Также, дополнительно существуют методы для отмены операции и проверки
	     текущего статуса. В качестве имплементации часто используется класс FutureTask.

 RunnableFuture<V> — Если Future — Интерфейс для Client API, то интерфейс RunnableFuture уже используется для запуска асинхронной части. 
		     Успешное завершение метода run() завершает асинхронную операцию и позволяет вытаскивать результаты через метод get.

 Callable<V> — Расширенный аналог интерфейса Runnable для асинхронных операций. Позволяет возвращать типизированное значение и кидать checked exception. 
	       Несмотря на то, что в этом интерфейсе отсутсвует метод run(), многие классы java.util.concurrent поддерживают его наряду с Runnable.

 FutureTask<V> — Имплементация интерфейса Future/RunnableFuture. Асинхронная операция принимается на вход одного из конструкторов в виде Runnable или Callable объектов.
		 Сам же класс FutureTask предназначен для запуска в worker потоке, например через new Thread(task).start(), или через ThreadPoolExecutor. 
		 Результаты работы асинхронной операции вытаскиваются через метод get(...).

 Delayed — Интерфейс, Используется для асинхронных задач, которые должны начаться в будущем, а также в DelayQueue. Позволяет задавать время до начала аснхрннй операции.

 ScheduledFuture<V> — Маркерный интерфейс, объединяющий Future и Delayed интерфейсы.

 RunnableScheduledFuture<V> — Интерфейс, объединяющий RunnableFuture и ScheduledFuture. Дополнительно можно указывать является ли задача одноразовой или же 
			      должна запускаться с заданной периодичностью.

	EXECUTOR SERVICES:

 Executor — Базовый интерфейс для классов, реализующих запуск Runnable задач. Тем самым обеспечивается развязка между добавлением задачи и способом её запуска.

 ExecutorService — Интерфейс, который описывает сервис для запуска Runnable или Callable задач. Методы submit на вход принимают задачу в виде Callable или Runnable, 
		   а в качестве возвращаемого значения идет Future, через который можно получить результат. Методы invokeAll работают со списками задач с блокировкой
		   потока до завершения всех задач в переданном списке или до истечения заданного таймаута. Методы invokeAny блокируют вызывающий поток до завершения
		   любой из переданных задач. В дополнении ко всему, интерфейс содержит методы для graceful shutdown. После вызова метода shutdown, данный сервис
	   	   больше не будет принимать задачи, кидая RejectedExecutionException при попытке закинуть задачу в сервис.

 ScheduledExecutorService — В дополнении к методам ExecutorService, данный интерфейс добавляет возможность запускать отложенные задачи.

 AbstractExecutorService — Абстрактный класс для построения ExecutorService'a. Имплементация содержит базовую имплементацию методов submit, invokeAll, invokeAny. 
			   От этого класса наследуются ThreadPoolExecutor, ScheduledThreadPoolExecutor и ForkJoinPool.
		

	THREADPOOLEXECUTOR & FACTORY:

 Executors — Класс-фабрика для создания ThreadPoolExecutor, ScheduledThreadPoolExecutor. 
	     Если нужно создать один из этих пулов, эта фабрика именно то, что нужно. 
	     Также, тут содержатся разные адаптеры Runnable-Callable, PrivilegedAction-Callable, PrivilegedExceptionAction-Callable и другие.

 ThreadPoolExecutor — Очень мощный и важный класс. Используется для запуска асинхронных задач в пуле потоков. Тем самым практически полностью отсутствует оверхэд на
		      поднятие и остановку потоков. А за счет фиксируемого максимума потоков в пуле обеспечивается прогнозируемая производительность приложения. 
		      Как было ранее сказано, создавать данный пул предпочтительно через один из методов фабрики Executors. 
		      Если же стандартных конфигураций будет недостаточно, то через конструкторы или сеттеры можно задать все основые параметры пула.

 ScheduledThreadPoolExecutor — В дополнении к методам ThreadPoolExecutor, позволяет запускать задачи после определенной задержки, а также с некоторой периодичностью,
			       что позволяет реализовать на базе этого класса Timer Service.

 ThreadFactory — По умолчанию, ThreadPoolExecutor использует стандартную фабрику потоков, получаемую через Executors.defaultThreadFactory(). 
		 Если нужно что-то больше, например задание приоритета или имени потока, то можно создать класс с реализацией этого интерфейса и передать его
		 в ThreadPoolExecutor.

 RejectedExecutionHandler — Позволяет определить обработчик для задач, которые по каким то причинам не могут быть выполнены через ThreadPoolExecutor. 
			    Такой случай может произойти, когда нет свободных потоков или сервис выключается или выключен (shutdown). 
			    Несколько стандартных имплементаций находятся в классе ThreadPoolExecutor: CallerRunsPolicy — запускает задачу в вызывающем потоке;
			    AbortPolicy — кидает эксцепшен; DiscardPolicy — игнорирует задачу; DiscardOldestPolicy — удаляет самую старую незапущенную задачу из очереди,
			    затем пытается добавить новую задачу еще раз.


	FORK JOIN:

 ForkJoinPool — Представляет собой точку входа для запуска корневых (main) ForkJoinTask задач. 
		Подзадачи запускаются через методы задачи, от которой нужно отстрелиться (fork). 
		По умолчанию создается пул потоков с количеством потоков равным количеству доступных для JVM процессоров (cores).

 ForkJoinTask — Базовый класс для всех Fork Join задач. Из ключевых методов можно отметить: fork() — добавляет задачу в очередь текущего потока 
		ForkJoinWorkerThread для асинхронного выполнения; invoke() — запускает задачу в текущем потоке; join() — ожидает завершения подзадачи с возвращением
		результата; invokeAll(...) — объединяет все три предыдущие предыдущие операции, выполняя две или более задач за один заход; adapt(...) — создает новую
		задачу ForkJoinTask из Runnable или Callable объектов.

 RecursiveTask — Абстрактный класс от ForkJoinTask, с объявлением метода compute, в котором должна производиться асинхронная операция в наследнике.

 RecursiveAction — Отличается от RecursiveTask тем, не возвращает результат.

 ForkJoinWorkerThread — Используется в качестве имплементации по умолчанию в ForkJoinPoll. При желании можно отнаследоваться и перегрузить методы инициализации и
 			завершения worker потока. 


	COMPLETION SERVICE:

 CompletionService — Интерфейс сервиса с развязкой запуска асинхронных задач и получением результатов. Так, для добавления задач используются методы submit,
		     а для вытаскивания результатов завершенных задач используются блокирующий метод take и неблокирующий poll. 

 ExecutorCompletionService — По сути является враппером над любым классом, реализующим интерфейс Executor, например ThreadPoolExecutor или ForkJoinPool. 
			     Используется преимущественно тогда, когда хочется абстрагироваться от способа запуска задач и контроля за их исполнением. 
			     Если есть завершенные задачи — вытаскиваем их, если нет — ждем в take пока что-нибудь не завершится. 
			     В основе сервиса по умолчанию используется LinkedBlockingQueue, но может быть передана и любая другая имплементация BlockingQueue.



	Иерархия:
	
		----------------------------------------------------------> (a)ForkJoinTask ---> (a)RecursiveAction
	       /									    ---> (a)RecursiveTask
(i)Future  ---> (i)RunnableFuture  ---> FutureTask	
	       \		       \						      ForkJoinWorkerThread	
		(i)ScheduledFuture --->(i)RunnableScheduledFuture
	       /
(i)Delayed ---> 								        (i)CompletionService ---> ExecutorCompletionService

(i)Callable			    	      Executors
			    	       (i)ThreadFactory			 ----> ForkJoinPool
			    (i)RejectedExecutionHandler			/
								       /		
(i)Executor ---> (i)ExecutorService --->(a)AbstractExecutorService ---> ThreadPoolExecutor ---> ScheduledThreadPoolExecutor
				   \							       /
			            ---> ScheduledExecutorService ------------------->---------



☣ Locks — представляет собой альтернативные и более гибкие механизмы синхронизации потоков по сравнению с базовыми synchronized, wait, notify, notifyAll.

 Condition — Интерфейс, который описывает альтернативные методы стандарным wait/notify/notifyAll. Объект с условием чаще всего получается из локов через метод
	     lock.newCondition(). Тем самым можно получить несколько комплектов wait/notify для одного объекта.

 Lock — Базовый интерфейс из lock framework, предоставляющий более гибкий подход по ограничению доступа к ресурсам/блокам нежели при использовании synchronized. 
	Так, при использовании нескольких локов, порядок их освобождения может быть произвольный. Плюс имеется возможность пойти по альтернативному сценарию, 
	если лок уже кем то захвачен.

 ReentrantLock — Лок на вхождение. Только один поток может зайти в защищенный блок. Класс поддерживает «честную» (fair) и «нечестную» (non-fair) разблокировку потоков.
		 При «честной» разблокировке соблюдается порядок освобождения потоков, вызывающих lock(). При «нечестной» разблокировке порядок освобождения потоков 
 		 не гарантируется, но, как бонус, такая разблокировка работает быстрее. По умолчанию, используется «нечестная» разблокировка.

 ReadWriteLock — Дополнительный интерфейс для создания read/write локов. Такие локи необычайно полезны, когда в системе много операций чтения и мало операций записи.

 ReentrantReadWriteLock — Очень часто используется в многопоточных сервисах и кешах, показывая очень хороший прирост производительности по сравнению с 
			  блоками synchronized. По сути, класс работает в 2-х взаимоисключающих режимах: много reader'ов читают данные в параллель и
			  когда только 1 writer пишет данные. 

 ReentrantReadWriteLock.ReadLock — Read lock для reader'ов, получаемый через readWriteLock.readLock().

 ReentrantReadWriteLock.WriteLock — Write lock для writer'ов, получаемый через readWriteLock.writeLock().

 LockSupport — Предназначен для построения классов с локами. Содержит методы для парковки потоков вместо устаревших методов Thread.suspend() и Thread.resume().


	(i)Condition   			  (i)ReadWriteLock 
	 LockSupport					  \
	     (i)Lock ---> ReentrantLock			   ReentrantReadWriteLock
		     ---> ReentrantReadWriteLock.ReadLock /	
		     ---> ReentrantReadWriteLock.WriteLock


 AbstractOwnableSynchronizer — Базовый класс для построения механизмов сихнронизации. 
			       Содержит всего одну пару геттер/сеттер для запоминания и чтения эксклюзивного потока, который может работать с данными.

 AbstractQueuedSynchronizer — Используется в качестве базового класса для механизма синхронизации в FutureTask, CountDownLatch, Semaphore, ReentrantLock,
			      ReentrantReadWriteLock. Может применяться при создании новых механизмов синхронизации, полагающихся на одиночное и атомарное значение int.

 AbstractQueuedLongSynchronizer — Разновидность AbstractQueuedSynchronizer, которая поддерживает атомарное значение long.


	AbstractOwnableSynchronizer ---> AbstractQueuedSynchronizer
				    ---> AbstractQueuedLongSynchronizer


☣ Atomics — классы с поддержкой атомарных операций над примитивами и ссылками.

 AtomicBoolean, AtomicInteger, AtomicLong, AtomicIntegerArray, AtomicLongArray — Что если в классе нужно синхронизировать доступ к одной простой переменной типа int?
 				Можно использовать конструкции с synchronized, а при использовании атомарных операций set/get, подойдет также и volatile.
				Но можно поступить еще лучше, использовав новые классы Atomic*. За счет использования CAS, операции с этими классами работают быстрее,
 				чем если синхронизироваться через synchronized/volatile. Плюс существуют методы для атомарного добавления на заданную величину, 
				а также инкремент/декремент.

 AtomicReference — Класс для атомарных операцией с ссылкой на объект.

 AtomicMarkableReference — Класс для атомарных операцией со следующей парой полей: ссылка на объект и битовый флаг (true/false).

 AtomicStampedReference — Класс для атомарных операцией со следующей парой полей: ссылка на объект и int значение.

 AtomicReferenceArray — Массив ссылок на объекты, который может атомарно обновляться.

 AtomicIntegerFieldUpdater, AtomicLongFieldUpdater,AtomicReferenceFieldUpdater — Классы для атомарного обновления полей по их именам через reflection. 
				Смещение полей для CAS определяется в конструкторе и кешируются, т.ч. тут нет сильного падения производительности из за reflection.

























