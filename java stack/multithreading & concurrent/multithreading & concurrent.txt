 ++++++++++++++++++++++
 +++ ОБЩИЕ СВЕДЕНИЯ +++
 ++++++++++++++++++++++

 Процесс - единица исполнения операционной системы (1 процесс может содержать в себе несколько потоков).
 Поток - единица исполнения программы.
 
 Конкуренция - ситуация в которой разным потокам необходим доступ к одному и тому же ресурсу.
 Параллелизм - ситуация в которой несколько потоков работают единовременно и их работа не имеет точек соприкосновения
 в виде общих ресурсов.
 
 Атомарность - свойство операции, которое говорит нам о том, что такая операция может находится только в одном из двух
 состояний: выполнена и невыполнена. Эта операция неделима.
 
 Модель памяти Java (Java Memory Model, JMM), относительно многопоточности, - описывает поведение потоков 
 в среде исполнения Java.
 Что описано в JMM? Чтение и запись переменной в многопоточной среде, работа с монитором, чтение и запись volatile 
 переменной, запуск нового потока, отношение happens-before и т.п.
 
 Некоторые термины имеющие отношение к JMM:
 - Видимость (visibility),- способность одним потоком увидить изменения состояний совершенные другим потоком.
   Некоторые интересные моменты:
	1. все операции с памятью, которые были сделаны потоком до выхода из synchronized блока должны быть видны любому потоку, 
	   который входит в synchronized блок для того же самого(!) монитора;
	2. чтения volatile переменной гарантированно вернёт последнее записанное в неё значение;
	3. нам не нужно дополнительно синхронизироваться, чтобы корректно прочитать final поля из одного потока в другом.
 - Переупорядочивание (reordering), - для увеличения производительности процессор или компилятор могут переставлять местами 
   некоторые инструкции и операции относительно исходного кода. reordering напрямую связан с отношением happens-before.
   Некоторые интересные моменты:
	1. операции чтения и записи volatile переменных не могут быть переупорядочены;
	2. в целом ситуации в которых мы не можем переупорядочивать операции описаны в правилах happens-before.
	3. не смотря на то, что порядок операций и инструкций меняется, смысл программы НЕ меняется, - такая гарантия 
	   называется "as-if-serial semantics" (в рамках одного потока - "sequential consistency", - всё выглядит так
	   будто исполняется последовательно)
 
 safe publication - показ объектов другим потокам из текущего, не нарушая ограничений visibility.
 Как это сделать в java:
 - static{} инициализатор
 - volatile переменные;
 - atomic переменные;
 - сохранение в разделяемой переменной, корректно защищенной с использованием synchronized(), 
   синхронизаторов или других конструкций, создающих read/write memory barrier;
 - final переменные в разделяемом объекте, который был корректно проинициализирован.
 
 --- --- ---
 
 В java процесс завершается тогда, когда завершается его последний обычный поток.
 Кроме обычных потоков существуют потоки-демоны. Потоки-демоны - это потоки обслуживающие обычные потоки. 
 Как правило, это различные фоновые и служебные задачи. Если в процессе остались только потоки-демоны, он завершится.
 В java, чтобы сделать поток потоком-демоном, нужно вызвать его метод setDaemon(true) . 

 Потоки выполняются асинхронно.
 Асинхронность означает то, что нельзя утверждать, что какая-либо инструкция одного потока, выполнится раньше или позже 
 инструкции другого. Порядок работы потоков не детерминирован.
 Следует помнить о том что операции чтения и записи памяти НЕ мгновенны.
 Основная проблема многопоточного программирования заключается в том, что сложно синхронизироватть работу разных потоков
 с одними и теми же ресурсами (общие регистры, англ.: shared register).

 Пример нотации: 
 e -> f (e happens before f)
 e || g (e is executed in parallel g)

 --- --- ---

 В языке java поток представляется в виде объекта класса Thread.
 
 Запустить поток в java можно тремя способами:
  1. Собственно создать потомка класса Thread и переопределить его метод run() .
  2. Имплиментировать целевому объекту интерфейс Runnable, таким образом добавив в этот объект метод run() .
     Создать объект класса Thread, передав ему в конструкторе этот объект.
     Плюс использования Runnable состоит в том, что это позволяет логически отделить выполнение задачи от логики управления потоками.
  3. Еще можно через новый интерфейс java.util.concurrent.Callable
     Callable представляет асинхронное вычисление, которое в конечном итоге возвращает объект.
     Future хранит результат асинхронного вычисления. Вы можете запустить вычисление, предоставив кому-либо объект Future, 
     и забыть о нем. Владелец объекта Future может получить результат, когда он будет готов.
 
 Жизненный цикл Thread
 Следует помнить, что указанные состояния не всегда отображают фактическое состояние потока, это лишь указания того какие
 указания мы отправили на рассмотрение планировщика потоков.
 STATE:
 -> NEW - состояние потока, который еще не начался.
 -> RUNNABLE - состояние для работающего потока. Нить в работоспособном состояние выполняется в виртуальной машине Java, 
    но ещё фактический может ждать других ресурсов от операционной системы (например: процессорное время).
 -> BLOCKED - состояние потока, заблокированного в ожидании блокировки монитора.
 -> WAITING - поток находится в состоянии ожидания из-за вызова одного из следующих методов:
    Object.wait, Thread.join, LockSupport.park
 -> TIMED_WAITING - поток находится в состоянии ожидания по времени из-за вызова одного из следующих методов, 
    с указанным положительным временем ожидания:
    Thread.sleep(long), Object.wait(long), Thread.join(long), LockSupport.parkNanos(long), LockSupport.parkUntil(long)  
 -> TERMINATED - состояние потока для завершенного потока, поток завершил выполнение.


 Класс ThreadGroup.
 Все потоки находятся в группах, представляемых экземплярами класса ThreadGroup. Группа указывается при создании потока. 
 Если группа не была указана, то поток помещается в ту же группу, где находится поток, породивший его.
 Методы activeCount() и enumerate() возвращают количество и полный список, соответственно, всех потоков в группе.


 Некоторые методы Thread:
  setName(String)		- задать имя потоку.
  setPriority(int от 1 до 10)	- задать приоритет потока 1 - min, 10 - max. Возможные значения priority — MIN_PRIORITY, 
				  NORM_PRIORITY и MAX_PRIORITY. Это указание для планировщика потоков.
				  Гипотетический, потоки с высоким приоритетом должны получать больше процессорного времени.
  setDaemon(boolian)		- сделать поток потоком-демоном.
  interrupt()			- (флаг)вывести поток у которого вызвали этот метод из состояния паузы (sleep(), wait() и join()).
				  При этом сгенерируется исключение InterruptedException.
  isAlive()			- возвращает true если поток выполняется и false если поток еще не был запущен или был завершен.
  getId()			- возвращает идентификатор потока. Идентификатор – уникальное число, присвоенное потоку.
  static yield()		- подсказка планировщику о том, что текущий поток готов отдать свое процессорное время.
				  Как правило используется в эксперементах по увеличению производительности. 
  static currentThread()	- позволяет в любом месте кода получить ссылку на объект класса Thread, представляющий текущий 
				  поток исполнения.
  holdsLock(obj)		- возвращает true тогда, когда текущий поток удерживает блокировку монитора для указанного объекта.
  static sleep(long)		- приостанавливает выполнение текущего потока на указанное количество миллисекунд. 
				  Требует обработки InterruptedException. Зависит от точности системных таймеров и планировщиков.
  join()			- позволяет одному потоку ждать завершения выполнения другого. Например, чтобы главный поток 
				  подождал завершения побочного потока myThready, необходимо выполнить инструкцию myThready.join() 
				  в главном потоке. Простыми словами: если мы хотим в нашем потоке подождать другой, мы, из 
				  нашего потока, приджоинимся к нему.

 Методы класса Object:
  wait()			- освобождает монитор и переводит вызывающий поток в состояние ожидания до тех пор, пока другой поток 
				  не вызовет метод notify()/notifyAll(); мы попадаем в wait-set того объекта у которого вызвали метод.
  wait(long)			- аналогичен предыдущему, но может перейти в state Running по истечению указанного кол-ва миллисекунд,
				  если не был вызван notify/notifyAll.
  notify()			- продолжает работу потока, у которого ранее был вызван метод wait();
  notifyAll()			- возобновляет работу всех потоков, у которых ранее был вызван метод wait().
  
  Поток может вызвать методы wait() или notify() для определённого объекта, только если он в данный момент имеет блокировку 
  на этот объект. Монитор надо захватывать в явном виде (через synchronized-блок), в том числе и потому что методы wait() 
  и notify() не синхронизированы. wait(), notify() и notifyAll() должны вызываться только из синхронизированного кода. 
  Эти методы работают с wait-set объекта, на котором проводилась блокировка.
  Когда вызван метод wait(), поток освобождает блокировку на объекте и переходит из состояния Работающий (Running) 
  в состояние Ожидания (Waiting). notify() и notifyAll() возвращают потоки в состояние Работающий (Running).
  Вернувшись в состояние Running поток продолжит исполнение с того места в которм был завейчен.
 

 Паттерн shared wait-set:
		1. объект shared (общий).
		2. кидаем ссылку на этот объект в потоки, в которым мы работаем с wait-set
		3. wait-notify вызываем синхронизировавшись на этом объекте.

 Запустили, отлично! Как теперь его остановить?
 В джава существуют методы позволяющие остановить поток принудительно (stop, suspend). Но их использование сопряжено с некоторыми 
 проблемами (потенциальные угрозы взаимных блокировок, остановка в недетерминируемом месте..).
 Вместо принудительного завершения потока рекомендуется применяться схема, в которой каждый поток сам ответственен за своё завершение.
 
 run(){return;}		//Завершение потока
 
 Как вариант, внутри потока можно держать флаг, который можно менять извне, а внутри потока при изменении флага принимать решение о том,
 какое действие совершить (завершить работу потока, закрыть ресурсы и т.п.).По сути, похожим образом реализована работа с .interrupt()
 
 --- --- ---
 
 Создание потоков это достаточно ресурснозатратная операция, кроме того количество потоков может быть ограничено имеющимися системными
 ресурсами или jvm. Решением этой проблемы может быть переиспользование потоков. Чтобы потоки было удобно переиспользовать мы можем
 держать их пул.
 
 Основной интерфейс для работы с пулами в джава, - Executor.
 Некоторые реализации ThreadPoolExecutor, ForkJoinPool
 
 Некоторые методы Executors для создания пулов:
 * newCachedThreadPool() - если есть свободный поток, то задача выполняется в нем, иначе добавляется новый поток в пул. 
   Потоки не используемые больше минуты завершаются и удалются и кэша. Размер пула неограничен. Предназначен для выполнения множество 
   небольших асинхронных задач.
 * newFixedThreadPool(int nThreads) - создает пул на указанное число потоков. Если новые задачи добавлены, когда все потоки активны, то 
   они будут сохранены в очереди для выполнения позже. Если один из потоков завершился из-за ошибки, на его место будет запущен другой поток. 
   Потоки живут до тех пор, пока пул не будет закрыт явно методом shutdown()
 * newSingleThreadScheduledExecutor() - однопотоковый пул с возможностью выполнять задачу через указанное время или выполнять периодически. 
   Если поток был завершен из-за каких-либо ошибок, то для выполнения следующей задачи будет создан новый поток.
 * newScheduledThreadPool(int corePoolSize) - пул для выполнения задач через указанное время или переодически;
 
 Как отправить задачу в пул?
 - execute(Runnable command) определён в интерфейсе Executor и выполняет поданную задачу и ничего не возвращает.
 - submit() – перегруженный метод, определённый в интерфейсе ExecutorService. Способен принимать задачи типов Runnable и Callable и 
   возвращать объект Future

 --- --- ---
 
 Выполнение нескольких потоков на одном процессоре в некотором порядке называется "Thread Scheduling".
 Среда выполнения Java поддерживает очень простой, детерминированный алгоритм планирования, называемый планированием с фиксированным приоритетом. 
 Этот алгоритм планирует потоки на основе их приоритета (учитываются потоки в Runnable) и демон-flag.
 
 Практическое правило:
 В любой момент времени выполняется поток с наивысшим приоритетом. Однако это не гарантируется. Планировщик потока может выбрать запуск потока 
 с более низким приоритетом, чтобы избежать голодания. По этой причине используйте приоритет потока только для того, чтобы повлиять на политику 
 планирования в целях повышения эффективности.
 
 В Java есть Планировщик Потоков(Thread Scheduler). ОН контролирует все запущенные потоки во всех программах и решает, какие потоки должны 
 быть запущены, и какие потоки должны изменить свои состояния.
 
 Именно планировщиком будет принято решение о том, что необходимо завершить программу, если остались только потоки-демоны.
 
 Некоторые пулы позволяют нам взаимодействовать с планировщиком, пример:
 ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();


 ++++++++++++++++++++++++++++++
 +++ ВЗАИМОДЕЙСТВИЕ ПОТОКОВ +++
 ++++++++++++++++++++++++++++++
  
 Если события в многопоточной среде не влияют друг на друга, они могут выполняться парралельно, порядок выполнения не гарантируется.
 Если события взаимосвязаны, то одно из них произойдет раньше другого (последовательно, о концепции happens before). 
 Концепция happens before говорит нам о том, что действия могут быть частично упорядочены. Мы никода не оперируем понятием глобального
 времени для описания парралельности потоков исполнения, лишь отношением "произошло до".
 
 Некоторые правила для отношения happens-before описанные в jmm:
 - В рамках одного потока любая операция happens-before любой операцией следующей за ней в исходном коде;
 - Освобождение монитора (unlock) happens-before захвату того же монитора (lock);
 - Выход из synchronized блока/метода happens-before вход в synchronized блок/метод на том же мониторе;
 - Запись volatile поля happens-before чтение того же самого volatile поля;
 - Завершение метода run() экземпляра класса Thread happens-before выход из метода join() 
   или возвращение false методом isAlive() экземпляром того же потока;
 - Вызов метода start() экземпляра класса Thread happens-before начало метода run() экземпляра того же потока;
 - Завершение конструктора happens-before начало метода finalize() этого класса;
 - Связь happens-before транзитивна, т.е. если X happens-before Y, а Y happens-before Z, то X happens-before Z.
 
 Линеаризуемость(англ. linearizability) в многопоточном программировании — это свойство программы, при котором результат любого 
 параллельного выполнения процедур (операций) эквивалентен некоторому последовательному выполнению. 
 Для любого другого потока выполнение линеаризуемой операции является мгновенным (атомарным): операция либо не начата, либо завершена.

  --- --- ---

 volatile - это ключевое слово означает, что значение этой переменной может изменяться другими потоками. 
 Как следствие запрещаются локальные копии, внутренние операции оптимизации, кеширование данных, перестановки в 
 инициализации переменных.
 
 volatile - этот модификатор вынуждает потоки отключить оптимизацию доступа и использовать единственный экземпляр переменной. 
 Если переменная примитивного типа – этого будет достаточно для обеспечения потокобезопасности. Если же переменная является ссылкой на 
 объект – синхронизировано будет исключительно значение этой ссылки. Все же данные, содержащиеся в объекте, синхронизированы не будут!
 
 Это поможет понять volatile:
 - Запись volatile поля happens-before чтению того же самого volatile поля (если кто-то записал значение в такое поле, то после
   даже из других потоков, можно будет считать только это новое значение (относительно глобального времени))
 - Операции чтения/записи volatile переменной являются атомарными.
 - volatile является safe publication (показ объектов другим потокам из текущего, не нарушая ограничений visibility).
 - volatile принуждает использовать единственный экземпляр переменной, но НЕ гарантирует атомарность. 
   Например, операция count++ не станет атомарной просто потому что count объявлена volatile. 
   C другой стороны class AtomicInteger предоставляет атомарный метод для выполнения таких комплексных операций атомарно, 
   например getAndIncrement() – атомарная замена оператора инкремента, его можно использовать, чтобы атомарно увеличить текущее 
   значение на один. Похожим образом сконструированы атомарные версии и для других типов данных.
 - Операции для таких полей являются линеаризуемыми.
 - Операции над НЕ volatile полями могут нарушать не только линеаризуемость, но и последовательную 
   согласованность (в отсутствии синхронизации).
 - volatile существенно замедляет код.
 
  --- --- --- 
  
 Локальные переменные потока, - это глобальные переменные в рамках текущего потока.

 private ThreadLocal myThreadLocal = new ThreadLocal();
 ThreadLocal —  класс, позволяющий имея одну переменную, иметь различное её значение для каждого из потоков.
 
 Для чего такое может понадобиться?
 Например, у вас есть приложение, которое пользуется различными библиотеками и фреймворками, цепочка вызовов уходит очень глубоко, 
 и где-то там вызывает ваш callback. Вы хотели бы передать дополнительную информацию (например, права текущего юзера, или там просто кэш),
 но промежуточные фреймворки не протягивают через цепочку вызовов эту дополнительную информацию. Что делать? Можно воспользоваться 
 статическими переменными, но что если ваше приложение многопоточное? За статические переменные будет конкуренция между потоками. 
 Решение — кладите информацию на входе в ThreadLocal, на выходе в callback'е можно будет забрать.
 
 Другой сценарий — это тот же кэш. В условиях многопоточной программы держать кэш потокобезопасным может оказаться дорого, ведь при 
 этом каждое обращение к кэшу означает дорогую синхронизацию. Решение — завести по экземпляру кэша в каждом потоке, положив его в ThreadLocal.
 
 --- --- ---
 
 Блокирующий метод - это метод который блокиирует поток исполнение до тех пор, пока не будет выполнена какая-то задача и возвращен callback
 пример: ServerSocket.accept()
		
 +++++++++++++++++++++
 +++ СИНХРОНИЗАЦИЯ +++
 +++++++++++++++++++++
 
 Синхронизация - это процесс в результате которого несколько потоков будут работать последовательно.
 
 mutual exclusion (взаимоисключающая блокировка, семафор с одним состоянием) - это паттерн описывающий механизм, 
 который гарантирует потоку исключительный доступ к ресурсу. Пример из java: synchronized и работа с монитором объекта. 
 Если просто, то его реализация в джава это и есть монитор (mutex).

 Подробнее и более простым языком.
 В основном хранилище для каждого объекта поддерживается блокировка ( lock ), над которой можно произвести два 
 действия – установить ( lock ) и снять ( unlock ). 
 Только один поток в один момент времени может установить блокировку на некоторый объект. 
 Если до того, как этот поток выполнит операцию unlock, 
 другой поток попытается установить блокировку, его выполнение будет приостановлено до тех пор, пока первый поток не отпустит ее.

 Каждый объект в java имеет ассоциированный с ним монитор. Этот монитор и есть сущность которая поддерживает работу блокировок.
 В java для того, чтобы воспользоваться механизмом блокировок, существует ключевое слово synchronized. 
 Оно может быть применено в двух вариантах:
  1. synchronized - блок ---> установить замок на каком-то конкретном объекте
  2. модификатор метода ---> поток устанавливает замок на объект, у которого был вызван данный метод. 
 То есть если мы хотим работать с монитором объекта мы используем ключевое слово synchronized.
 
 static synchronized метод, - здесь мы будем работать с монитором объекта класса Class<>.
 
 Объект для синхронизации делается private, чтобы сторонний код не мог на него синхронизироваться и случайно 
 получить взаимную блокировку.

 deadlock – взаимная блокировка. 
  Если один поток заблокировал один ресурс и пытается заблокировать второй, а другой поток заблокировал второй и пытается 
  заблокировать первый, то такие потоки уже никогда не выйдут из состояния ожидания.
  
 livelock - тип взаимной блокировки, при котором несколько потоков выполняют бесполезную работу, попадая в зацикленность при попытке 
 получения каких-либо ресурсов.
 Пример из жизни: два человека встречаются в узком коридоре и каждый, пытаясь быть вежливым, отходит в сторону, и так они бесконечно 
 двигаются из стороны в сторону, абсолютно не продвигаясь в нужном им направлении.
  
 Способы синхронизации в java:
 1. Использование wait()/notify() + synchronized.
 2. Использование join().
 3. Использование классов из пакета java.util.concurrent*
 
 * ReentrantLock – распространённая реализация Lock, которая предоставляет Lock с таким же базовым поведением и семантикой, 
   как у synchronized, но расширенными возможностями, такими как опрос о блокировании (lock polling), ожидание блокирования заданной 
   длительности и прерываемое ожидание блокировки. 
   
	Lock lock = new ReentrantLock();
	lock.lock();
	try { 
	  // update object state
	}
	finally {
	  lock.unlock(); 
	}
	
	+ Реализация ReentrantLock гораздо более масштабируема в условиях состязательности, чем реализация synchronized. 
	  Это значит, что когда много потоков соперничают за право получения блокировки, общая пропускная способность обычно 
	  лучше у ReentrantLock, чем у synchronized. JVM требуется меньше времени на установление очередности потоков и больше 
	  времени на непосредственно выполнение.
	- У ReentrantLock (как и у других реализаций Lock) блокировка должна обязательно сниматься в finally блоке (иначе, если бы 
	  защищенный код выбросил исключение, блокировка не была бы снята). Используя синхронизацию, JVM гарантирует, что блокировка 
	  автоматически снимаются.
	  
 * ReadWriteLock – это интерфейс расширяющий базовый интерфейс Lock. Используется для улучшения производительности в многопоточном 
   процессе и оперирует парой связанных блокировок (одна - для операций чтения, другая - для записи). Блокировка чтения может 
   удерживаться одновременно несколькими читающими потоками, до тех пор пока не появится записывающий. 
   Блокировка записи является эксклюзивной.
   
	ReadWriteLock rwLock = new ReentrantReadWriteLock();
	Lock rLock = rwLock.readLock();
	Lock wLock = rwLock.writeLock();

	wLock.lock();
	try {
		// exclusive write
	} finally {
		wLock.unlock();
	}
			
	rLock.lock();
	try {
		// shared reading
	} finally {
		rLock.unlock();
	}  

 --- --- ---	

 Если работа с ресурсами не синхронизирована, то потоки могут оказаться в состоянии гонки.
 Состояние гонки (race condition) - состояние, при которой эта работа программы напрямую зависит от того, в каком порядке 
 выполняются потоки, а этот порядок не гарантируется.
 
 +++++++++++++++++++++
 +++ Best practice +++
 +++++++++++++++++++++
 
 - именуйте потоки, - процесс отладки многопоточного приложения сложен, а стандартные имена крайне неинформативны.
 - избегайте блокировок и уменьшайте масштабы синхронизации; лучше синронизировать блок, чем весь метод целиком, так мы можем
   синхронизировать меньший участок кода.
 - крайне осторожно относитесь к прерываниям работы потока (чем он гипотетический может быть занят во время прерывания?).
 - внимательно относитесь к обработке исключений; помните про асинхронные исключения; познакомтесь с Thread.UncaughtExceptionHandler
 - Между синхронизаторами и wait() и notify() следует выбирать синхронизаторы. Так код будет более читаем, а в будущем внутренняя
   реализация может быть улучшена в новых версиях.
 - пользуйтесь Concurrent-коллекциями, они работают быстрее чем полностью синхронизированные.
 - Метод, который не оперирует с состояниями априори является потокобезопасным.
 

 ++++++++++++++++++++++++++++
 +++ java.util.concurrent +++
 ++++++++++++++++++++++++++++
 
  https://habrahabr.ru/company/luxoft/blog/157273/
   
  - Concurrent Collections	— набор коллекций, для работы в многопоточной среде.
  - Queues			— неблокирующие и блокирующие очереди с поддержкой многопоточности.
  - Synchronizers		— вспомогательные утилиты для синхронизации потоков.
  - Executors			— фрейморки для создания пулов потоков, планирования работы асинхронных задач с получением результатов. 
  - Locks			— альтернативные и более гибкие механизмы синхронизации потоков по сравнению с базовыми synchronized,
  				  wait, notify, notifyAll.
  - Atomics			— классы с поддержкой атомарных операций над примитивами и ссылками.


☣ Concurrent Collections — набор коллекций, для работы в многопоточной среде. Вместо базового враппера Collections.synchronizedList 
   с блокированием доступа ко всей коллекции используются блокировки по сегментам данных или же оптимизируется работа для параллельного
   чтения данных по wait-free алгоритмам.

  Содержит:
  - CopyOnWrite коллекции
  - Scalable Maps (масштабируемые)

  CopyOnWrite коллекции:
  Все операции по изменению коллекции (add, set, remove) приводят к созданию новой копии внутреннего массива. 
  Из массива в массив копируются ссылки!
  Использовать когда мы имеем дело с небольшим количеством операций записи.
  1. CopyOnWriteArrayList<E> — Потокобезопасный аналог ArrayList, реализованный с CopyOnWrite алгоритмом.
  2. CopyOnWriteArraySet<E> — Имплементация интерфейса Set, использующая за основу CopyOnWriteArrayList.


   CopyOnWriteArrayList ---> CopyOnWriteArraySet


  Scalable Maps:
  1. ConcurrentMap<K, V> 		— Интерфейс, расширяющий Map несколькими дополнительными атомарными операциями.
  2. ConcurrentHashMap<K, V> 		— В отличие от Hashtable и блоков synhronized на HashMap, данные представлены в виде сегментов,
  					  разбитых по hash'ам ключей. В результате, для доступ к данным лочится по сегментам, 
					  а не по одному объекту.
  3. ConcurrentNavigableMap<K,V> 	— Расширяет интерфейс NavigableMap и вынуждает использовать ConcurrentNavigableMap объекты в
  					  качестве возвращаемых значений.
  4. ConcurrentSkipListMap<K, V>	— Является аналогом TreeMap с поддержкой многопоточности. Данные также сортируются по ключу и
  					  гарантируется усредненная производительность log(N) для containsKey, get, put, remove
					  и других похожих операций.
  5. ConcurrentSkipListSet<E>		— Имплементация Set интерфейса, выполненная на основе ConcurrentSkipListMap.


   (i)ConcurrentMap ---> ConcurrentHashMap
	 	    ---> (i)ConcurrentNavigableMap ---> ConcurrentSkipListMap
					           ---> ConcurrentSkipListSet


☣ Queues — неблокирующие и блокирующие очереди с поддержкой многопоточности. 

   Неблокирующие очереди заточены на скорость и работу без блокирования потоков. 
   Блокирующие очереди используются, когда нужно «притормозить» потоки «Producer» или «Consumer», если не выполнены какие-либо условия, 
    например, очередь пуста или перепонена, или же нет свободного «Consumer»'a.

 Non-Blocking Queues:
  1. ConcurrentLinkedQueue<E>   	— В имплементации используется wait-free алгоритм от Michael & Scott, адаптированный для работы
  					  с garbage collector'ом. Этот алгоритм довольно эффективен и, что самое важное, очень быстр,
					  т.к. построен на CAS. Метод size() может работать долго, т.ч. лучше постоянно его не дергать.
  2. ConcurrentLinkedDeque<E>   	— Deque расшифровывается как Double ended queue и читается как «Deck». Это означает, что данные
  					  можно добавлять и вытаскивать с обоих сторон. Соответственно, класс поддерживает оба режима
					  работы: FIFO и LIFO. На практике, CLD стоит использовать только, если обязательно нужно LIFO,
					  т.к. за счет двунаправленности нод данный класс проигрывает по производительности на 40% 
					  по сравнению с ConcurrentLinkedQueue.

 Blocking Queues:
  1. BlockingQueue<E>   		— Интерфейс... добавляет queue возможностью задать размер очереди или блокировки по условиям,
  					  добавляет новые методы, которые реагируют по-разному на незаполнение или переполнение queue.
					  Не поддерживают null значения, т.к. это значение используется в методе poll как индикатор
					  таймаута. 
  2. ArrayBlockingQueue<E>   		— Класс блокирующей очереди, построенный на классическом кольцевом буфере. 
					  Доступна возможность управлять «честностью» блокировок. 
					  Если fair=false (по умолчанию), то очередность работы потоков не гарантируется. 
					  Более подробно о «честности» можно посмотреть в описании ReentrantLock'a.
  3. DelayQueue<E extends Delayed>   	— Довольно специфичный класс, который позволяет вытаскивать элементы из очереди только по
  					  прошествии некоторой задержки, определенной в каждом элементе через метод getDelay интерфейса
					  Delayed.
  4. LinkedBlockingQueue<E>    		— Блокирующая очередь на связанных нодах, реализованная на «two lock queue» алгоритме: 
  					  один лок на добавление, другой на вытаскивание элемента. По сравнению с ArrayBlockingQueue,
					  производительность выше, но и расход памяти у него выше.
  5. PriorityBlockingQueue<E>   	— Является многопоточной оберткой над PriorityQueue. При вставлении элемента в очередь, его
  					  порядок определяется в соответствии с логикой Comparator'а или имплементации Comparable
					  интерфейса у элементов. Первым из очереди выходит самый наименьший элемент.
  6. SynchronousQueue<E>   		— Эта очередь работает по принципу один вошел, один вышел.
  7. BlockingDeque<E>   		— Интерфейс, описывающий дополнительные методы для двунаправленной блокирующей очереди.
  8. LinkedBlockingDeque<E>  		— Двунаправленная блокирующая очередь на связанных нодах, реализованная как простой
  					  двунаправленный список с одним локом.
  9. TransferQueue<E>   		— Интерфейс, при добавлении элемента в очередь существует возможность заблокировать вставляющий
  					  «Producer» поток до тех пор, пока другой поток «Consumer» не вытащит элемент из очереди.
					  Блокировка может быть как с таймаутом, так и вовсе может быть заменена проверкой на наличие
					  ожидающих «Consumer»ов. 
					  Тем самым появляется возможность реализации механизма передачи сообщений с поддержкой 
					  как синхронных, так и асинхронных сообщений.
  10. LinkedTransferQueue<E>   		— Реализация TransferQueue на основе алгоритма Dual Queues with Slack. 
					  Активно использует CAS и парковку потоков, когда они находятся в режиме ожидания.

  (i)BlockingQueue ---> ArrayBlockingQueue
		   ---> DelayQueue
		   ---> LinkedBlockingQueue
		   ---> PriorityBlockingQueue
		   ---> SynchronousQueue
		   ---> (i)BlockingDequ	 ---> LinkedBlockingDeque
		   --->	(i)TransferQueue ---> LinkedTransferQueue
	

☣ Synchronizers — вспомогательные утилиты для синхронизации потоков. Представляют собой мощное оружие в «параллельных» вычислениях.

 Semaphore — Семафоры чаще всего используются для ограничения количества потоков при работе с аппаратными ресурсами или файловой
 	     системой. Доступ к общему ресурсу управляется с помощью счетчика. Если он больше нуля, то доступ разрешается, 
	     а значение счетчика уменьшается. 
	     Если счетчик равен нулю, то текущий поток блокируется, пока другой поток не освободит ресурс. 
	     Количество разрешений и «честность» освобождения потоков задается через конструктор.

 CountDownLatch — Позволяет одному или нескольким потокам ожидать до тех пор, пока не завершится определенное количество операций,
 		  выполняющих в других потоках.
		  Классический пример с драйвером довольно неплохо описывает логику класса: Потоки, вызывающие драйвер, будут висеть 
		  в методе await (с таймаутом или без), пока поток с драйвером не выполнит инициализацию с последующим вызовом метода
		  countDown. Этот метод уменьшает счетчик count down на единицу. 
		  Как только счетчик становится равным нулю, все ожидающие потоки в await продолжат свою работу, а все последующие
		  вызовы await будут проходить без ожиданий. Счетчик count down одноразовый и не может быть сброшен в первоначальное
		  состояние.

 CyclicBarrier — Может использоваться для синхронизации заданного количества потоков в одной точке. 
 		 Барьер достигается когда N-потоков вызовут метод await(...) и заблокируются. 
		 После чего счетчик сбрасывается в исходное значение, а ожидающие потоки освобождаются. 
		 Дополнительно, если нужно, существует возможность запуска специального кода до разблокировки потоков и сброса счетчика. 
		 Для этого через конструктор передается объект с реализацией Runnable интерфейса.

 Exchanger<V> — Как видно из названия, основное предназначение данного класса — это обмен объектами между двумя потоками. 
		При этом, также поддерживаются null значения, что позволяет использовать данный класс для передачи только одного объекта
		или же просто как синхронизатор двух потоков. Первый поток, который вызывает метод exchange(...) заблокируется 
		до тех пор, пока тот же метод не вызовет второй поток. Как только это произойдет, потоки обменяются значениями и 
		продолжат свою работу.

 Phaser — Улучшенная реализация барьера для синхронизации потоков, которая совмещает в себе функционал CyclicBarrier и CountDownLatch, 
 	  вбирая в себя самое лучшее из них. Так, количество потоков жестко не задано и может динамически меняться. Класс может повторно
	  переиспользоваться и сообщать о готовности потока без его блкрвки.


☣ Executors — содержит в себе отличные фрейморки для создания пулов потоков, планирования работы асинхронных задач с 
		получением результатов. 
 
   Разделы:
	- Future and Callable 		-- работа с асинхронными задачами
	- Executor Services		-- сервис для запуска Runnable или Callable задач
	- ThreadPoolExecutor & Factory	-- мощные средства управления потоками 
	- Fork Join			-- фреймворк для решения рекурсивных задач, работающих по алгоритмам разделяй и влавствуй 
					   или Map Reduce. 
	- Completion Service		-- работа с выполненными задачами


	FUTURE AND CALLABLE:

 Future<V> — Интерфейс для получения результатов работы асинхронной операции. Ключевым методом здесь является метод get, который
 	     блокирует текущий поток(с таймаутом или без) до завершения работы асинхронной операции в другом потоке. Также,
	     дополнительно существуют методы для отмены операции и проверки текущего статуса. В качестве имплементации часто
	     используется класс FutureTask.

 RunnableFuture<V> — Если Future — Интерфейс для Client API, то интерфейс RunnableFuture уже используется для запуска асинхронной части. 
		     Успешное завершение метода run() завершает асинхронную операцию и позволяет вытаскивать результаты через метод get.

 Callable<V> — Расширенный аналог интерфейса Runnable для асинхронных операций. 
 	       Позволяет возвращать типизированное значение и кидать checked exception. 
	       Несмотря на то, что в этом интерфейсе отсутсвует метод run(), многие классы java.util.concurrent поддерживают 
	       его наряду с Runnable.

 FutureTask<V> — Имплементация интерфейса Future/RunnableFuture. 
  		 Асинхронная операция принимается на вход одного из конструкторов в виде Runnable или Callable объектов.
		 Сам же класс FutureTask предназначен для запуска в worker потоке, например через new Thread(task).start(), 
		 или через ThreadPoolExecutor. Результаты работы асинхронной операции вытаскиваются через метод get(...).

 Delayed — Интерфейс, Используется для асинхронных задач, которые должны начаться в будущем, а также в DelayQueue. 
 	   Позволяет задавать время до начала аснхрннй операции.

 ScheduledFuture<V> — Маркерный интерфейс, объединяющий Future и Delayed интерфейсы.

 RunnableScheduledFuture<V> — Интерфейс, объединяющий RunnableFuture и ScheduledFuture. 
 			      Дополнительно можно указывать является ли задача одноразовой или же должна запускаться 
			      с заданной периодичностью.

	EXECUTOR SERVICES:

 Executor — Базовый интерфейс для классов, реализующих запуск Runnable задач. 
 	    Тем самым обеспечивается развязка между добавлением задачи и способом её запуска.

 ExecutorService — Интерфейс, который описывает сервис для запуска Runnable или Callable задач. 
 		   Методы submit на вход принимают задачу в виде Callable или Runnable, а в качестве возвращаемого значения идет Future,
		   через который можно получить результат. Методы invokeAll работают со списками задач с блокировкой потока до 
		   завершения всех задач в переданном списке или до истечения заданного таймаута. 
		   Методы invokeAny блокируют вызывающий поток до завершения любой из переданных задач. 
		   В дополнении ко всему, интерфейс содержит методы для graceful shutdown. 
		   После вызова метода shutdown, данный сервис больше не будет принимать задачи, кидая RejectedExecutionException 
		   при попытке закинуть задачу в сервис.

 ScheduledExecutorService — В дополнении к методам ExecutorService, данный интерфейс добавляет возможность запускать отложенные задачи.

 AbstractExecutorService — Абстрактный класс для построения ExecutorService'a. 
 			   Имплементация содержит базовую имплементацию методов submit, invokeAll, invokeAny. 
			   От этого класса наследуются ThreadPoolExecutor, ScheduledThreadPoolExecutor и ForkJoinPool.
		

	THREADPOOLEXECUTOR & FACTORY:

 Executors — Класс-фабрика для создания ThreadPoolExecutor, ScheduledThreadPoolExecutor. 
	     Если нужно создать один из этих пулов, эта фабрика именно то, что нужно. 
	     Также, тут содержатся разные адаптеры Runnable-Callable, PrivilegedAction-Callable, PrivilegedExceptionAction-Callable 
	     и другие.

 ThreadPoolExecutor — Очень мощный и важный класс. Используется для запуска асинхронных задач в пуле потоков. 
 		      Тем самым практически полностью отсутствует оверхэд на поднятие и остановку потоков. 
		      А за счет фиксируемого максимума потоков в пуле обеспечивается прогнозируемая производительность приложения. 
		      Как было ранее сказано, создавать данный пул предпочтительно через один из методов фабрики Executors.
		      Если же стандартных конфигураций будет недостаточно, то через конструкторы или сеттеры можно задать все основые
		      параметры пула.

 ScheduledThreadPoolExecutor — В дополнении к методам ThreadPoolExecutor, позволяет запускать задачи после определенной задержки, 
 			       а также с некоторой периодичностью, что позволяет реализовать на базе этого класса Timer Service.

 ThreadFactory — По умолчанию, ThreadPoolExecutor использует стандартную фабрику потоков, получаемую через 
 		 Executors.defaultThreadFactory(). Если нужно что-то больше, например задание приоритета или имени потока, 
		 то можно создать класс с реализацией этого интерфейса и передать его в ThreadPoolExecutor.

 RejectedExecutionHandler — Позволяет определить обработчик для задач, которые по каким то причинам не могут быть выполнены через
 			    ThreadPoolExecutor. Такой случай может произойти, когда нет свободных потоков или сервис выключается 
			    или выключен (shutdown). Несколько стандартных имплементаций находятся в классе ThreadPoolExecutor:
			    CallerRunsPolicy — запускает задачу в вызывающем потоке;
			    AbortPolicy — кидает эксцепшен; 
			    DiscardPolicy — игнорирует задачу; 
			    DiscardOldestPolicy — удаляет самую старую незапущенную задачу из очереди, затем пытается добавить 
			    			  новую задачу еще раз.


	FORK JOIN:
	
	набор классов и интерфейсов позволяющих использовать преимущества многопроцессорной архитектуры современных компьютеров. 
	Он разработан для выполнения задач, которые можно рекурсивно разбить на маленькие подзадачи, которые можно решать параллельно.
	
	Этап Fork: большая задача разделяется на несколько меньших подзадач, которые в свою очередь также разбиваются на меньшие. 
				И так до тех пор, пока задача не становится тривиальной и решаемой последовательным способом.
	Этап Join: далее (опционально) идёт процесс «свёртки» - решения подзадач некоторым образом объединяются пока не получится 
				решение всей задачи.

 ForkJoinPool — Представляет собой точку входа для запуска корневых (main) ForkJoinTask задач. 
		Подзадачи запускаются через методы задачи, от которой нужно отстрелиться (fork). 
		По умолчанию создается пул потоков с количеством потоков равным количеству доступных для JVM процессоров (cores).

 ForkJoinTask — Базовый класс для всех Fork Join задач. Из ключевых методов можно отметить: 
 		fork() — добавляет задачу в очередь текущего потока ForkJoinWorkerThread для асинхронного выполнения; 
		invoke() — запускает задачу в текущем потоке; join() — ожидает завершения подзадачи с возвращением результата; 
		invokeAll(...) — объединяет все три предыдущие предыдущие операции, выполняя две или более задач за один заход;
		adapt(...) — создает новую задачу ForkJoinTask из Runnable или Callable объектов.

 RecursiveTask — Абстрактный класс от ForkJoinTask, с объявлением метода compute, в котором должна производиться асинхронная операция 
 		 в наследнике.

 RecursiveAction — Отличается от RecursiveTask тем, не возвращает результат.

 ForkJoinWorkerThread — Используется в качестве имплементации по умолчанию в ForkJoinPoll. 
 			При желании можно отнаследоваться и перегрузить методы инициализации и завершения worker потока. 


	COMPLETION SERVICE:

 CompletionService — Интерфейс сервиса с развязкой запуска асинхронных задач и получением результатов. 
 		     Так, для добавления задач используются методы submit, а для вытаскивания результатов завершенных 
		     задач используются блокирующий метод take и неблокирующий poll. 

 ExecutorCompletionService — По сути является враппером над любым классом, реализующим интерфейс Executor, например 
 			     ThreadPoolExecutor или ForkJoinPool. Используется преимущественно тогда, когда хочется абстрагироваться 
			     от способа запуска задач и контроля за их исполнением. 
			     Если есть завершенные задачи — вытаскиваем их, если нет — ждем в take пока что-нибудь не завершится. 
			     В основе сервиса по умолчанию используется LinkedBlockingQueue, но может быть передана и любая другая
			     имплементация BlockingQueue.

	Иерархия:
	
		----------------------------------------------------------> (a)ForkJoinTask ---> (a)RecursiveAction
	       /									    ---> (a)RecursiveTask
(i)Future  ---> (i)RunnableFuture  ---> FutureTask	
	       \		       \						      ForkJoinWorkerThread	
		(i)ScheduledFuture --->(i)RunnableScheduledFuture
	       /
(i)Delayed ---> 								     (i)CompletionService ---> ExecutorCompletionService

(i)Callable			    	      Executors
			    	       (i)ThreadFactory			 ----> ForkJoinPool
			    (i)RejectedExecutionHandler			/
								       /		
(i)Executor ---> (i)ExecutorService --->(a)AbstractExecutorService ---> ThreadPoolExecutor ---> ScheduledThreadPoolExecutor
				   \							       /
			            ---> ScheduledExecutorService ------------------->---------



☣ Locks — представляет собой альтернативные и более гибкие механизмы синхронизации потоков по сравнению с базовыми synchronized, wait,
	   notify, notifyAll.

 Condition — Интерфейс, который описывает альтернативные методы стандарным wait/notify/notifyAll. 
 	     Объект с условием чаще всего получается из локов через метод lock.newCondition(). 
	     Тем самым можно получить несколько комплектов wait/notify для одного объекта.

 Lock — Базовый интерфейс из lock framework, предоставляющий более гибкий подход по ограничению доступа к ресурсам/блокам нежели 
 	при использовании synchronized. 
	Так, при использовании нескольких локов, порядок их освобождения может быть произвольный. 
	Плюс имеется возможность пойти по альтернативному сценарию, если лок уже кем то захвачен.

 ReentrantLock — Лок на вхождение. Только один поток может зайти в защищенный блок. 
 		 Класс поддерживает «честную» (fair) и «нечестную» (non-fair) разблокировку потоков.
		 При «честной» разблокировке соблюдается порядок освобождения потоков, вызывающих lock(). 
		 При «нечестной» разблокировке порядок освобождения потоков не гарантируется, но, как бонус, 
		 такая разблокировка работает быстрее. По умолчанию, используется «нечестная» разблокировка.

 ReadWriteLock — Дополнительный интерфейс для создания read/write локов. 
 		 Такие локи необычайно полезны, когда в системе много операций чтения и мало операций записи.

 ReentrantReadWriteLock — Очень часто используется в многопоточных сервисах и кешах, показывая очень хороший прирост производительности
 			  по сравнению с блоками synchronized. По сути, класс работает в 2-х взаимоисключающих режимах: много reader'ов
			  читают данные в параллель и когда только 1 writer пишет данные. 

 ReentrantReadWriteLock.ReadLock — Read lock для reader'ов, получаемый через readWriteLock.readLock().

 ReentrantReadWriteLock.WriteLock — Write lock для writer'ов, получаемый через readWriteLock.writeLock().

 LockSupport — Предназначен для построения классов с локами. 
 	       Содержит методы для парковки потоков вместо устаревших методов Thread.suspend() и Thread.resume().


	(i)Condition   			  (i)ReadWriteLock 
	 LockSupport					  \
	     (i)Lock ---> ReentrantLock			   ReentrantReadWriteLock
		     ---> ReentrantReadWriteLock.ReadLock /	
		     ---> ReentrantReadWriteLock.WriteLock


 AbstractOwnableSynchronizer — Базовый класс для построения механизмов сихнронизации. 
			       Содержит всего одну пару геттер/сеттер для запоминания и чтения эксклюзивного потока, 
			       который может работать с данными.

 AbstractQueuedSynchronizer — Используется в качестве базового класса для механизма синхронизации в FutureTask, CountDownLatch,
 			      Semaphore, ReentrantLock, ReentrantReadWriteLock. 
			      Может применяться при создании новых механизмов синхронизации, полагающихся на одиночное и 
			      атомарное значение int.

 AbstractQueuedLongSynchronizer — Разновидность AbstractQueuedSynchronizer, которая поддерживает атомарное значение long.

 AbstractOwnableSynchronizer	---> AbstractQueuedSynchronizer
				---> AbstractQueuedLongSynchronizer


☣ Atomics — классы с поддержкой атомарных операций над примитивами и ссылками.

 AtomicBoolean, AtomicInteger, AtomicLong, AtomicIntegerArray, AtomicLongArray — Что если в классе нужно синхронизировать доступ 
 	к одной простой переменной типа int? Можно использовать конструкции с synchronized, а при использовании атомарных операций
	set/get, подойдет также и volatile. Но можно поступить еще лучше, использовав новые классы Atomic*. За счет использования CAS,
	операции с этими классами работают быстрее, чем если синхронизироваться через synchronized/volatile. Плюс существуют методы для
	атомарного добавления на заданную величину, а также инкремент/декремент.

 AtomicReference — Класс для атомарных операцией с ссылкой на объект.

 AtomicMarkableReference — Класс для атомарных операцией со следующей парой полей: ссылка на объект и битовый флаг (true/false).

 AtomicStampedReference — Класс для атомарных операцией со следующей парой полей: ссылка на объект и int значение.

 AtomicReferenceArray — Массив ссылок на объекты, который может атомарно обновляться.

 AtomicIntegerFieldUpdater, AtomicLongFieldUpdater,AtomicReferenceFieldUpdater — Классы для атомарного обновления полей по их именам
 	через reflection. Смещение полей для CAS определяется в конструкторе и кешируются, т.ч. тут нет сильного падения 
	производительности из за reflection.






