Тестирование:
- модульное
- интеграциональное
- функциональное

+ нагрузочное
+ регрессионное

бенчмарк - тестирование
профилирование - время работы метода
_________________________________________________
==================== Junit ======================
Юнит-тестирование (модульное тестирование) есть автоматизированное тестирование отдельных функций/классов в независимом окружении, то есть без использования сторонних классов или функций, от которых проверямый код зависит. Идея состоит в том, чтобы убедиться в постоянности поведения самого класса/функции, а не в том, как он взаимодействует с другим кодом.
Юнит тестирование должно покрывать функциональность разрабатываемого приложения.

Юнит-тест этой функции покрывает только описанный функционал. Цель юнит-тестирования — убедиться, что функция работает правильно, а не искать условия,
в которых она работает неправильно.

Юнит-тестирование также используют для фиксации поведения кода. Мы знаем, прямо сейчас, что функция ведёт себя определённым образом. И код, который её использует, полагается на это поведение. Когда мы захотим изменить эту функцию, юнит-тест будет вам гарантировать, что
поведение функции осталось таким же (либо тест провалится). Следовательно остальной код не заметит изменения реализации функции, а это значит, что с этого момента мы можем спокойной менять любую часть кода: юнит-тесты не позволят нам что-нибудь сломать.
_________________________________________________
Все юнит-тесты пишутся по единому шаблону:
1 создаются входные данные,
2 создаются эталонные данные (expected),
3 вызывается тестируемый код и
3 результат его работы(actual) сравнивается с эталонными данными.
_________________________________________________
JUnit предоставляет несколько assert*  функций, выполняюших сравнение.
	assertEquals сравнивает эквивалентность объектов expected и actual и, в случае когда они не эквивалентны, проваливает тест и выводит сообщение.
		assertEquals позволяет указать погрешность, например если мы сравниваем значения c плавающей точкой.
	assertTrue и assertFalse - ждут true и false соответственно
	assertArrayEquals - помогает сравнивать массивы
_________________________________________________
Любой public void  метод, с аннотацией @Before  будет вызван автоматически перед запуском каждого теста (то есть столько раз, сколько в классе
тестов). Традиционно такой метод называют setUp.

@After . Эта аннотация так же требует public void метод, который будет вызван после каждого теста. Традиционно такой метод называют tearDown.

Для значений, которые достаточно проинициализировать один раз или инициализация которых слишком медленна, чтобы делать это перед каждым тестом, предусмотрены аннотации @BeforeClass/@AfterClass . Методы, которые ими можно аннотировать, должны быть статическими, а поэтому работать они могут только с статическими членами класса. Процедуры, аннотированные @BeforeClass/@AfterClass  традиционно называеются setUpClass  и tearDownClass  соответственно.
_________________________________________________
Следует помнить, что порядок тестов в обычных условиях не определён и может меняться между запусками, если другое поведение не указано явно.
_________________________________________________
JUnit использует родственный проект Hamcrest, сфокусированный на разработке универсальных матчеров. А заключается основное преимущество матчеров перед старорежимными assert* методами в том, что матчер может быть любым (до той поры, пока он следует интерфейсу) и использование матчеров позволяет декларативно описывать условия теста.

Нужно подгрузить зависимость: hamcrest-library

//Доказать что(assertThat) пантера(panther) розовая(is(pink()).
assertThat(panther, is(pink());
_________________________________________________
Параметер expected говорит JUnit что метод должен кинуть исключение указанного типа и это не будет ошибкой теста. А вот если исключение не будет брошено, это будет ошибкой теста.

    @Test(expected = NumberFormatException.class)
    public void testToDoubleException() {
        StringUtils.toDouble(testString);
    }

Также можно проверять исключения с использованием првил. 
	    @Rule
	    public ExpectedException exception = ExpectedException.none();
И с помощью подхода  try/catch/fail (ловим ошибку в методе выводим принтстактрейс, если ошибки нет - проваливаем тест вручную)
_________________________________________________
Тест можно пропустить используя аннотацию:
@Ignore("Disabled for educational reason.")

но лучше ничего не игнорировать :)
_________________________________________________
Мы можем создавать параметризированные тесты:
1. Создать параметры - поля
2. Создать конструктор для этих параметров
3. Создать специальный метод с аннотацией @Parameters, в котором мы определим массив массивов параметров
4. Поставить аннотацию @RunWith(Parameterized.class) над классом,
 чтобы сказать что тест нужно запустить со всем набором параметров определённым в методе @Parameters
_________________________________________________
Теории
Теории объединяют предусловия и параметризацию, позволяя писать обобщённые тесты.
Часто встречается необходимость проверять одно и тоже поведение, с разными данными. 

Теории предлагают общие тесты, которые можно выразить как «При определённых предположениях код всегда ведёт себя определённым образом». «Всегда» означает: «с любыми данными». Пример такого утверждения: «При возведении числа в целую чётную степень результат всегда будет положительным». «Возведение числа» — код, «Целая чётная степень» — предположение, «Всегда положительный» — проверяемый результат. В общем виде теории позволяют выразить предназначение и поведение кода.

1. Создали класс @RunWith(Theories.class)
2. Создали теорию @Theory
3. Создали параметры которыми будет оперировать тория @DataPoint
_________________________________________________
Правила- код, исполняющийся «вокруг» тестового метода, для каждого такого метода, позволяя расширять и переделывать поведение JUnit каким угодно образом.

JUnit содержит несколько заранее написанных правил:
1 TemporaryFolder - Предоставляет временную директорию для файлов, которая будет очищена после завершения теста.
2 TestName - Позволяет тестам узнавать собственное имя.
3 ErrorCollector - Собирает ошибки, возникающие в ходе выпонения теста и проваливает весь тест целиком. Полезен, когда проверяется поведение при каких-то независимых условиях и хочется проверить всё сразу.
4 Verifier - Базовый класс для ErrorCollectior , позволяет провалить успешный тест, если он не проходит проверку после выполнения (пример из официальной документации JUnit):
5 ExpectedException - Улучшает поддержку исключений в JUnit.
6 Timeout - для проверки кода, который содержит циклы или рекурсию, может, при определённых условиях, исполняться бесконечно долго.

_________________________________________________
Runners - способ группировки тестов.

_________________________________________________
Некоторые замечания:

1. На один тест - один assert, но в целом если метод прост - один тест на метод. На сложные методы - несколько тестов (нужно спрашивать на проекте).
2. геттеры\сеттеры - зависти от проекта, если есть логика - надо
3. Помни что тесты в junit могут вызываться не в том порядке, в котором они описаны в классе\классах.
4. Мы проверяем исключительно поведение. Тест должен проваливаться только когда поведения тестируемого кода изменилось (или не соответствует задуманному).
5. Тест должен быть фальсифицируемым.
6. Лучше плохой тест, чем никакого теста =)

!!! --- JUnit5 переписывался с нуля, там очень много изменений --- !!!
!!! --- https://habrahabr.ru/post/337700/		       --- !!!



-----------------------------------------------------------------+++
Простые рецепты хороших юнит тестов – Константин Заикин
https://habr.com/ru/company/yandex/blog/436850/
https://www.youtube.com/watch?time_continue=299&v=ZyGZjpxF9Fo


















