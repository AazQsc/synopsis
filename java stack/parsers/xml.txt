XML - eXtensible Markup Language — расширяемый язык разметки. 

XML - это промышленный стандарт, определенный W3C.
XML технология лежит в основе SOAP веб-сервисов.

___________________
---- Схема XML ----

Определение схемы XML (XSD) представляет собой основанное на XML определение грамматики, которое используется для описания структуры
и содержимого XML-документа. Благодаря XSD элементы и атрибуты становятся строго типизированными и имеют информацию о типе данных,
связанную с ними.

Некоторые элементы подмножества XSD-элементов:
	element - Элементы объявляются с помощью элемента element. Например, order — это элемент, который в документе выглядит как:
			<order id="1234" date="11/08/2013" total_amount="93.48">
	type - Элемент может иметь простой тип, например string, decimal, long или double (type="xs:long") или сложный (type="customer")
	complexType - Определяет комплексный тип, имеющий собственные элементы, подэлементы и атрибуты.

__________________________
---- Анализаторы схем ----

Если у вас есть XML-документ и связанное с ним определение схемы XML, вы можете использовать анализатор, чтобы он проверил документ 
за вас. Анализаторы могут быть одного из двух основных типов: DOM и SAX.

Aнализатор == процессор xml
выполняет анализ разметки и делает данные, содержащиеся в XML, доступными для нуждающихся в них приложений.

_________________
---- Парсеры ----
Существует три подхода к чтению xml:
				Объектный
				событийный
				потоковый

В java чаще всего имеем дело с двумя реализациями: DOM и SAX

Объектный API 
DOM (Document Object Model) - Объектная модель документа, который считывает весь источник данных XML и строит в оперативной памяти его
древовидное представление. DOM лучше использовать для небольших структур данных XML в случаях, когда скорость не имеет первостепенного
значения для приложения или требуется произвольный доступ ко всему содержимому документа.

Поскольку DOM основывается на иерархии информации, про нее говорят, что она древовидно-базированная или объектно-базированная.
DOM также обеспечивает API, который позволяет разработчику добавлять или удалять узлы в любой точке дерева в надлежащим образом
созданном приложении.
	Анализаторы: JDOM, TinyXML, pugixml

Событийный API
SAX (Simple API for XML) - модель на основе событий под названием «простой API для XML», который считывает источник данных XML и
выполняет функции обратного вызова приложения всякий раз, когда он сталкивается с определенным разделом (концом элемента). 
То есть он не строит модель в памяти на подобии DOM, а идет по документу последовательно, шаг за шагом. <- событийная модель

Если нам необходимо прочесть элемент который уже был прочтен, необходимо начать считать документ заново. Плюс этого подхода заключается
в низких расходах оперативной памяти и скорости считывания. SAX является самым быстрым способом анализа XML и подходит для работы с
большими документами, которые не могут быть считаны в память целиком.
	Анализаторы: Expat

---- XPath ----

Выполнение запросов с помощью XPath

XPath (XML Path Language) - язык запросов к элементам XML-документа. Разработан для организации доступа к частям документа XML в 
файлах трансформации XSLT и является стандартом консорциума W3C. XPath призван реализовать навигацию по DOM в XML.

Выражения XPath могут представлять собой узел, двоичное значение, число или строку.
Наиболее распространенный тип выражений XPath — это путь, который представляет собой адрес узла.

Выражения могут быть достаточно сложными и иметь много условий.

--------------------------
<!-- пример xpath -->
--------------------------
http://msiter.ru/tutorials/uchebnik-xml-dlya-nachinayushchih/xml-i-xpath

______________
---- XSLT ----

XSLT (eXtensible Stylesheet Language Transformations) — язык преобразования XML-документов.

Мы можем трансформировать XML-документ в форму, подготовленную к печати, или веб-страницу.
	1 Создать таблицу стилей XSL (набор инструкций по преобразованию для трансформации исходного дерева в конечное).
	2 Процессор XSLT преобразует исходный документ, связывая шаблоны исходного дерева XML с шаблонами применяемой таблицы стилей.
Шаблон — это выражение XPath, которое сравнивается с элементами исходного дерева. При совпадении создается часть результирующего дерева.

Общий API для XSLT располагается в пакете javax.xml.transform и использу­ется для составления инструкций стилей и преобразования
источника XML в результирующий XML-документ. XSLT также можно использовать вместе с SAX API, чтобы преобразовать данные в XML.

__________________
---- JAVA API ----

JAXP (Java Architecture for XML Processing — архитектура Java для обработки XML) — это низкоуровневая спецификация (JSR 206), 
которая дает возможность очень гибко обрабатывать XML, а также позволяет использовать SAX, DOM или XSLT. 
Этот API также применяется JAXB и StAX. -> Этот API также применяется JAXB и StAX.

1. Java Architecture for XML Binding (JAXB) позволяет Java разработчикам ставить в соответствие Java классы и XML представления. 
JAXB предоставляет две основные возможности: маршаллирование Java объектов в XML и наоборот, то есть демаршализация из XML 
обратно в Java объект. (JSR 222)

2. Streaming API for XML (StAX) — потоковый API для XML. Представляет собой API для чтения и записи XML-документов. 
Умеет работать с DOM и SAX. (JSR 173)

Используя JAXP, можно анализировать XML-документы с помощью SAX, DOM, XSLT.
Архитектура JAXP:

		JAXP
	/	|		\
SAX API  	DOM API  	XSLT API
	|	|		|
SAX proc 	DOM proc 	XSLT proc

JAXP состоит из четырех пакетов:
	javax.xml.parsers 	Общий интерфейс для анализаторов DOM и SAX
	org.w3c.dom 		Общий API для работы с DOM в Java
	org.xml.sax 		Определяет интерфейсы, использованные для анализаторов SAX
	javax.xml.transform 	API XLST для преобразования XML в другие типы документов

--------------------------
<!-- пример 1 sax -->
--------------------------

SAX более мощный инструмент, нежели может показаться в начале. В SAX 2.0 добавлена поддержка пространства имён. 
Данные могут быть направлены в другой процессор SAX, на преобразование или (конечно же) в файл. 
Мы можем изменить данные перед их анализом (XMLFilter).

1. Для использования SAX парсера, нужно определить класс, расширяющий DefaultHandler. 
Правильный разбор при помощи SAX требует специфических вызовов методов этого обработчика.
	public class MySAXParser extends DefaultHandler {}

2. Это наш парсер.
	XMLReader xmlReader;

3.Мы используем пару классов, SAXParserFactory и SAXParser, чтобы создать парсер.
SAXParserFactory настраивает и создает объект анализатора SAX.
SAXParser является оберткой объекта SAXReader, на который он может ссылаться с помощью getXMLReader()
	SAXParserFactory spfactory = SAXParserFactory.newInstance();
4. проверку правильности XML использовать не будем.
        spfactory.setValidating(false);
	SAXParser saxParser = spfactory.newSAXParser();
	xmlReader = saxParser.getXMLReader();

5. Парсер должен посылать свои события в ContentHandler.
Всего DefaultHandler реализует четыре различных обработчика:
 ContentHandler,
 ErrorHandler,
 DTDHandler,
 EntityResolver
	xmlReader.setContentHandler(new MySAXParser());

6. InputSource - класс является SAX оболочкой для любых данных, которые мы будем обрабатывать.
   Оборачиваем в эту оболочку наш файл xml
	InputSource source = new InputSource("new.xml");

7. метод parse(InputSource) принимает такой объект в качестве аргумента
	xmlReader.parse(source);

8. Методы DefaultHandler с помощью которых мы 
startDocument()
startElement(
	String namespaceURI, 
	String localName,
	String qName, 
	Attributes atts
	)

--------------------------
Потоковый обработчик StAX
--------------------------
StAX можно работать через 2 API:
	низкоуровневое XMLStreamReader, возвращающая примитивы
	высокоуровневое XMLEventReader, которое возвращает объекты


https://habrahabr.ru/post/339716/
--------------------------
<!-- пример 2 dom -->
--------------------------

"Карта DOM"

ПАРСЕР --- анализирует ---> XML-файл --- для создания
						|
						|
						|
УЗЛОВ <------ который состоит из ------- ДОКУМЕНТА DOM
 |
 |
 |
которыми могут быть ---> ЭЛЕМЕНТЫ, ТЕКСТ, АТРИБУТЫ или ДРУГИЕ ТИПЫ УЗЛОВ
						|
						|
						|
					которые являются частью
ПРОСТРАНСТВ ИМЕН <--------------------- одного или нескольких определённых
 |
 |
 |
и могут обрабатываться
любыми определёнными   ---------------> МЕТОДАМИ ОБЪЕКТОВ
						|
						|
						|
API DOM <------------------------------ которые являются частью

СПЕЦИФИКАЦИЯ
Уровень 0 - Включает в себя все специфические модели DOM, которые существовали до появления Уровня 1, например, document.images,
	    document.forms, document.layers и document.all. Необходимо обратить внимание, что эти модели формально не являются
	    спецификациями DOM, опубликованными W3C, а скорее являются информацией о том, что существовало до начала процесса
	    стандартизации.
Уровень 1 - Базовые функциональные возможности DOM (HTML и XML) в документах, такие как получение дерева узлов документа, возможность
	    изменять и добавлять данные.
Уровень 2 - Поддержка так называемого пространства имён XML <--filtered views--> и событий.
Уровень 3 - Состоит из шести различных спецификаций, эти спецификации являются дополнительными расширениями DOM:
  DOM Level 3 Core;
  DOM Level 3 Load and Save;
  DOM Level 3 XPath;
  DOM Level 3 Views and Formatting;
  DOM Level 3 Requirements;
  DOM Level 3 Validation.	
Текущим уровнем спецификаций DOM является Уровень 2, но тем не менее некоторые части спецификаций Уровня 3 являются рекомендуемыми W3C.

DOM очень мощный инструмент, он позволяет нам не просто просматривать документ, но и редактировать его: добавлять узлы и атрибуты,
задавать их значения. Можно сконструировать новый XML и отправить его как ответ.


В среде Java разбор файла является 3-шаговым процессом:
1. Создание DocumentBuilderFactory. Этот объект создает DocumentBuilder. 
   У него в атрибутах мы можем указать нажна ли проверка правильности документов, нужно ли игнорировать комментарии и тому подобное.
2. Создание DocumentBuilder. DocumentBuilder действительно выполняет разбор для создания объекта Document.
3. Разбор файла для создания объекта Document.

        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
        DocumentBuilder db = dbf.newDocumentBuilder();
        doc = db.parse(File);				// это и есть нах xml

Когда парсер создал документ, приложение может проходить через него для обработки данных.
Некоторые примеры:

1: получить корневой элемент
	Element root = doc.getDocumentElement();
        System.out.println("The root element is " + root.getNodeName());

2: получить наследников (количество)
        NodeList children = root.getChildNodes();
        System.out.println("There are " + children.getLength() + " nodes in this документ." + "\n");


----------------------
<!-- пример 3 xslt -->
----------------------

Есть my.xml ...

<?xml version="1.0" encoding="WINDOWS-1251"?>
<?xml-stylesheet type='text/xsl' href='my.xsl'?>
<tutorial>
  <title>"Заметки об XSL"</title>
  <author>Yaraslau</author>
</tutorial>

... и для него my.xsl ...

<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/TR/WD-xsl">
<xsl:template match="/">
  <p><strong><xsl:value-of select="//title"/></strong></p>
  <p><xsl:value-of select="//author"/></p>
</xsl:template>
</xsl:stylesheet>

... теперь если мы его откроем в его браузере, увидим отредактированную страничку.


-------------------------------
<!-- пример 4 xmlpullparser -->
-------------------------------

Google в Android-приложениях рекомендует использовать именно его.

Android не поддерживает API StAX.
Однако в состав Android входит принимающий парсер, работающий аналогично StAX.

Принцип работы принимающего парсера похож на SAX. Он оперирует теми же событиями (начало элемента, конец элемента), однако их необходимо
запрашивать явным образом при помощи метода (parser.next()). События имеют числовые идентификаторы (коды), поэтому для их выбора можно
использовать оператор case-switch. Следует отметить, что вместо отслеживания закрывающих тегов, как в SAX, в случае принимающего парсера
проще обрабатывать содержимое элемента при обнаружении открывающего тега.









