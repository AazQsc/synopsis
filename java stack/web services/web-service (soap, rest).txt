Web service — идентифицируемая веб-адресом программная система со стандартизированными интерфейсами.
В простейшем приближении веб-сервисом можно считать html-страницу, которая отвечает на запрос клиента или servlet.
Но в большей степени это относится к сервис-ориентированной архитектуре (SOA).

Сущности работающие в рамках веб-сервиса:
	заказчик (service requester);
	исполнитель (service provider);
	каталог (service broker).

Альтернативы веб-сервисам:
Меньшая производительность и больший размер сетевого трафика по сравнению с технологиями RMI, CORBA, DCOM (это всё ранние реализации
RPC) за счёт использования текстовых XML-сообщений.
Но вышеперечисленные технологии являются устаревшими (они сложнее в использовании и не предоставляют такого гибкого api как сервисы), 
а ещё они работают через какие-то свои сетевые протоколы вместо простого HTTP.


========================================================================================
========================================================================================
SOAP (от англ. Simple Object Access Protocol — простой протокол доступа к объектам) — веб-сервис основанный на протоколе обмена
структурированными сообщениями. Первоначально SOAP предназначался в основном для реализации RPC  (Remote Procedure Calling – удаленный
вызов процедур). Сейчас протокол используется для обмена произвольными сообщениями в формате XML, а не только для вызова процедур.

SOAP - определяет:
* структуру вызова, 
* правила кодирования, 
* соглашения для представления вызовов и ответов.
	Эти вызовы и ответы передаются как SOAP  сообщения (XML файлы) над HTTP.

--------------------------------
В основе SOAP лежат:
1. XML — основной фундамент, на котором строятся и определяются веб-службы SOAP (SOAP, WSDL и UDDI). 
	 Клент и сервер в soap обмениваются сообщениями с помощью XML-документов.
	 
2. WSDL (Web Services Description Language) — определяет протокол, интерфейс, типы сообщений и взаимодействия между потребителем и 
					      поставщиком.
					      
WSDL использует XML для описания того, что служба делает, как вызвать ее операции и где ее найти.
Т.е. если веб-сервис предоставляет возможность вызова какого-то метода, он должен дать возможность клиентам узнать какие параметры для
данного метода    используются. Если веб-сервис ждет строку для метода Method1 в качестве параметра и строка должна иметь имя Param1, 
то в описании веб-сервиса эти правила будут указаны. На любое сообщение, которое не соответствует правилам, веб-сервис ответит ошибкой.

3. Cобственно SOAP — протокол кодирования сообщения, основанный на технологиях XML определяющих «конверт» для общения вебслужб.

4. Транспортный протокол — HTTP, SMTP, JMS.
+ API --> для джава это JAX-RPC ---> JAR-WS*

* JAX-RPC означает Java™ API для RPC на базе XML, также называется JSR 101. Это спецификация, описывающая API Java и соглашения для компоновки веб-служб и клиентов веб-служб, использующих удаленные вызовы процедур (RPC) и XML.
На данный момент развитие спецификации JAX-RPC привело к появлению JAX-WS (SOAP) и JAX-RS (для REST)

--------------------------------
Некоторые спецификации, связанные с веб-службами SOAP
1. JAX-WS ( Java API for XML Based Web Services ) - определяет набор API и аннотаций, которые позволяют создавать и 
						    использовать веб-службы в Java.
						    SOAP сообщения являются сложными, но JAX-WS API скрывает сложность от разработчика. 
2. Web Services - определяет модель программирования и поведение во время выполнения веб-служб в контейнере Java EE.
3. WS-Metadata - предоставляет аннотации, помогающие определять и развертывать веб-службы.


    client			web-service
JAX-WS Runtime <--- SOAP ---> JAX-WS Runtime 
		     /\
		    WSDL здесь определяет XML формат для описания услуг как множество операций, построенных на сообщениях. 


из схемы: 

	СЕРВЕР
SOAP работает (это протокол, надстройка над HTTP), а программист работает с 'java api for web-service'
На стороне сервера, разработчик указывает веб-сервисные операции, определяя методы в интерфейс, написанный на языке программирования
Java. Разработчик пишет классы которые реализуют эти методы (Конечные точки). В JAX-WS разработчик  не создает и не разбирает SOAP
сообщения. Это делает среда выполнения JAX-WS переводит  к API вызовам и ответам SOAP сообщения.

	КЛИЕНТ
Клиент создает прокси (локальный объект, представляющий сервис) и тогда просто вызывает эти методы на прокси.

--------------------------------

   Начиная с JAVA EE 7 дискриптор развертования не является обязательным, но возможно его использовать вместо аннотированных классов.

   Некоторые аннотации описанные в этих спецификациях.
   Аннотации отображения WSDL — относятся к пакету javax.jws и позволяют изменить преобразование WSDL/Java.
   Аннотации @WebMethod, @WebResult, @WebParam и  @OneWay используются веб-службой для настройки сигнатуры доступных методов
   Аннотации связывания SOAP — относятся к пакету javax.jws.soap и позволяют настроить связывание SOAP (@SoapBinding и
   @SOAPMessageHandler).
   @SoapBinding - можно выбрать стиль:
	RPC — это только для удаленного вызова методов.
	DOCUMENT — тоже позволяет в себя завернуть RPC и что-то ещё...

Интерфейс конечной точки сервиса и реализация конечной точки сервиса(SEI -service endpoint implementation) является Java интерфейсом 
или классом, соответственно, который объявляет методы, которые может вызвать клиент.
Проще - класс работающий с протоколом SOAP называется конечной точкой (SEI)
   Конечные точки бывают: EJB и POJO

   POJO Класс веб-служба должен иметь аннотацию @javax.jws.WebService или XML-эквивалент в дескрипторе развертывания (webservices.xml).
   EJB  Для того чтобы преобразовать веб-службу SOAP в компонент-конечную точку, класс должен иметь аннотацию @javax.ejb.Stateless 
   или @javax.ejb.Singleton

Требования JAX-WS Endpoint
JAX-WS Endpoint должны удовлетворять следующим условиям:
1. Реализующий класс должен иметь аннотацию javax.jws.WebService или javax.jws.WebServiceProvider
2. Реализующий класс может явно ссылаться на SEI через элемент endpointinterface аннотации @WebService, но делать это не обязательно.
   Если endpointinterface в аннотации @WebService не указан, то SEI определен неявно реализацией класса.
3. Методы реализующего класса должны быть публичные и должны быть static или final
4. Методы, предоставляемые клиенту, должны иметь аннотацию javax.jws.WebMethod
5. Методы, предоставляемые клиенту, должны иметь JAX-совместимые параметры и возвращать поддерживаемые типы. 
6. Реализующий класс не может быть final или abstract
7. Реализующий класс должен иметь публичный дефолтовый конструктор без параметров
8. В реализующем классе не дол;но быть finalize метода
9. Реализующий класс может использовать javax.annotation.PostConstruct или javax.annotation.PreDestroy аннотации
@PostConstruct вызывается контейнером до реализации класса веб-сервиса.
@PreDestroy вызывается контейнером до того как endpoint будет удален.

ОБЩИЙ ПОДХОД:
- Описать интерфейс веб-сервиса
- Реализовать этот интерфейс
- Запустить наш веб-сервис
- Написать клиента и удаленно вызвать нужный метод веб-сервиса

Достоинства:
- Программисту на сервере достаточно сказать, что данный метод можно вызывать через веб-сервис, и wsdl-описание будет 
  сгенерировано автоматом.
- Описание, имеющее четкую структуру, читается любым soap-клиентом.
- Автоматическая валидация XML.
- Авторизация и аутентификация может быть реализована отдельным методом. нативно. либо, используя http-авторизацию.
- Веб-сервисы могут работать как по soap-протоколу, так и по http, то есть через get-запросы.

Недостатки:
- Использование SOAP для передачи сообщений увеличивает их объём (соответственно и количество трафика) и снижает скорость обработки, 
  это несколько связано с избыточностью xml. В системах, где скорость важна, чаще используется пересылка XML-документов через HTTP
  напрямую, где параметры запроса передаются как обычные HTTP-параметры.
- Все действия по вызову методов должны быть атомарными. Например, работая с субд мы можем начать транзакцию, выполнить несколько
  запросов, потом откатиться или закоммитить. В soap транзакций нет. Один запрос-один ответ, разговор закончен.

подробнее:
https://ru.stackoverflow.com/questions/257184/%D0%A7%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-soap


========================================================================================
========================================================================================
REST (сокр. от англ. Representational State Transfer — «передача состояния представления») — архитектурный стиль взаимодействия
компонентов распределённого приложения в сети.
REST представляет собой согласованный набор ограничений (принципов), учитываемых при проектировании распределённой гипермедиа-системы. 
В определённых случаях (интернет-магазины, поисковые системы, прочие системы, основанные на данных) это приводит к повышению
производительности и упрощению архитектуры. В широком смысле компоненты в REST взаимодействуют наподобие взаимодействия клиентов и
серверов во Всемирной паутине. REST является альтернативой RPC

В отличие от веб-сервисов (веб-служб) на основе SOAP, не существует «официального» стандарта для RESTful веб-API. 
Дело в том, что REST является архитектурным стилем, в то время как SOAP является протоколом!

Ещё раз. REST - архитектурный стиль.
Технологии со стороны Java описаны в спецификации JAX-RS
реализации JAX-RS:
	Jersey
	CXF (Apache)
	RESTEasy (JBoss)

Системы, в которых придерживаются принципов REST, называются RESTfull-системами.
Принципы REST (Roy Fielding):
	Единый интерфейс (Uniform Interface)
	Отсутствие состояний (Stateless)
	Кеширование ответа (Cacheable)
	Клиент-сервер (Client-Server)
	Многоуровневая система, или иначе - слои  (Layered System)
	"Код по требованию" (Code on Demand - опционально)
подробнее:
http://www.restapitutorial.ru/lessons/whatisrest.html#uniform-interface
https://ru.wikipedia.org/wiki/REST

Каждая единица информации однозначно определяется URL – это значит, что URL по сути является первичным ключом для единицы данных. 
Т.е. например третья книга с книжной полки будет иметь вид /book/3, а 35 страница в этой книге — /book/3/page/35.

Идемпонтентный - большое количество идентичных запросов имеет такой же эффект, как и один запрос.
Идемпотентные методы по определению безопасны так как не меняют состояния клиента. 

Для HTTP действие над данными задается с помощью методов: 
GET (получить) 		и + б
PUT (добавить)		и + нб
POST (изменить)		ни + нб
DELETE (удалить)	и + нб

Вызов удалённой процедуры может представлять собой обычный HTTP-запрос (обычно «GET» или «POST»; такой запрос называют «REST-запрос»), 
а необходимые данные передаются в качестве параметров запроса

Например:
GET /book/ — получить список всех книг
GET /book/3/ — получить книгу номер 3
PUT /book/ — добавить книгу (данные в теле запроса)   или пут и пост наоборот?
POST /book/3 – изменить книгу (данные в теле запроса)
DELETE /book/3 – удалить книгу

По виду пришедшего запроса сразу можно определить, что он делает, не разбираясь в форматах (в отличие от SOAP, XML-RPC). 
Данные передаются без применения дополнительных слоев, поэтому REST считается менее ресурсоемким, поскольку не надо парсить запрос 
чтобы понять, что он должен сделать и не надо переводить данные из одного формата в другой. 

Интересный комментарий (https://habrahabr.ru/post/38730/   кстати! - /post/38730/ - хабр сделан, похоже, с преминением принципов rest!):
"Поясню. REST предполагает, что все есть ресурс. Таким образом, каждый комментарий к этой статье должен иметь свой URL и быть по нему
доступен. И каждый коммент должен подгружаться отдельным запросом. Все как в ООП. Если у вашего объекта «магазин» есть метод
«инвентарь», то инвентарь это тоже объект, и каждый предмет в инвентаре тоже есть объект, и загружается соответственно отдельно. Но с
другой стороны REST на этом не настаивает. Вот жешь блин )))"

_______________________________________________________________________________________________________
Веб-службы в стиле REST — это обычные POJO, имеющие минимум один метод, аннотированный javax.ws.rs.Path

Tребования для написания REST-службы:
- класс должен быть аннотирован с помощью @javax.ws.rs.Path (в JAX-RS 2.0  отсутствует XML-эквивалент метаданных, 
  поскольку нет дескриптора развертывания);
- класс должен быть определен как общедоступный (публичный), при этом не должен быть ни финальным, ни абстрактным;
- классы корневых ресурсов (имеющие аннотацию @Path ) должны иметь действующий по умолчанию общедоступный конструктор. 
  Классы некорневых ресурсов не требуют такого конструктора;
- класс ни в коем случае не должен определять метод finalize();
- для добавления возможностей EJB (... или JAP!) к REST-службе класс должен иметь аннотацию @javax.ejb.Stateless или
  @javax.ejb.Singleton;
- служба должна быть объектом, не имеющим состояния, и не должна сохранять клиентоспецифичное состояние между вызовами методов.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
/**
 * extends Application - заменяет необходимость
 * конфигурации веб-сервисов в файле web.xml
 * О необходимых настройках конфигурации сообщит
 * этот класс родитель. Мы даём знать, что работаем с REST
 * <p>
 * И здесь же нужно указать:
 * ApplicationPath Идентификация базового URL
 * все остальные пути будут содержать его.
 * <p>
 * То есть данный класс является альтернотивой конфигураций rest
 * в web.xml
 */
@ApplicationPath("userscatalog")
public class MyApplication extends Application {
}



Аннотации:
@Path("/") представляет относительный URI и может сопровождать класс или метод. 
Про методы - это может быть полезно для объединения в группы общих функциональностей нескольких ресурсов.

аннотации для получения параметров:
@PathParam
@QueryParam
@MatrixParam 
@CookieParam 
@HeaderParam
@FormParam
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Извлечение параметров пути и регулярных выражений:
@Path("{id}")
public Response deleteBook(@PathParam("id") Long bookId) {}
------
@Path("search/{text}")
public Customers searchCustomers(@PathParam("text") String textToSearch) {
// URI : /customer/search/smith
}
------
@GET
@Path("{login: [a-zA-Z]*}")
public Customer getCustomerByLogin(@PathParam("login") String login) {
// URI : /customer/foobarsmith
}
------
@GET
@Path("{customerId : \\d+}")
public Customer getCustomerById(@PathParam("customerId") Long id) {
// URI : /customer/12345
}
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Извлечение параметров со значением запроса и матрицы:
@GET
public Customers getCustomersByZipCode(
		@QueryParam("zip") Long zip,
		@QueryParam("city") String city
		) {
// URI : /customer?zip=75012&city=Paris
}
------
@GET
@Path("search")
public Customers getCustomersByName(
		@MatrixParam("firstname") String firstname, 
		@MatrixParam("surname") String surname
		) {
// URI : /customer/search;firstname=Antonio;surname=Goncalves
}
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Аннотация @FormParam указывает, что значение параметра должно быть из-
влечено из формы, содержащейся в теле объекта в запросе. Поддержка аннотации
@FormParam у полей и свойств не требуется.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
можно добавить аннотацию @DefaultValue для опреде-
ления значения, которое будет действовать по умолчанию для ожидаемого пара-
метра:
public Customers getCustomersByAge(
		@DefaultValue("50") 
		@QueryParam("age")
		int age
		) {
// ...
}
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Аннотации 
	@javax.ws.rs.Consumes и		получает
	@javax.ws.rs.Produces 		отправляет
могут применяться с таким ресурсом, который способен иметь несколько представлений. 
Здесь определяются медиатипы представления, которыми могут обмениваться клиент и сервер.
В JAX-RS есть класс javax.ws.rs.core.MediaType , действующий в качестве абстракции для MIME-типа.
APPLICATION_ATOM_XML		"application/atom+xml"
APPLICATION_FORM_URLENCODED	"application/x-www-form-urlencoded"
APPLICATION_JSON 		"application/json"
APPLICATION_OCTET_STREAM 	"application/octet-stream"
APPLICATION_SVG_XML 		"application/svg+xml"
APPLICATION_XHTML_XML 		"application/xhtml+xml"
APPLICATION_XML 		"application/xml"
MULTIPART_FORM_DATA 		"multipart/form-data"
TEXT_HTML 			"text/html"
TEXT_PLAIN 			"text/plain"
TEXT_XML 			"text/xml"
WILDCARD 			"*/*"		- значение по-умолчанию (поддержка любого медиатипа)
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Возвращаемые значения:
	примитивные типы + строка:
@GET
@Path("maxbonus")
   public Long getMaximumBonusAllowed() {
   return 1234L;
}
	JAXB:
@GET
@Produces(MediaType.APPLICATION_XML)
   public Customer getAsXML() {
   return new Customer("Джон", "Смит", "jsmith@gmail.com", "12 34565");
}
	Response:
@GET
@Produces(MediaType.APPLICATION_JSON)
public Response getAsJson() {
   return Response.ok(new Customer("Джон", "Смит", "jsmith@gmail.com", "12 34565"), MediaType.APPLICATION_JSON).build();
}
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
В JAX-RS предоставляется объект javax.ws.rs.core.UriBuilder , призванный заменить java.net.URI и упростить безопасное построение URI.
    UriBuilder.fromUri("http://www.myserver.com").path("book").path("1234").build();

Создание контекстной информации:
    Аннотация @javax.ws.rs.co­re.Con­text предназначена для внедрения в атрибут или параметр метода следующих классов:
	HttpHeaders 
	UriInfo
	Request
	SecurityContext
	Providers
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
В JAX-RS 2.0 отсутствует дескриптор развертывания.



















