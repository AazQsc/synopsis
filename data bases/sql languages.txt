> select * from v$version 	// версия оракл
> mysql -u root -p		//  подключение к MySQL-серверу
> USE name;			// cмена базы
> SHOW databases;		// смотрим какие базы есть

$ mysqldump -u root -p name > mydbscheme_dump.sql		// сделать дамп БД
$ mysqldump -u root -p name < mydump.sql			// загрузить БД из дампа

> SET AUTOCOMMIT=0						// отключит автокоммит
> SHOW table status;						// инфа о таблицах в БД
> SHOW COLUMNS FROM имя_таблицы; == DESCRIBE имя_таблицы; 	// информация о столбцах таблицы
> SHOW INDEX FROM имя_таблицы;
					// посмотреть только view / table
> SHOW FULL TABLES WHERE TABLE_TYPE LIKE 'VIEW';
> SHOW FULL TABLES WHERE TABLE_TYPE LIKE 'BASE TABLE';
> SHOW CREATE TABLE имя_таблицы;	// получения выражения CREATE TABLE, которое было написано, для создания выбранной таблицы
+ 
>INSERT INTO имя_таблицы SELECT * FROM имя_таблицы;
= копия таблицы

При добавлении к запросу '\G' данные будут выведены горизонтально
> SELECT * FROM имя_таблицы;
> SELECT * FROM имя_таблицы\G;
----------------------------------------------------------------------
Выражения для управления схемой бд ---> schema statements
Выражения для управления данными бд ---> data statements


Structured Query Language (SQL)
 DDL - definition
    		CREATE 	// CREATE DATABASE name;
    		ALTER 	// редактирование данных: ALTER TABLE имя_таблицы DROP COLUMN имя_колонки;
		DROP
 DML - manipulation
		INSERT
		UPDATE
		DELETE
		MERGE
 DQL - query
		SELECT
 DCL - control
		GRANT
		DENY
		REVOKE
 TCL - transaction
		COMMIT
		ROLLBACK
		SAVEPOINT
		SET

		--------
		SELECT DISTINCT	уникальные поля
		EXPLAIN - поставь перед SELECT чтобы узнать подробности запроса (план запроса)
		WHERE условие-1 AND условие-2
		WHERE условие-1 OR условие-2
		WHERE  имя_колонки BETWEEN значение-1 AND значение-2;
		WHERE  имя_колонки IN (значение-1, значение-2);
		WHERE имя_колонки LIKE шаблон
		сортировки
		ORDER BY имя_колонки ASC - прямой порядок
		ORDER BY имя_колонки DESC - обратный порядок
		
		LIMIT 0,3 - количество записей (1, 2, 3)
		UNION - см. join'ы - служит для комбинирования результатов двух и более SQL запросов без возвращения повторющихся данных
		UNION ALL - тоже но плюс повторы

		GROUP BY - группировать после выполнения функции
		HAVING - аналог WHERE для групп // может работать как WHERE

 HAVING aggregate_function(column_name) operator value;

 SELECT Singer, SUM(Sale) AS AllSales
 FROM Artists
 GROUP BY Singer

 SELECT колонка1, колонка2, ... колонкаN
 FROM имя_таблицы
 WHERE [ условие ]
 GROUP BY колонка1, колонка2, ... колонкаN
 ORDER BY колонка1, колонка2, ... колонкаN
		
		COUNT() - функция, возвращает кол-во по условию
		SELECT COUNT(1) FROM name;
		EXISTS - проверяет существование объекта в подзапросе родительского запроса.

 ORDER BY RIGHT(fed_id, 3);	- сортировать по последним трем символам поля fed_id
 ORDER BY 2, 5;			- сортировать по второму и пятому столбцах
		
 +++++++++++++++++++++++++++++++++++ Примеры выражений: +++++++++++++++++++++++++++++++++++++
 ___ Создание таблицы ___
CREATE TABLE имя_таблицы(
 колонка1 тип_данных, 
 колонка2 тип_данных,
 колонка3 тип_данных,
 ...
 PRIMARY KEY( одни или несколько колонок )
 );

 CREATE TABLE developers(
   ID   INT               NOT NULL AUTO_INCREMENT,
   NAME VARCHAR (100)     NOT NULL,
   SPECIALTY VARCHAR(100) NOT NULL,
   EXPERIENCE  INT        NOT NULL,
   SALARY   INT,       
   PRIMARY KEY (ID)
 );

 ___ добавить столбец  ___
 ATLER TABLE Artists ADD Producer varchar(20);

 ___ Переименовать таблицу ___
 ALTER TABLE имя_таблицы RENAME TO новое_имя_таблицы;

 ___ Переименовать столбец ___ (придется его заменить на новый!)
 ALTER TABLE name_of_table CHANGE old_column_name new_column_name VARCHAR(128);

 ___ Удаление констрейнта ___
 ALTER TABLE имя_таблицы DROP CONSTRAINT someConstraint;

 ___ Очистить таблицу ___
 TRUNCATE TABLE имя_таблицы;

 ___ Вставить значения ___
 INSERT INTO имя_таблицы (колонка1, колонка2 ...)
 VALUES ( значение1, значение2 ...);

 INSERT INTO developers (ID, NAME, SPECIALTY, EXPERIENCE, SALARY)
 VALUES (1, 'Eugene Suleimanov', 'Java', 2, 2000);

 INSERT INTO developers 
 VALUES (6, 'Ludmila Geiko', 'UI/UX', 2, 1800);

 ___ Обновить данные ___
 UPDATE table_name
 SET колонка1 = значение1, колонка2 = значение2 ...
 [ WHERE условие ];

 UPDATE developers 
 SET SALARY = 2500 
 WHERE NAME LIKE 'Eugene Suleimanov';

 UPDATE developers 
 SET EXPERIENCE = 3, SALARY = 2500 
 WHERE NAME LIKE 'Andrei Komarov';

 ___ Удалить данные ___
 DELETE FROM <Имя Таблицы> WHERE <Условие отбора записей>

 ___ получить первые N записей ___
 SELECT колонка1, колонка2 ... колонкаN
 FROM имя_таблицы
 LIMIT число_записей;

 ___ слияние данных ___
 SELECT колонка1, колонка2 ... колонкаN
 FROM имя_таблицы1, имя_таблицы2
 WHERE имя_таблицы.ID = имя_таблицы.ID;

 ___ подзапрос ___
 SELECT имя_колонки
 FROM   таблица1
 WHERE  имя_колонки ОПЕРАТОР
       (SELECT имя_колонки
       FROM таблица1
       WHERE ...)

 
 

----------------------------------------------------------------------
ТИПЫ ДАННЫХ(здесь не все):

целочисленные			int, money
числа с плавающией точкой	float, real
время и дата			datetime, date, time
символы				varchar, text
символы Unicode			nvarchar, ntext
бинарные			image, binary

другие	
	1. sql_variant	Хранит значения различных типов данных, поддерживаемых сервером SQL, за исключением, text, ntext и timestamp.
	2. timestamp	Хранит уникальное для базы данных значение, которое обновляется при каждом изменении записи.
	3. uniqueidentifier	Хранит глобальный уникальный идентификатор (GUID)
	4. xml	Хранит XML данные. Мы можем хранить экземпляр xml в колонке, либо в переменной ( Только для SQL Server 2005).
	5. cursor	Хранит ссылку на курсор.
	6. table Хранит результирующее множество для крайней обработки.
----------------------------------------------------------------------
ОГРАНИЧЕНИЯ
		Constraints:
1. NOT NULL	Гарантирует, что данная колонка не может иметь значение NULL.
2. DEFAULT	Обеспечивает значение по умолчанию для колонки, в случае, если данные не указаны.
3. UNIQUE	Гарантирует, что все занчения в данной колонке уникальны.

	CREATE TABLE Persons (
	    ID int NOT NULL UNIQUE,
	    FirstName varchar(255),
	    Age int
	);

4. PRIMARY KEY	Уникальный идентификатор каждой записи в таблице БД.
5. FOREIGN KEY	Уникальный идентификатор записи в другой таблице БД.
6. CHECK	Гарантирует, что все занчения в колонке соответствуют определённому условию.
7. INDEX	Используется для быстрого получения данных из БД.

		Integrity:
1. Entity	В таблице нет повторяющихся данных.
2. Domain	Использует валидные вводы для указанной колонки путём ограничения типа,
 		формата или диапазона значений.
3. Referential	Записи, которые используются другими записями, не могут быть удалены.
+
Определённая	
пользователем
+++ другие +++
IDENTITY (seed,increment) Создание столбца идентификаторов в таблице. Это свойство используется с инструкциями CREATE TABLE 
и ALTER TABLE

seed - Значение, используемое в первой строке, которая загружается в таблицу.
increment - Приращение, добавляемое к значению идентификатора предыдущей загруженной строки

----------------------------------------------------------------------
ХРАНИМЫЕ ПРОЦЕДУРЫ
1.Хранимая процедура представляет собой набор команд SQL, которые могут компилироваться и храниться на сервере.
2.Хранимая процедура MySQL представляет собой подпрограмму, хранящуюся в базе данных. 
  Она содержит имя, список параметров и операторы SQL.
3.Хранимая процедура - это способ инкапсуляции повторяющихся действий.

+++  CИНТАКСИС	+++
CREATE [DEFINER = { user | CURRENT_USER }]          
PROCEDURE имя_процедуры ([параметры_процедуры[,...]])          
[характеристики ...] тело_подпрограммы

+++++++++++++++++++
CREATE PROCEDURE `myProc` () 		// № характеристики хранимой процедуры:
LANGUAGE SQL				// 1. Language: в целях обеспечения переносимости, по умолчанию указан SQL.
DETERMINISTIC 				// 2. Deterministic: Значение по умолчанию - NOT DETERMINISTIC.
SQL SECURITY DEFINER 			// 3. SQL Security: права INVOKER - пользователь, вызывающий хранимую процедуру. DEFINER - это 
					// “создатель” процедуры. Значение по умолчанию - DEFINER.
COMMENT 'A procedure' 			// 4. Comment: в целях документирования, значение по умолчанию - ""
BEGIN
    SELECT 'Hello World !'; 
END $$

+++++++++++++++++++
сменить разделитель
		DELIMITER $$ ;				
		DELIMITER ; $$

+++++++++++++++++++
Вызов хранимой процедуры
		CALL имя_процедуры();			

+++++++++++++++++++ 
структура процедуры
		SHOW CREATE PROCEDURE имя_процедуры;

+++++++++++++++++++
параметры
CREATE PROCEDURE proc1 (): 				// пустой список параметров
							
CREATE PROCEDURE `proc_IN` (IN var1 INT) 		// IN входящий параметр. это параметр по умолчанию - IN (входящие).
BEGIN
  SELECT var1 + 2 AS result; 
END $$

CREATE PROCEDURE `proc_OUT` (OUT var1 VARCHAR(100)) 	// OUT возвращаемый параметр.
BEGIN 							// проверить:
  SET var1 = 'This is a test'; 				// 	CALL proc_OUT(@var1);
END $$							// 	SELECT @var1;
	
CREATE PROCEDURE `proc_INOUT` (INOUT var1 INT) 		// INOUT одновременно входящий и возвращаемый. 
BEGIN 
  SET var1 = var1 * 2; 
END $$

+++++++++++++++++++
переменные
Вы должны объявлять их явно в начале блока BEGIN/END, вместе с их типами данных.
синтаксис объявления: DECLARE varname DATA-TYPE DEFAULT defaultvalue; 

пример:
CREATE PROCEDURE `var_proc` (IN paramstr VARCHAR(20)) 
BEGIN 
    DECLARE a, b INT DEFAULT 5; 
    DECLARE str VARCHAR(50); 
    DECLARE today TIMESTAMP DEFAULT CURRENT_DATE; 
    DECLARE v1, v2, v3 TINYINT; 
    
    INSERT INTO table1 VALUES (a); 
    SET str = 'I am a string'; 
    SELECT CONCAT(str,paramstr), today FROM table2 WHERE b >=5; 
END

+++++++++++++++++++
Структуры управления потоками
MySQL поддерживает конструкции IF, CASE, ITERATE, LEAVE LOOP, WHILE и REPEAT для управления потоками в пределах хранимой процедуры
- - - - - - - - - -
IF param1 = 0 THEN 
        SELECT 'Parameter value = 0'; 
ELSE 
        SELECT 'Parameter value <> 0'; 
END IF;
- - - - - - - - - -
CASE variable1 
WHEN 0 THEN 
        INSERT INTO table1 VALUES (param1); 

WHEN 1 THEN 
        INSERT INTO table1 VALUES (variable1); 
ELSE 
        INSERT INTO table1 VALUES (99); 
END CASE; 
- - - - - - - - - -
WHILE variable1 < param1 DO 
	INSERT INTO table1 VALUES (param1); 
        SELECT COUNT(*) INTO variable2 FROM table1; 
        SET variable1 = variable1 + 1; 
END WHILE;

+++++++++++++++++++


+++++++++++++++++++
+++++++++++++++++++
+++ ----------- +++


Хранимые процедуры требуют наличия таблицы proc в базе mysql.
----------------------------------------------------------------------
КУРСОРЫ - это объект бд который позволяет организовать сложную обработку данных на стороне сервера строка за строкой. 

1. Курсоры объявляются в начале хранимой процедуры до выполнения каких либо операций.
//пара переменных для последующей выборки данных курсора
DECLARE a, b INT;
//объявляем курсор, выбирающий пары значений из некой тестовой таблицы
DECLARE cur1 CURSOR FOR 
SELECT value_a, value_b FROM test.t1;

2. Перед выборкой строк из курсора его нужно инициализировать (выполняется запрос)
OPEN cur1;

3. Далее вы можете выбирать данные из курсора, строка за строкой.
//помещаем следующую пару значений в переменные a и b
FETCH cur1 INTO a, b;
//выполняем какие то манипуляции с данными
IF a < b THEN
   ...
ELSE
   ...
END IF;

4. Завершение работы с курсором
CLOSE cur1;

5. Нам нужен сигнал об окончании данных в курсоре. В MySQL для этого используют обработку исключительных ситуаций — конструкцию
DECLARE .. HANDLER FOR ... { }

+++ Пример +++
// объявим дополнительно переменную-флажок
// этот флаг будет хранить сигнал об окончании данных в курсоре
DECLARE done INT DEFAULT FALSE;
DECLARE a, b INT;
DECLARE cur1 CURSOR FOR SELECT id,data FROM test.t1;
//описываем как действовать во время исключения
DECLARE CONTINUE HANDLER FOR NOT FOUND 
//а именно : установим флаг
SET done = TRUE;
//если нужно выполнить несколько команд - используйте операторные скобки
//BEGIN ... END;
//инициализация
OPEN cur1;
//цикл чтения курсора
read_loop: LOOP
    FETCH cur1 INTO a, b;
    //проверка флага
    IF done THEN
        LEAVE read_loop;
    END IF;
    //обработка данных
    ...
END LOOP;
//завершаем работу с курсором
CLOSE cur1;

----------------------------------------------------------------------
ТРИГЕРЫ
Триггер объект БД который представляет собой хранимую процедуру, которая активизируется при наступлении определенного события.

Синтаксис создания триггера

CREATE
[DEFINER = { имя_ пользователя | CURRENT_USER }]
TRIGGER имя_триггера время_триггера событие_срабатывания_триггера
ON имя_таблицы FOR EACH ROW выражение_выполняемое_при_срабатывании_триггера

время_триггера - определяет время свершения действия триггера:
- BEFORE означает, что триггер выполнится до завершения события срабатывания триггера, а
- AFTER означает, что после.

событие_срабатывания_триггера - при каком событии выполняется триггер.
- INSERT: т.е. при операциях вставки или аналогичных ей выражениях (INSERT, LOAD DATA, и REPLACE)
- UPDATE: когда сущность (строка) модифицирована
- DELETE: когда запись удаляется (запросы, содержащие выражения DELETE и/или REPLACE)

CREATE TRIGGER myTrigger BEFORE INSERT ON `table1`
FOR EACH ROW
BEGIN
  INSERT INTO `LogsName` (`ValueCh`, `DateChange`) VALUES (NEW.`FirstName`,  NOW()) ;
END

----------------------------------------------------------------------
ФУНКЦИИ
это хранимая процедура имеющее возвращаемое значение

1 - Функции потока управления программой: ifnull, if
2 - Строковые функции: concat, lenght
3 - Математические функции: sqrt
4 - Функции даты и времени: now
5 - Функции приведения типов: cast
6 - Агрегатные функции - это функции возвращающие одно значение от набора значений столбца (sum, max, min, count) GROUP BY
7 - Битовые функции: bit_count
8 - : PASSWORD(str), ENCODE(str,pass_str) + DECODE(crypt_str,pass_str), GET_LOCK(str,timeout) + RELEASE_LOCK(str), FOUND_ROWS()


CREATE FUNCTION func() RETURNS INTEGER
BEGIN
	DECLARE val INTEGER;
	SELECT id INTO val FROM table;
	RETURN IFNULL(val, 0);
END $$

----------------------------------------------------------------------
Виды объединений (JOIN)

1. INNER JOIN: возвращает записи, когда имеются совпадения в обоих таблицах (0(1)0)
	SELECT *
	FROM Authors INNER JOIN Books
	ON Authors.AuthorID = Books.BookID

2. FULL JOIN: возвращает записи, когда есть совпадение, хотя бы в одной из таблиц.
	SELECT column_names [,... n]
	FROM Table_1 FULL JOIN Table_2
	ON condition

3. FULL OUTER JOIN		
	SELECT *
	FROM `t1`
	LEFT OUTER JOIN `t2` ON `t1`.`id` = `t2`.`id`

	UNION

	SELECT *
	FROM `t1`
	RIGHT OUTER JOIN `t2` ON `t1`.`id` = `t2`.`id`
	WHERE `t1`.`id` IS NULL;

4. LEFT JOIN: возвращает записи из левой таблицы даже если нет совпадений в правой. (1(1)NULL)
	SELECTcolumn_names [,... n]
	FROM Table_1 LEFT JOIN Table_2
	ON condition

5. RIGHT JOIN: возвращает все записи из правой таблицы, даже если нет совпадений в левой. (NULL(1)1)
	SELECTcolumn_names [,... n]
	FROM Table_1 RIGHT JOIN Table_2
	ON condition

6. LEFT JOIN EXCLUDING INNER JOIN, 

7. RIGHT JOIN EXCLUDING INNER JOIN,


8. SELF JOIN: используется для объединения таблицы с ней самой, таким образом, как будто первая таблица является и второй, 
	      временно переименовывая хотя бы одну из таблиц в SQL запросе.
	SELECT a.имя_колонки, b.имя_колонки...
	FROM таблица1 a, таблица1 b
	WHERE a.общее поле = b.общее поле;
	
	SELECT a.name, b.name
	FROM friends a, friends b;

9. CROSS JOIN: 		--- > даёт нам Декартово произведение = все возможные перестановки
	SELECT *
	FROM Authors CROSS JOIN Books

Type — указывает на то, как MySQL связывает используемые таблицы. Это одно из наиболее полезных полей в выводе потому, 
что может сообщать об отсутствующих индексах или почему написанный запрос должен быть пересмотрен и переписан. 
Возможные значения:

System – таблица имеет только одну строку
Const – таблица имеет только одну соответствующую строку, которая проиндексирована. Это наиболее быстрый тип соединения потому, 
	что таблица читается только один раз и значение строки может восприниматься при дальнейших соединениях как константа.
Eq_ref – все части индекса используются для связывания. Используемые индексы: PRIMARY KEY или UNIQUE NOT NULL. 
	Это еще один наилучший возможный тип связывания.
Ref – все соответствующие строки индексного столбца считываются для каждой комбинации строк из предыдущей таблицы. 
	Этот тип соединения для индексированных столбцов выглядит как использование операторов = или < = >
Fulltext – соединение использует полнотекстовый индекс таблицы
Ref_or_null – то же самое, что и ref, но также содержит строки со значением null для столбца
Index_merge – соединение использует список индексов для получения результирующего набора. Столбец key вывода команды EXPLAIN будет
	содержать список использованных индексов.
Unique_subquery – подзапрос IN возвращает только один результат из таблицы и использует первичный ключ.
Index_subquery – тоже, что и предыдущий, но возвращает более одного результата.
Range – индекс, использованный для нахождения соответствующей строки в определенном диапазоне, обычно, когда ключевой столбец
	сравнивается с константой, используя операторы вроде: BETWEEN, IN, >, >=, etc.
Index – сканируется все дерево индексов для нахождения соответствующих строк.
All – Для нахождения соответствующих строк используются сканирование всей таблицы. 
	Это наихудший тип соединения и обычно указывает на отсутствие подходящих индексов в таблице.

----------------------------------------------------------------------
ИНДЕКСЫ

Индекс помогает ускорить запросы на получение данных (SELECT [WHERE]),
 но замедляет процесс добавления и изменения записей (INSERT, UPDATE).

Индексы создаются для столбцов таблиц и представлений.
Первичный ключ (Primary Key) — это особый тип индекса, который является идентификатором записей в таблице.

Количество возможных перестановок столбцов определяет количество индексов

___ Создать ___
CREATE INDEX имя_индекса ON имя_таблицы;

CREATE INDEX имя_индекса ON имя_таблицы (имя_колонки);

CREATE INDEX имя_индекса ON имя_таблицы (колонка1, колонка2);

___ Удалить ___
DROP INDEX имя_индекса;

----------------------------------------------------------------------
KEY

Оператор SQL PRIMARY KEY (Первичный ключ) — это параметр, который устанавливается для однозначной идентификации той или 
					    иной записи в таблице.
Значения SQL PRIMARY KEY должны быть всегда уникальны, а так же не содержать значений NULL.

Оператор SQL FOREIGN KEY (Внешний ключ) служит для указания в одной таблице на Первичный ключ (оператор SQL PRIMARY KEY) в другой.
- это прежде всего защита целостности

ON UPDATE / ON DELETE
CASCADE: если связанная запись родительской таблицы обновлена или удалена, и мы хотим чтобы соответствующие записи в таблицах-потомках
	также были обновлены или удалены. Что происходит с записью в родительской таблице, тоже самое произойдет 
	с записью в дочерних таблицах. Однако не забывайте, что здесь можно легко попасться в ловушку бесконечного цикла.
SET NULL: если запись в родительской таблице обновлена или удалена, а мы хоти чтобы в дочерней таблице некоторым занчениям 
	  было присвоено
NULL (конечно если поле таблицы это позволяет)
NO ACTION: смотри RESTRICT
RESTRICT: если связанные записи родительской таблицы обновляются или удаляются со значениями которые уже/еще содержатся
	  в соответствующих записях дочерней таблицы, то база данных не позволит изменять записи в родительской таблице. 
	  Обе команды NO ACTION и RESTRICT эквивалентны отсутствию подвыражений ON UPDATE or ON DELETE для внешних ключей.
SET DEFAULT: На данный момент эта команда распознается парсером, но движок InnoDB никак на нее не реагирует.

CREATE TABLE invoice (
        id  INT AUTO_INCREMENT NOT NULL,			// AUTO_INCREMENT сам выставляет значения 1,2,3 ... n
        usr_id  INT NOT NULL,
        prod_id  INT NOT NULL,
        quantity INT NOT NULL,
        PRIMARY KEY(inv_id),
        FOREIGN KEY (usr_id) REFERENCES usr(usr_id)
          ON UPDATE CASCADE
          ON DELETE RESTRICT,
        FOREIGN KEY (prod_id) REFERENCES product(prod_id)
          ON UPDATE CASCADE
          ON DELETE RESTRICT
      ) ENGINE=InnoDB CHARACTER SET=UTF8;


----------------------------------------------------------------------
ДВИЖКИ mysql (некоторые)

MyISAM
	работа в кластере: нет ?
	Советы:
	-говорят, что MyISAM таблицы обязательно «ломаются» рано или поздно, так что будте готовы ;)
	-не убивайте сервер во время записи
	-не изменяйте таблицы несколькими серверами одновременно
	-не изменяйте таблицы утилитой и сервером одновременно
	Рекомендации:
	-справочники ?
InnoDB
	индексы кластеризуются для «типичных запросов»
	Советы:
	-SELECT (*) FROM table работает гораздо медленнее, чем MyISAM — создавайте триггеры если нужно
	-бэкап простым копирование файлов невозможен
	-mysqldump работает медленно, для бэкапа используйте InnodDb Hot Backup
	-следите за индексами, выгода InnoDB теряется, если для запросов нет индексов
	Рекомендации: 
	- высоконагруженные сайты, финансовые транзакции

Maria — «улучшенный MyISAM»

Falcon — «улучшенный InnoDb», улучшенная производительность, для Web серверов

----------------------------------------------------------------------
VIEW (именованые SQL запросы)

Представление (VIEW) — объект базы данных, являющийся результатом выполнения запроса к базе данных, 
определенного с помощью оператора SELECT, в момент обращения к представлению.
	Виды позволяют нам:
	-Структурировать данные наиболее удобным способом.
	-Ограничить доступ к данным, которые может видеть пользователь.
	-Собирать данные из нескольких таблиц, которые могут быть использованы для генерирования отчётов.

 ___ Cоздания view ___
 CREATE VIEW имя_вида AS
 SELECT колонка1, колонка2.....
 FROM имя_таблицы
 WHERE [условие];

 ___ использовать view ___
 SELECT * FROM имя_вида;

 Определение view подчиненно следующим ограничениям:
	-Инструкция SELECT не может содержать подзапрос в предложении FROM.
	-Инструкция SELECT не может обратиться к переменным пользователя или системы.
	-Инструкция SELECT не может обратиться к подготовленным операторным параметрам.
	-Внутри сохраненной подпрограммы, определение не может обратиться к стандартным параметрам или локальным переменным.
	-Любая таблица или view, упоминаемый в определении, должны существовать. Однако, после того, как view был создан, можно удалить
	 таблицу или view, к которому определение обращается. В этом случае, использование view приводит к ошибке. Чтобы проверить 
	 определение view для выявления проблем этого вида, используйте инструкцию CHECK TABLE.
	-Определение не может обратиться к таблице типа TEMPORARY, и Вы не можете создавать TEMPORARY view.
	-Таблицы, поименованные в определении view, должны уже существовать.
	-Вы не можете связывать триггер с view.

Оператор CREATE VIEW содержит 4 необязательные конструкции:
1. OR REPLACE — при использовании данной конструкции в случае существования представления с таким именем старое будет удалено, а новое
создано. В противном случае возникнет ошибка, информирующая о сществовании представления с таким именем и новое представление создано не
будет. Следует отметить одну особенность — имена таблиц и представлений в рамках одной базы данных должны быть уникальны, т.е. нельзя
создать представление с именем уже существующей таблицы. Однако конструкция OR REPLACE действует только на представления и замещать
таблицу не будет.

2. ALGORITM — определяет алгоритм, используемый при обращении к представлению.
	алгоритмы: MERGE, TEMPTABLE и UNDEFIND(по-умолчанию).

3. column_list — задает имена полей представления (в скобках).
	CREATE VIEW v (a_id, b_id) AS SELECT a.id, b.id FROM a,b;

4. WITH CHECK OPTION — при использовании данной конструкции все добавляемые или изменяемые строки будут проверяться на соответствие
определению представления. В случае несоответствия данное изменение не будет выполнено. Обратите внимание, что при указании данной
конструкции для необновляемого представления возникнет ошибка и представление не будет создано. (подробнее речь об этом пойдет ниже).
	CREATE VIEW developers_view_with_check_option AS 
	SELECT NAME, SPECIALTY 
	FROM developers 
	WHERE SPECIALTY IS NOT NULL 
	WITH CHECK OPTION;

 с view можно работать как с обыкновенной таблицей (crud), но есть некоторые ограничения.

----------------------------------------------------------------------
ТРАНЗАКЦИЯ - минимальная логически осмысленная операция, которая имеет смысл и может быть выполнена или отменена только целиком. 

требования к выполнению транзакций:
ACID – 
	Atomicity	Атомарность	любая транзакция должна быть зафиксирована только целиком. Если нет, - rollback. 
	Consistency	Согласованность любые изменения должны быть согласованы со всеми ограничениями на уровне БД и таблиц
	Isolation, 	Изолированность результат выполнения тр-ции не должен зависить от выполнения других параллельных тр-ций
	Durability 	Долговечность	при подтверждении тр-ции, изменения, вызванные этой тр-цией не должны быть отменены из-за 
					сбоя системы

Для управления транзакциями используются следующие команды:
	SET autocommit=0;	// отключить автотранзакции

	BEGIN - начать транзакцию
	COMMIT - Сохраняет изменения
	ROLLBACK - Откатывает (отменяет) изменения
	SAVEPOINT - Создаёт точку к которой группа транзакций может откатиться
			SAVEPOINT SP1;
			RELEASE SAVEPOINT SP1;
	SET TRANSACTION - Размещает имя транзакции.
			SET TRANSACTION READ ONLY;
			SET TRANSACTION READ WRITE;



Проблемы доступа с использованием тразакций:
1. потерянное обновление — при одновременном изменении одного блока данных разными транзакциями одно из изменений теряется;
2. «грязное» чтение — чтение данных, добавленных или изменённых транзакцией, которая впоследствии не подтвердится (откатится);
3. неповторяющееся чтение — при повторном чтении в рамках одной транзакции ранее прочитанные данные оказываются изменёнными;
4. фантомное чтение — одна транзакция в ходе своего выполнения несколько раз выбирает множество строк по одним и тем же критериям.
Другая транзакция в интервалах между этими выборками добавляет или удаляет строки или изменяет столбцы некоторых строк, используемых в
критериях выборки первой транзакции, и успешно заканчивается. В результате получится, что одни и те же выборки в первой транзакции дают
разные множества строк.

Уровни изолированности транзакций.
От самымого слабого к самому сильному, каждый последующий включает в себя все предыдущие:
	- Read uncommitted (чтение незафиксированных данных)
	- Read committed (чтение фиксированных данных)
	- Repeatable read (повторяемость чтения)		Этот уровень используется по умолчанию в MySQL
	- Serializable (упорядочиваемость)

Можно изменить уровень изоляции для отдельно взятой сессии или нового соединения таким образом:
			SET [SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL
					       {READ UNCOMMITTED | READ COMMITTED
						| REPEATABLE READ | SERIALIZABLE}

Уровень изоляции	Фантомное чтение	Неповторяющееся чтение	«Грязное» чтение	Потерянное обновление
SERIALIZABLE		+			+			+			+
REPEATABLE READ		-			+			+			+
READ COMMITTED		-			-			+			+
READ UNCOMMITTED	-			-			-			+


----------------------------------------------------------------------
TEMPORARY (ВРЕМЕННЫЕ) ТАБЛИЦЫ - будут удалены по завершению сессии

	CREATE TEMPORARY TABLE имя_таблицы (
          имя_поля VARCHAR (100) NOT NULL, 
          имя_поля INT NOT NULL, 
          имя_поля INT NOT NULL DEFAULT 1
        );

----------------------------------------------------------------------
В MySQL придется рекурсию организовывать внешними по отношению к СУБД средствами ищи «MySQL tree»
Впрочем, есть иной подход , заключающийся в создании левой и правой границы для каждого узла, предложенный Джо Селко. Тогда можно будет обойтись обычными, не рекурсивными запросами.

----------------------------------------------------------------------
ВЛОЖЕННЫЕ ЗАПРОСЫ

правила:
-Вложенный запрос должен быть заключён в родительский запрос.
-Вложенный запрос может содержать только одну колонку в операторе SELECT.
-Оператор ORDER BY не может быть использован во вложенном запросе. Для обеспечения функционала ORDER BY, 
 во вложенном запросе может быть -использован GROUP BY.
-Вложенные запросы, возвращающие более одной записи могут использоваться с операторами нескольких значений, как оператор IN.
-Вложенный запрос не может заканчиваться в функции.
-SELECT не может включать никаких ссылок на значения BLOB, ARRAY, CLOB и NCLOB.
-Оператор BETWEEN не может быть использован вместе с вложенным запросом.


SELECT  * FROM developers 
          WHERE ID IN (SELECT ID 
                       FROM developers 
                       WHERE SALARY > 2000);

----------------------------------------------------------------------
SEQUENCES
	AUTO_INCREMENT			// по умолчанию равен 0
	AUTO_INCREMENT = 100;
----------------------------------------------------------------------
ПЛАН ЗАПРОСА

	EXPLAIN				// посмотреть план запроса
	EXPLAIN SELECT * FROM t_name;
	EXPLAIN SELECT * FROM t_name\G;

самое интересное в плане запроса:
1. Type — указывает на то, как MySQL связывает используемые таблицы. Может сообщать об отсутствующих индексах или почему 
   написанный запрос должен быть пересмотрен и переписан 
	некоторые значения type:
	Const – таблица имеет только одну соответствующую строку, которая проиндексирована. Это наиболее быстрый тип соединения, 
	        таблица читается только один раз и значение строки может восприниматься при дальнейших соединениях как константа.
	Eq_ref – все части индекса используются для связывания. Используемые индексы: PRIMARY KEY или UNIQUE NOT NULL. 
	         Отличный тип связывания.
	All – используются сканирование всей таблицы, это наихудший тип соединения, указывает на отсутствие подходящих индексов 
	      в таблице.
2. Possible_keys – показывает индексы, которые могут быть использованы для нахождения строк в таблице. Значение NULL указывает на то,
  		   что не найдено ни одного подходящего индекса (можно оптимизировать).
3. Rows – отображает число записей, обработанных для получения выходных данных.

После EXPLAIN в запросе вы можете использовать ключевое слово EXTENDED и MySQL покажет вам дополнительную информацию о том, 
как выполняется запрос. Чтобы увидеть эту информацию, вам нужно сразу после запроса с EXTENDED выполнить запрос SHOW WARNINGS.
	EXPLAIN EXTENDED SELECT * FROM t_name;

помни что запросы можно логировать
----------------------------------------------------------------------
----------------------------------------------------------------------



+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+++++++++++++++++++					      +++++++++++++++++++
+++++++++++++++++++   ИЗУЧАЕМ SQL C O'REILLY И АЛАНОМ БЬЮЛИ   +++++++++++++++++++
+++++++++++++++++++ 					      +++++++++++++++++++
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

База данных — представленная в объективной форме совокупность самостоятельных материалов, систематизированных таким образом, 
чтобы эти материалы могли быть найдены и обработаны с помощью электронной вычислительной машины (ЭВМ)

База данных – это всего лишь набор взаимосвязанных данных.

Типы бд:
1. hierarchical database system --- single parent hierarchy
2. network database system --- multiparent hierarchy ---> связи (links) + отношения (relationships)
3. Relational database system

Процесс улучшения структуры базы данных с целью обеспечения хранения всех независимых элементов данных только 
в одном месте (за исключением внешних ключей) называют нормализацией (normalization).

Результирующий набор (result set) - другое название непостоянной таблицы, обычно являющейся результатом SQL-запроса.

Порядок мысли:
3 SELECT /* одна или более сущностей */			что вернёт?	
1 FROM   /* одно или более мест */			откуда.
2 WHERE  /* удовлетворяется одно или более условий */	ограничения.

1175 ---> error safe-updates option set
	SET SQL_SAFE_UPDATES = 0;
	Or you can modify your query to follow the rule (use primary key in where clause).


CHAR(20)	/* строка фиксированной длины */ 	255 символов
VARCHAR(20) 	/* строка переменной длины */		255 символов

	+-----------------------------------------------+
	|Тип 		Максимальное число символов	|
	+-----------------------------------------------+
	|Tinytext 	255				|
	|Text 		65 535				|
	|Mediumtext 	16 777 215			|
	|Longtext 	4 294 967 295			|
	+-----------------------------------------------+

Разница заключается в том, что строки фиксированной длины справа дополняются пробелами, тогда как строки переменной длины – нет.

поддерживаемые кодировки:
SHOW CHARACTER SET;

установка определённой кодировки:
VARCHAR(20) CHARACTER SET utf8

тип енам
gender ENUM('M','F'),

ключевое слово ALL применяется по умолчанию и в явном указании не нуждается является обратным ключевому слову DISTINCT

SELECT e.fname, e.lname, d.name			1
FROM employee e INNER JOIN department d
USING (dept_id);

==

SELECT e.fname, e.lname, d.name			2
FROM employee e INNER JOIN department d
ON e.dept_id = d.dept_id;

==

SELECT e.fname, e.lname, d.name			3
FROM employee e, department d
WHERE e.dept_id = d.dept_id;


------------------------------------------
Работа с множествами.

 1. Объединение множеств

	составной запрос

		SELECT 1 num, 'abc' str
		UNION
		SELECT 9 num, 'xyz' str;

		и вот ещё:

		SELECT cust_id, lname
		FROM individual

		UNION ALL

		SELECT cust_id, name
		FROM business;



---------------------------------------------

В MySQL есть функции для конкотенации строк, получения подстрок и т.п.

Агрегатные функции осуществляют определенную операцию над всеми строками группы.
Max() Возвращает максимальное значение из набора.
Min() Возвращает минимальное значение из набора.
Avg() Возвращает среднее значение набора.
Sum() Возвращает сумму значений из набора.
Count() Возвращает количество значений в наборе.

count(val)	- игнорирует null
count(*)	- учитывает


+№_%?*"+! ОБОБЩЕНИЕЯ +№_%?*"+!

1.
	SELECT product_cd, open_branch_id,
	SUM(avail_balance) tot_balance
	FROM account
	GROUP BY product_cd, open_branch_id WITH ROLLUP; <--- подытожить по каждой группе, обобщить в соответствии с функцией

подзапрос действует как временная таблица, областью видимости которой является выражение

скалярным подзапросом (scalar subquery) называется запрос который возвращает одну строку и один столбец

name IN names --- есть ли имя в списке имён, то тру
name NOT IN names --- если имени нет в списке имён, то тру
number > ALL numbers --- если номер больше каждого из номеров, то тру
number > ANY numbers --- если номер больше хоть какого-то из номеров, то тру / эквивалент оператора IN
OR --- или
EXISTS --- существует
NOT EXISTS --- не существует  	SELECT 1 --- стандарт возврата для exists и not exists


записать результат селекта в файл:

SELECT emp_id, fname, lname, start_date
INTO OUTFILE 'C:\\TEMP\\emp_list.txt'
FROM employee;

-----------------
Singer		Album				Year	Sale
The Prodigy	Invaders Must Die		2008	1200000
Drowning Pool	Sinner				2001	400000
Massive Attack	Mezzanine			1998	2300000
The Prodigy	Fat of the Land			1997	600000
The Prodigy	Music For The Jilted Generation	1994	1500000
Massive Attack	100th Window			2003	1200000
Drowning Pool	Full Circle			2007	800000
Massive Attack	Danny The Dog			2004	1900000
Drowning Pool	Resilience			2013	500000

description:
Получить Singer, Album, Sale самого продоваемого альбома каждой группы
иннер джоин + результирующий набор + группировка

SELECT Artists.Singer, Artists.Album, Artists.Sale
FROM Artists INNER JOIN (
	SELECT Singer, MAX(Sale) AS bestSale
	FROM Artists
	GROUP BY Singer
) AS tempT
ON Artists.Sale = tempT.bestSale;

-------------------------------
description:
Есть таблица с id. Когда мы удаляем dto из серидины списка, порядок id нарушается.
Как удалять сохраняя порядок id?

DELETE FROM customers 
WHERE id = deletedid;

UPDATE customers 
SET id=id-1 
WHERE id > deletedid
ORDER BY id
----------------------------------

description: 
Найти всех юзеров фамилии которых начинаются на букву 'T'

SELECT emp_id, fname, lname
FROM employee
WHERE LEFT(lname, 1) = 'T';






















