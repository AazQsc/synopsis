HTTP
HyperText Transfer Protocol

HTTPS
HyperText Transfer Protocol Secure

http - протокол прикладного уровня передачи данных (в соответствии со спецификацией OSI),
изначально создавался для передачи данных в виде гипертекстовых документов в формате «HTML», в настоящий момент используется для передачи произвольных данных(например xml или json).

На данный момент существуют и другие протоколы, предназначенные для передачи веб-содержимого. В частности, протокол SPDY.
====================================================================
Распределение протоколов по уровням модели TCP/IP
5. прикладной	HTTP, FTP, DNS 
4. транспортный TCP
3. сетевой 	IP
2. канальный	Ethernet
1. физический 	физическая среда и принципы кодирования информации...

TCP(Transmission Control Protocol) - порт, это связь на уровне приложений (это целое число от 1 до 65535)
Порты в диапазоне от 0 до 1023, - уже определены

IP(Internet Protocol) - id пользовательской машины + id сети(xxx.xxx.xxx.xxx), для каждого узла свой.
сокет - TCP + IP

Ключевыми классами для реализации взаимодействия программ по TCP являются java.net.Socket и java.net.ServerSocket.

IP-адреса бывают трёх классов:
идентификации сети(net - t)
идентификации пользователя(user - u)
	А - ttt.uuu.uuu.uuu 
	В - ttt.ttt.uuu.uuu
	С - ttt.ttt.ttt.uuu
====================================================================
Основой HTTP является технология «клиент-сервер».
Клиентское приложение формирует запрос и отправляет его на сервер, после чего серверное программное обеспечение обрабатывает данный запрос, формирует ответ и передаёт его обратно клиенту.

Программное обеспечение для работы с протоколом HTTP разделяется на три категории:
-Серверы
-Клиенты
-Прокси (посредники)
====================================================================
Как правило, передача данных по протоколу HTTP осуществляется через TCP/IP-соединения.
Серверное программное обеспечение при этом обычно использует TCP-порт 80 (и, если порт не указан явно, то обычно клиентское программное обеспечение по умолчанию использует именно 80-й порт для открываемых HTTP-соединений), хотя может использовать и любой другой...
====================================================================
Каждое HTTP-сообщение (ЗАПРОС\ОТВЕТ) состоит из трёх частей, которые передаются в указанном порядке:
-Стартовая строка (англ. Starting line) — определяет тип сообщения;
-Заголовки (англ. Headers) — характеризуют тело сообщения, параметры передачи и прочие сведения;
-Тело сообщения (англ. Message Body) — непосредственно данные сообщения. Обязательно должно отделяться от заголовков пустой строкой.

транзакция http = запрос + ответ
====================================================================
ЗАПРОС = метод + URI + версия HTTP

URI (Uniform Resource Identifier, унифицированный идентификатор ресурса) — путь до конкретного ресурса (например, документа), над которым необходимо осуществить операцию.

методы запроса (http request):
	Наиболее часто используемые (4)
GET - запрашивает представление ресурса. Запросы с использованием этого метода могут только извлекать данные.
POST- используется для отправки сущностей к определёному ресурсу. Часто вызывает изменение состояния или какие-то побочные эффекты на сервере.
PUT - заменяет все текущие представления ресурса данными запроса.
DELETE - удаляет указанный ресурс.
	
HEAD- запрашивает ресурс так же, как и метод GET, но без тела ответа.
CONNECT - устанавливает "туннель" к серверу, определённому по ресурсу.
OPTIONS - используется для описания параметров соединения с ресурсом.
TRACE - выполняет вызов возвращаемого тестового сообщения с ресурса.
PATCH - используется для частичного изменения ресурса.
====================================================================
ОТВЕТ = версия + код состояния (Status Code) + пояснение к коду состояния (Reason Phrase) + тело ответа

Классы кодов состояний:
1xx - Информационный (informational)
2xx - Успех (Success)
3xx - Перенаправление (Redirection)
4xx - Ошибка клиента (Client Error)
5xx - Ошибка сервера (англ. Server Error)

пример ответа:

HTTP/1.1 200 OK
Server: nginx/1.2.1
Date: Sat, 08 Mar 2014 22:53:46 GMT
Content-Type: application/octet-stream
Content-Length: 7
Last-Modified: Sat, 08 Mar 2014 22:53:30 GMT
Connection: keep-alive
Accept-Ranges: bytes

<html>
<head><title>freedom</title></head>
<body>
<center><h1>freedom</h1></center>
</body>
</html>
====================================================================
====================================================================
fuser /tmp/ufm_clm330347/target_local/ufm_service/log/ufm.2018-11-30-2.log		узнать PID процесса который юзает этот файл
netstat -tunap																	посмотреть список запущенных процессов
sodu -i																			работать с правами рута
scp ./txt name@srv7-gbayina:/tmp												копируем файл txt из текущей директории на хост имя_пользователя@srv7-gbayina в директорию tmp
scp -r "/drives/C/Users/Yaroslav.Khamenka/Documents/MobaXterm/home/txt.txt" yaroslav.khamenka@srv7-joanes:/tmp 		<- через mobaXterm
ip a																			узнать ip


################################### iptables #########################
### https://eax.me/iptables/ 						   			   ###
### https://www.dmosk.ru/instruktions.php?object=iptables-settings ###
### http://vasilisc.com/21-examples-iptables                       ###
######################################################################
iptables -A INPUT -s xxx.xxx.xxx.xxx -j DROP									установить правило для фаервола, - блокировать по ip
iptables -D INPUT -s xxx.xxx.xxx.xxx -j DROP									отменить правило для фаервола, - блокировать по ip
iptables-save > /etc/iptables.rules												cохранить правила
iptables-restore < /etc/iptables.rules											восстановить правила

172.30.178.109

iptables -A INPUT -s xxx.xxx.xxx.xxx -j DROP

ifconfig -a
route
ping 192.168.1.1