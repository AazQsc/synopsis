Конспект по книге Адитья Бхаргава __"Грокаем Алгоритмы"__.

## БАЗА

__logarithm__ - противоположен по смыслу возведению в степень. 
	
	
Примеры:

	Log^10 100 = сколько раз нужно перемножить 10 чтобы получилось 100 ?
	<br>Log^2 N = сколько раз нужно перемножить 2 чтобы получилось N ?

Примечание:

	Для сокращения записи Log по основанию 2 всегда записывается как просто Log (Log^2 == Log)

__O-sintax__

Скорость, немного визуализации, - чем выше по списку, - тем быстрее:

	<br>*Быстро*
	<br>O (1) 	- Постоянная зависимость (обращение к элементу массива, простые операторы)
	<br>O (Log N)	- Логарифмическая зависимость (двоичный поиск) 
	<br>O (N)	- Линейная зависимость (последовательный поиск, цикл)
	<br>O (N Log N)	- Эта зависимость слабее линейной, но не намного (среднее время быстрой сортировки, сортировки методом пузырька)
	<br>O (N^2)	- Квадратичная зависимость (выборочная сортировка и сортировка включением, вложенный цикл)
	<br>O (N^3)	- Кубическая зависимость
	<br>*пропасть*	- здесь очень большой разрыв в производительности
	<br>O (N!)	- N-факториал (тоже что и C^N)  пример: 5! = 5 x 4 x 3 x 2 x 1 = 120
	<br>O (C^N)	- Экспоненциальная зависимость (задача о коммивояжере, разбиение набора)
	<br>*Медленно*

O(N) это на самом деле O(c\*N) где 'с' - это фиксированный промежуток времени

Пример:

	*Линейный алгоритм поиска* - O (N)
	<br>*Бинарный алгоритм поиска* - O (Log N)


## СТРУКТУРЫ ДАННЫХ

Виды доступа к структуре бывают: __произвольный__ и __последовательный__.

		чтение*    вставка(конец)    вставка(середина)    удаление(конец)    удаление(середина)
	Array	O(1)       O(1)	       	     O(N)	     	  O(1)	    	     O(N)
	List	O(N)       O(1)	       	     O(N)**	     	  O(1)	   	     O(N)**

	*  чтение по индексу
	** на самом деле O(n) где 'n' это позиция элемента в списке

Стек - LIFO

		чтение    вставка    удаление    поиск
	Stack	O(1)	  O(1)	     O(1)	 поиск невозможен

------------------------------------------------------------
Hash Table = хеш-функция + массив
Хеш-функция - представляет собой функцию, которая получает строку и возвращает число.

Хеш-функция неизменно связывает строку с одним индексом.
Хеш-функция связывает разные строки с разными индексами.
Хеш-функция знает размер массива и возвращает только действитель­ные индексы.

Требования к хеш-функциям:
	1. должна быть последовательной (одну и туже строку всегда преобразовывать в одно и тоже число);
	2. разным словам должны соответствовать разные числа.

В идеале хеш-функция должна распределять ключи равномерно по всему хешу.
В реальности сделать это очень сложно.
Для предотвращения коллизий необходимы:
	1. низкий коэффициент заполнения;
		(0,7 - потолок, если очень низкий - часто пересоздаётся массив, если высокий - мого коллизий
		 коэффициент выше 1 говорит о том, что коллизии абсолютно точно есть)
	2. хорошая хеш-функция.
		(должна обеспечить раномерное распределение)

			чтение вставка удаление
Hash Table (средний)	 O(1)	O(1)	 O(1)
Hash Table (худший)	 O(N)	O(N)	 O(N)


____________________________________________________________
СОРТИРОВКИ -------------------------------------------------

			Лучший		Худший
Сортировка выбором	О(N^2) но на самом деле ---> N * 1/2 * N
Быстрая сортировка*	О(N log N)	O(N)** 
Сортировка слиянием	О(N log N)	О(N log N)

*  Константа 'c' у быстрой сортировки меньше чем у сортировки слиянием, поэтому быстрая быстрее сортировки слиянием.
** зависит от выбора опорного элемента.

_____________________________________________________________
РЕКУРСИЯ ----------------------------------------------------
Чтобы понять рекурсию нужно понять рекурсию.
Доказательство по индукции - это рекурсия (базовый случай, индукционный переход).

Каждая рекурсивная функция состоит из двух частей: базового случая и рекурсивного случая.
В рекурсивном случае функция вызывает сама себя. В базовом случае функция себя не вызывает, чтобы предотвратить зацикливание.

Что такое хвостовая рекурсия?



_____________________________________________________________
ГРАФЫ ДРАКУЛЫ -----------------------------------------------

Каждый граф состоит из узлов и ребер.
Узел может быть напрямую со­ единен с несколькими другими узлами. Эти узлы называются соседями.
Переменная связанная с ребром называется весом.

Поиск в ширину.
Алгоритм для решения задачи поиска кратчайшего пути называется поиском в ширину.

Бинарный поиск, типы вопросов:
 тип 1: существует ли путь от узла А к узлу В?
 тип 2: как выглядит кратчайший путь от узла А к узлу В?

Очереди отлично подходят для выполнения бинарного поиска.

Сложность поиска в ширину:
 O(V+E)
	'V' - это количество вершин 
	'Е' - это количество ребер

Метод упорядочивания графа - топологическая сортировка.

Немного о деревьях! 
Разновидность графа, в которой нет ребер, указывающих в об­ ратном направлении, называется деревом.
Дерево - это граф с ориентированными в одну сторону ребрами
Дерево - подкатегория графов. Дерево всегда граф, но граф не всегда дерево.


ВЗВЕШЕННЫЕ ДРАКУЛЫ

Алгоритм Дейкстры - позволяет найти крачйший путь во взвешенном графе.
Ал­горитм Дейкстры работает только с направленными ациклическими графами, которые нередко обозначаются сокращением DAG (Directed Acyclic Graph).
Алгоритм Дейкстры также не работает если в графе присутствуют ребра с отрицательным весом (а вот алгоритм Беллмана-Форда с этим справится!)
Алгоритм Дейкстры.
 1. Найти узел с наименьшей стоимостью (то есть узел, до которого можно добраться за минимальное время).
 2. Обновить стоимости соседей этого узла (проверить, существует ли более дешевый путь к соседям этого узла, и если существует, обновить их стоимости.).
 3. Повторять, пока это не будет сделано для всех узлов графа.
 4. Вычислить итоговый путь (пройдя обратно по родителям).

Реализация алгоритма:

1. нужны три таблицы
- граф
- стоимости
- родители

2. Массив для отслежевания обработаных узлов 

3. Алгоритм

	Пока остаются необработанные узлы <------
		|				^
		*				|
	Взять узел ближайший к началу		|
		|				|
		*				|
	Обновить стоимости для его соседей	|
		|				|
		*				|
	Если стоимости каких либо узлов 	|
	были обновлены обновить и родителей	|
		|				|
		*				|
	Пометить узел как обработанный --->-----/



_____________________________________________________________
ЖАДНЫЕ АЛГОРИТМЫ --------------------------------------------

- это алгоритмы в которых на каждом шаге выбирается локально-оптимальное решение, а в итоге вы получаете глобально-оптимальное решение.
То есть жадные алгоритмы стремятся к локальной оптимизации в расчете на то, что в итоге будет достигнут глобальный оптимум.

- эти алгоритмы просты в реализации, но не всегда возвращают лучший результат (часто, просто, очень близкий к нему).

- Приближенный алгоритм - это алгоритм, который находит решение близкое к оптимальному, и лишь иногда оптимальное.

Такие "приближенные алгоритмы" оцениваются по:
 быстроте;
 близости полученного решения к оптимальному.

На будущее --->
 1. NP-полная задача — в теории алгоритмов задача с ответом «да» или «нет» из класса NP, к которой можно свести любую другую задачу из этого класса за полиномиальное время (то есть при помощи операций, число которых не превышает некоторого полинома в зависимости от размера исходных данных).

 2. В теории алгоритмов классом NP (от англ. non-deterministic polynomial) называют множество проблем разрешимости, решение которых возможно проверить на машине Тьюринга за время, не превосходящее полинома от размера входных данных, при наличии некоторых дополнительных сведений (так называемого сертификата решения).

 3. Задача разрешимости (проблема разрешимости) — вопрос, сформулированный в рамках какой-либо формальной системы, требующий ответа «да» или «нет», возможно, зависящего от значений некоторых входных параметров.

Классические примеры NP-полных задач: Задача о коммивояжере и задача о покрытии множества.



_____________________________________________________________
ДИНАМИЧЕСКОЕ ПРОГРАММИРОВАНИЕ -------------------------------

Простым языкам - это решение большой задачи через множество подзадач

Алгоритм решения задачи о рюкзаке:

Мы формируем таблицу - где горизонтали соответствуют доступным предметам, а вертикали - возможным размерам ёмкости.
По сути посмотреть как решается задача для самого маленького рюкзака, потом, для чуть большего и т.д. - это и есть динамический алгоритм.
Шаг зависит от характеристик объекта. Необходимо выбрать шаг с лучшим приближением.

cell 	- клетка таблицы
i 	- строка
j 	- столбец

cell[i][j] = максимум = предыдущий максимум cell[i-1][j] || стоимость текущего элемента  + стоимость оставшегося пространства cell[i-1][j - вес предмета]

Короткая запись:
cell[i][j] = cell[i-1][j] || i.стоимость  + cell[i-1][j - вес предмета]

Динамическое программирование работает толъко в том случае, если каждая подзадача автономна, то естъ не зависит от других подзадач.




_____________________________________________________________
АЛГОРИТМ 'К'* БЛИЖАЙШИХ СОСЕДЕЙ -----------------------------

*для 'K' объектов следует рассматривать sqrt(K) соседей.

Мы выделяем множество характеристик (критерии).
Важно правильно выбрать критерии:
 - непосредственно относятся к предмету работы
 - не содержат смещения (не должно быть воброса по критерию)
Объекты обладающие этими критерии мы наносим на сеть координат (где кол-во измерений равно кол-ву характеристик).

Растояние между объектами измеряется по формуле Пифигора! (часто ещё применяется 'метрика близости косинусов')

Для двух точек:
Корень{ (x1-x2)^2 + (y1-y2)^2 }

Для пяти трех точек:
Корень{ (x1-x2)^2 + (y1-y2)^2 + (z1-z2)^2 }

Для множества точек:
Корень{ (x1-x2)^2 + (y1-y2)^2 + ... + (n1-n2)^2 }

Для чего применяют алгоритм K ближайших соседей?
 - классификация = распределение по категориям
 - регрессия = прогнозирование ответа (в числовом выражении)

R - регрессия.
Регрессия - метод построения критерия на основе уже построенных критериев ближайших соседей.


Простой пример машинного обучения:
- тренировка (выделение критериев)
- работа (алгоритм K ближайших соседей (классификация))


Наивный классификатор Байеса (спам фильтры).

	Тренировка:
	ТЕМА						СПАМ?
	измените пароль					нет
	вы выиграли миллион				да
	сообщите свой пароль				да
	нигирийских принц готов перевести вам миллион	да	
	с днем рождения					нет

	Во время тренировка смотрим какие слова есть и как часто они встречаются в спаме и не в спаме.
	Например слово миллион - определённо маркер спама

	Работа:
	Применяем алгоритм K ближайших соседей.


_____________________________________________________________
НА БУДУЩЕЕ --------------------------------------------------

---> Бинарное дерево поиска <---
Есть корень - слева то что меньше, справа то, что больше.

	 5
       /   \
      3	    7
     / \   / \
    2   4  6  9
   /	     / \
  1         8  10 

поиск, вставка, удаление в реднем за O(log N)  <--- если сбалансировано!

---> Инвертированные индексы <---
это хеш-таблица, связывающая слова с местами, в которых эти слова встречаются.
Отлично подходит для поиска данных.

---> Преобразование Фурье <---
Если у вас есть коктейль , преобразование Фурье сообщает, из каких ингредиентов он состоит.
Если у вас есть песня, преобразовани Фурье реразделяет ее на отдельные частоты.

---> Парралельные алгоритмы <---

MapReduce - распределенный алгоритм (работаем с множеством машин и ядер).
В основе технологии MapReduce лежат две простые идеи:
 - функция отображения map (преобразует каждый отдельный элемент)
 - функция свертки reduce (преобразует весь набор элементов)

---> Фильтры Блума и Hyperloglog <---

Фильтр блума - вероятностная структура данных.
Возможны ложно-положительные ответы, ложно-отрицательные ответы исключены (если да, то может быть и нет, но если нет, то нет).

HyperLogLog аппроксимирует количество уникальных элементов в множе­стве.

---> Алгоритмы SHA <---

SHA (Secure Hash Algorithm)- разновидность хеш-функций
Преобразует строку в строку.

Локально чувствительные алгоритмы - обратимые хеш функции
Simhash - используется для сравнения строк (антиплагиат)

--->Обмен ключами Диффи-Хеллмана<---
И его наследник - RSA

Комбинирование открытого и закрытого ключа для шифрования.

---> Линейное программирование <---

Это что-то очень крутое.. )

Линейное программирование используется для максимизации некоторой характеристики при заданных ограничениях.
В линейном программировании используется симплекс-метод.











