Наиболее общие принципы, которым стоит следовать: 

--> DRY (don't repeat yourself) - не повторяй себя, - создавай уникальные сущности.


--> Ортогональность. Создавай ортоганальные сущности. Два или более объекта ортогональны,
    если изменения, вносимые в один из них, не влияют на любой другой.


--> Программируй утверждения. Если чего-то быть не должно (никогда!), проверь, нет ли этого чего-то.
	- проверка на null, как пример
	- помни, что это не обработка ошибок


--> Итеративный процесс разработки крайне эффекктивен. Получи рабочую версию как можно раньше,
    а затем, на каждой итерации, добавляй функционал. В конце каждой итерации старайся иметь
    завершенный продукт. 
	- Это создание скилета. Это "стрельба трассирующими".
	- Стрельбе трассирующими может предшествовать создание прототипов.
	- Разработка ПО - это динамический процесс.
	- Разработка ПО не строительство, хм.. это скорее садоводство. :-D
	- Проводи реорганизацию как можно чаще

	
--> Минимизируй связывания между модулями (сущностями/объектами, минимизируй связывания в принципе).
    Закон Деметры - каждый программный модуль:
	1. должен обладать ограниченным знанием о других модулях: знать о модулях, которые имеют «непосредственное» отношение к этому модулю.
	2. должен взаимодействовать только с известными ему модулями «друзьями», не взаимодействовать с незнакомцами.
	3. обращаться только к непосредственным «друзьям».

	Аналогия из жизни: Если Вы хотите, чтобы собака побежала, глупо командовать её лапами, лучше отдать команду собаке, 
			   а она уже разберётся со своими лапами сама.
	Это может сказаться на производительности. Не переусердствуй, возможно некоторые модули стоит связать.


--> Используй метаданные:
      Стремись к абстракции. Пусть программа работает с абстракциями, а конкретные значения пусть находятся в области метаданных.
      Конфигурирование можно осуществлять на уровне метаданных. Это лучший подход чем прямая интеграция данных в программу.
      Осуществляйте настройку, а не интеграцию.
      Хорошо, когда такие настройки можно менять динамический, во время работы программы.


--> При проектировании думай о том, какие процессы могут идти парралельно.
      Проектируй службы.
      Службы — независимые, па­раллельные объекты скрытые за четко определенными, непротиворечивыми ин­терфейсами.
      Для координации параллельных потоков можно исользовать что-то вроде доски объявлений.


--> Автоматизируй.


--> Если работтаешь в объектно-оринтированом стиле (здесь подразумевается наиболее распространненное представление об ооп, как о способе структурировать код по классам определённым образом), то помни про принципы ООП и принципы SOLID. Ах да, и, конечно же помни про GRASP!
	
	--> S.O.L.I.D.
	https://ru.wikipedia.org/wiki/SOLID_(%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)
	
	S Принцип единственной ответственности (The Single Responsibility Principle) - Каждый класс выполняет лишь одну задачу.
	O Принцип открытости/закрытости (The Open Closed Principle) - «программные сущности … должны быть открыты для расширения, но закрыты для модификации.»
	L Принцип подстановки Барбары Лисков (The Liskov Substitution Principle) - «объекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения правильности выполнения программы.» Наследующий класс должен дополнять, а не изменять базовый.
	I Принцип разделения интерфейса (The Interface Segregation Principle) - «много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс общего назначения.»
	D Принцип инверсии зависимостей (The Dependency Inversion Principle) - «Зависимость на Абстракциях. Нет зависимости на что-то конкретное.»
	
	--> принципы OOП
	
	1. Абстракция - необходимо использовать только те характеристики объекта, которые с достаточной точностью представляют его в данной системе. Основная идея состоит в том, чтобы представить объект минимальным набором полей и методов и при этом с достаточной точностью для решаемой задачи.
	
	2. Полиморфизм - мы можем обрабатывать данные разных типов единообразно (опираясь на контракты), если это необходимо (стремимся работать с сущностями на наиболее высоком уровне абстракции).
		ВИДЫ ПОЛИМОРФИЗМА:
		- параметрический полиморфизм - один интерфейс — много реализаций
		- специальный полиморфизм (специализированный полиморфизм, ad-hoc-полиморфизм) - в типизированных это: перегрузка функций и методов, а в слабо типизированных: приведения типов.
		
	3. Наследование - говорит о том, что абстрактный тип данных может наследовать данные и функциональность некоторого существующего типа, способствуя повторному использованию компонентов программного обеспечения. 
	
	4. Инкапсуляция - упаковка данных и функций в единый компонент (тесно связано с абстракцией). В ооп, как правило, рассматривается неотрывно от сокрытия реализации.
	
	--> GRASP (англ. general responsibility assignment software patterns — общие шаблоны распределения ответственностей; также существует английское слово "grasp" — «контроль, хватка») — шаблоны, используемые в объектно-ориентированном проектировании для решения общих задач по назначению ответственностей классам и объектам.
	
	https://ru.wikipedia.org/wiki/GRASP

	1. Информационный эксперт (Information Expert) - Ответственность должна быть назначена тому, кто владеет максимумом необходимой информации для исполнения.
	2. Создатель (Creator) - Информационный эксперт (смотрите пункт №1) в вопросах создания объектов. Пример - абстрактная фабрика
	3. Контроллер (Controller) - Отвечает за операции, запросы на которые приходят от пользователя, и может выполнять сценарии одного или нескольких вариантов использования (например, создание и удаление); не выполняет работу самостоятельно, а делегирует компетентным исполнителям;
	4. Слабое зацепление (Low Coupling)
		«Степень зацепления» — мера неотрывности элемента от других элементов (либо мера данных, имеющихся у него о них).
		«Слабое зацепление» — распределение ответственностей и данных, обеспечивающее взаимную независимость классов. 
		одно из решений для уменьшения зацепленности - Inversion of Control, IoC
	5. Высокая связность (High Cohesion)
		"Высокая связанность класса" — это оценочная модель, направленная на удержание объектов должным образом сфокусированными, управляемыми и понятными. Высокая связанность обычно используется для поддержания низкого зацепления. Высокая связанность означает, что обязанности данного элемента тесно связаны и сфокусированы. Разбиение программ на классы и подсистемы является примером деятельности, которая увеличивает связанность системы.
		"Низкая связанность" — это ситуация, при которой данный элемент имеет слишком много несвязанных обязанностей. Элементы с низкой связанностью часто страдают от того, что их трудно понять, трудно использовать, трудно поддерживать.
		"Связанность класса" — мера сфокусированности предметных областей его методов
	6. Полиморфизм (Polymorphism)- см. полиморфизм ООП
	7. Чистая выдумка (Pure Fabrication) - термин из DDD и отражает концепцию сервисов
	8. Посредник (Indirection) - Слабое зацепление между элементами системы (и возможность повторного использования) обеспечивается назначением промежуточного объекта их посредником. пример: контроллер в MVC
	9. Устойчивость к изменениям (Protected Variations) - Шаблон защищает элементы от изменения другими элементами (объектами или подсистемами) с помощью вынесения взаимодействия в фиксированный интерфейс, через который (и только через который) возможно взаимодействие между элементами. Поведение может варьироваться лишь через создание другой реализации интерфейса.
	
--------------------------------------------------------------------------------------------------------------------------------
Если возникла сложность:
	• Существует ли более простой способ?
	• Вы пытаетесь решить главную проблему или отвлекаетесь на второстепенные технические детали?
	• Почему это является проблемой?
	• Что делает эту проблему столь сложной для решения?
	• Стоит ли делать это именно таким образом?
	• Стоит ли это делать вообще?




--------------------------------------------------------------------------------------------------------------------------------
Границы моего языка есть границы моего мира.
				Людвиг фон Витгенштейн

Великим лицедеям присуща одна общая черта: они знают, когда начинать, и когда подождать.
