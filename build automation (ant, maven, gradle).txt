APACHE ANT
Build file - build.xml

Ant — утилита для автоматизации процесса сборки программного продукта.
Ant обеспечивает императивную сборку проекта (Есть инструкции, описание(то "как") --> инструкции выполняются последовательно).
Ant специализируется на одном - на сборке ПО.

Build file - build.xml
этот файл содержит определение проекта, состоящего из отдельных целей (Targets). Цели сравнимы с процедурами в языках программирования и содержат вызовы команд - заданий (Tasks). Каждое задание представляет собой неделимую, атомарную команду, выполняющую некоторое элементарное действие.
Примеры target'ов:
- clean (удаление промежуточных файлов)
- compile (компиляция всех классов)
- deploy (развёртывание приложения на сервере)
---------------------------------------------------------------------------------------------------
<?xml version="1.0"?>
<!-- имя, действие по умолчанию(соответствует таргету), базовая директория -->
<project name="MyProject" default="build" basedir=".">

    <!-- Сборка приложения -->
    <property name="name" value="AntBuildJar"/>
    <property name="src.dir" location="${basedir}/src"/>
    <property name="build" location="${basedir}/build"/>
    <property name="build.classes" location="${build}/classes"/>
    <path id="libs.dir">
	<fileset dir="lib" includes="**/*.jar"/>
    </path>

    <!-- Сборка приложения -->
    <target name="build" depends="clean" description="Builds the application">
        <!-- Создание директорий -->
        <mkdir dir="${build.classes}"/>

        <!-- Компиляция исходных файлов -->
        <javac srcdir="${src.dir}"
               destdir="${build.classes}"
               debug="false"
               deprecation="true"
               optimize="true" >
            <classpath refid="libs.dir"/>
        </javac>

        <!-- Копирование необходимых файлов -->
        <copy todir="${build.classes}">
            <fileset dir="${src.dir}" includes="**/*.*" excludes="**/*.java"/>
        </copy>

        <!-- Создание JAR-файла -->
        <jar jarfile="${build}/${name}.jar">
            <fileset dir="${build.classes}"/>
        </jar>
    </target>

    <!-- Очистка -->
    <target name="clean" description="Removes all temporary files">
        <!-- Удаление файлов -->
        <delete dir="${build.classes}"/>
    </target>
</project>
---------------------------------------------------------------------------------------------------

Недостатки:
	- сложно работать с зависимостями
	- громоздкий xml
	- не поддерживает работу с многомодульными проектами (не учитывает разбиение на модули)

===================================================================================================
APACHE MAVEN
Build file - pom.xml

maven - система автоматизация сборки и  управления пакетами.
maven обеспечивает декларативную сборку проекта. Декларативно: задаётся спецификация решения задачи, то есть описывается, что представляет собой проблема и ожидаемый результат. В файлах описания проекта содержится его спецификация, а не отдельные команды выполнения в отличии от Ant.
maven использует принцип Maven-архетипов. Стандартная структура каталогов — одна из реализаций принципа архетипов в Maven. То есть maven может задать структуру проекта по-умолчанию.
		testproject1
                            |-- pom.xml
                            `-- src
                                |-- main
                                |   `-- java
                                |       `--ru
                                |           `-- apache_maven
                                |                   `-- App.java
                                `-- test
                                    `-- java
                                        `-- ru
                                            `-- apache_maven
                                                    `-- AppTest.java

	Репозитории. Maven ищет необходимые файлы в локальных каталогах или в локальном Maven-репозитории. Если зависимость не может быть локально разрешена, Maven подключается к указанному Maven-репозиторию в сети и копирует в локальный репозиторий. По умолчанию Maven использует Maven Central Repository[20], но разработчик может конфигурировать и другие публичные Maven-репозитории, такие, как Apache, Ibiblio, Codehaus или Java.Net.
	Транзитивные зависимости. Необходимые библиотеки подгружаются в проект автоматически. При разрешении конфликта версий используется принцип «ближайшей» зависимости, то есть выбирается зависимость, путь к которой через список зависимых проектов является наиболее коротким.

преимущества
1 Независимость от os
2 Управление зависимостями
3 Возможна сборка из командной строки
4 Хорошая интеграция со средами разработки

Build file - pom.xml (описан на языке POM --> подмножество XML)
Крупные проекты могут быть поделены на несколько модулей, или подпроектов, каждый со своим собственным POM. Операции над модулями могут выполняться через общий корневой POM единой командой.
---------------------------------------------------------------------------------------------------
<project>
1
  <!-- версия модели для POM-ов Maven 2.x всегда 4.0.0 -->
  <modelVersion>4.0.0</modelVersion>

2
  <!-- координаты проекта, то есть набор значений, который
       позволяет однозначно идентифицировать этот проект -->
 
  <groupId>com.mycompany.app</groupId>	// домен - правила аналогичны именованию java-файлов
  <artifactId>my-app</artifactId>	// название проекта
  <version>1.0</version>		// версия проекта, "-SNAPSHOT" что обозначает, что версия в разработке и результирующий jar файл может меняться.
  <packaging>war</packaging> 		// определяет какого типа файл будет создаваться как результат сборки (pom, jar, war, ear). 

3
  <!-- эта информация, которая не используется самим мавеном, но нужна для программиста, чтобы понять, о чём этот проект -->

  <name>My Application</name> 			// название проекта для человека
  <description>My app is ...</description> 	// Описание проекта
  <url>http://www.apache-maven.ru</url> 	// сайт проекта.

4
  <!-- зависимости от библиотек -->
 
  <dependencies>			// обязательные теги groupId, artifactId, version (GAV)

    <dependency> 
      <groupId>junit</groupId>		// координаты необходимой библиотеки
      <artifactId>junit</artifactId>
      <version>3.8.1</version>
      <scope>test</scope>		// эта библиотека используется только для запуска и компилирования тестов
    </dependency>

    <dependency> 			// http://mavenrepository.com/
      <groupId>...</groupId>
      <artifactId>...</artifactId>
      <version>...</version>
    </dependency>

  </dependencies>

5
  <!-- Необязательный блок, но важный, содержит информацию о сборке-->

  <build>

5.1
  <!-- определяет, в какую директорию компилятор будет сохранять результаты компиляции - *.class файлы. Значение по умолчанию - target/classes -->

    <outputDirectory>target2</outputDirectory>

5.2
  <!-- имя результирующего jar (war, ear..) файла с соответствующим типу расширением, который создаётся на фазе package. По умолчанию — artifactId-version. -->
    
    <finalName>ROOT</finalName>

5.3
  <!-- определяет, откуда maven будет брать файлы исходного кода. По умолчанию это src/main/java, но вы можете определить, где это вам удобно.
 Директория может быть только одна (без использования специальных плагинов) -->

    <sourceDirectory>src/java</sourceDirectory>

5.4
  <!--  вложенные в неё тэги <resource> определяют, одну или несколько директорий, где хранятся файлы ресурсов.
 Ресурсы в отличие от файлов исходного кода при сборке просто копируются . Директория по умолчанию src/main/resources -->

  	<resources>

  	  <resource>
  	    <directory>${basedir}/src/java</directory>
  	    <includes>
   	    	<include>**/*.properties</include>
  	    </includes>
  	  </resource>

  	</resources>

  <!-- Maven плагины позволяют задать дополнительные действия, которые будут выполняться при сборке -->
	<plugin>
          <groupId>org.apache.maven.plugins</groupId>
 	  <artifactId>maven-jar-plugin</artifactId>
	  <version>3.0.2</version>
            <configuration>
              <archive>
                <manifest>
                  <mainClass>by.khamenka.andersenlab.HelloWorld</mainClass>	// Добавляем Main-Class в манифест
                </manifest>
              </archive>
             </configuration>
          </plugin>

  </build>

6
  <!-- Если мы планируем запускать приложение в разном окружении  мы можем использовать 'профайлы'.
 Профайлы это наборы разных настроек, зависимостей и плагинов.
 Одновременно может быть подключено несколько профайлов
 Профайлы можно вынести в отдельный файл
 Активные профайлы можно также задать в ~/.m2/settings.xml -->

  <profiles>
	<profile>					// 1 profile						
            <id>development</id>			// уникальный ID профайла
	    <activation>

		<!-- Кроме активации по умолчанию можно задать активацию на основе операционной системы, установленных переменных окружения, версии JDK -->
		<activeByDefault>true</activeByDefault>

	    </activation>
            <properties>
                <database.url>jdbc:hsqldb:mem:testdb</database.url>
            </properties>
            <dependencies>
                <dependency>
                    <groupId>org.hsqldb</groupId>
                    <artifactId>hsqldb</artifactId>
                    <version>2.0.0</version>
                </dependency>
            </dependencies>
        </profile>
        <profile>					// 2 profile
            <id>productionServer</id>
            <properties>
                <database.url>jdbc:postgresql://databseserver/database</database.url>
            </properties>
            <dependencies>
                <dependency>
                    <groupId>postgresql</groupId>
                    <artifactId>postgresql</artifactId>
                    <version>9.0-801.jdbc4</version>
                </dependency>
            </dependencies>
        </profile>
    </profiles>

  </project>
---------------------------------------------------------------------------------------------------
Существует три встроенных жизненных цикла сборки:
Жизненный цикл Default обрабатывает развертывание вашего проекта.
- не выполняются если явно не указаны -
Жизненный цикл Clean обрабатывает очистку проекта.
Жизненный цикл Site - это создание документации сайта вашего проекта.

Основные фазы сборки проекта (можно выполнить фазу используя команду mvn)
	1. Validate - проверить проект
	2. compile - Компилирование проекта
	3. test - Тестирование с помощью JUnit тестов
	4. package - Создание .jar файла или war, ear в зависимости от типа проекта
	5. verify - Запуск интеграционных тестов
	6. install - Копирование .jar (war , ear) в локальный репозиторий
	7. deploy - публикация файла в удалённый репозиторий

Каждая следующая фаза включает в себя предыдущую

---------------------------------------------------------------------------------------------------
Непрерывная интеграция ( Continuous Integration, CI)- это
	-автоматическая сборка проекта из исходного кода,
	-при этом дополнительно возможен запуск автоматических тестов
	(см. maven-surefire-plugin, maven-failsafe-plugin )
	-проверка качества кода
	(см. maven-pmd-plugin, maven-checkstyle-plugin findbugs-maven-plugin ),
	-развёртывание приложения на тестовом сервере (для серверных приложений).

    Плюсы непрерывной интеграции:
	раннее обнаружение ошибок
	автоматизация рутинных операций
	как результат - экономия времени и повышение качества кода.

    Организовать процесс автоматической сборки можно используя:
	Jenkins/Hudson
	Continuum
	CruiseControl
	Teamcity

===================================================================================================
GRADLE
Build file - gradle.build

gradle — система автоматической сборки, построенная на принципах Apache Ant и Apache Maven, но предоставляющая DSL на языке Groovy
gradle — "DSL на базе Groovy для сборки проектов"
DSL - Domain Specific Language -  язык программирования, специализированный для конкретной области применения (в противоположность языку общего назначения, применимому к широкому спектру областей и не учитывающему особенности конкретных сфер знаний).

Gradle DAG — Directed Acyclic Graph (направленный ациклический граф) — направленный, не содержащий циклов, граф.
В отличие от Apache Maven, основанного на концепции жизненного цикла проекта, и Apache Ant, в котором порядок выполнения задач (targets) определяется отношениями зависимости (depends-on), Gradle использует направленный ациклический граф для определения порядка выполнения задач.

DSL на Groovy – это просто Groovy-скрипт с набором удобных и готовых функций для сборки проектов, другими словами, gradle.build – это просто программа на Groovy.
О Groovy:
	- можно опускать скобки для методов, которые имеют всего один аргумент
	  println("hello")  --->  println "hello"
	
	- Gradle перед выполнением скрипта groovy обрабатывает его с помощью TaskDefinitionScriptTransformer написанном на джава
	  https://code-review.gradle.org/browse/Gradle/subprojects/core/src/main/groovy/org/gradle/groovy/scripts/internal/TaskDefinitionScriptTransformer.java?r=1bb1189c72c4efdbf42e0d5a906a4fb9d7537b8b#to49
	  из-за чего синтаксис groovy в gradle отличается от оригинального (вот почему он DSL?)

	- Каждая задача, которую вы объявляете, в действительности, становится объектом-задачей в пределах всего проекта билда.
	  По умолчанию, каждой новой задаче присваивается тип DefaultTask.


Задача (task) является основным компонентом процесса сборки в файле билда Gradle и представляют собой именованные наборы инструкций билда, которые Gradle запускает выполняя сборку приложения.
Задачи Gradle являются полнофункциональными объектами, которыми можно управлять программно.

Каждый раз, когда Gradle запускает билд, процесс проходит через три фазы жизненного цикла:
	Инициализация — фаза, в которой Gradle принимает решение, какие объекты будут принимать участие в билде. Последняя фаза важна в многопроектных билдах.
	Конфигурация — фаза в которой объекты задачи собираются во внутреннюю объектную модель, обычно называемую направленным ациклическим графом.
	Выполнение — фаза, во время которой задачи билда выполняются в порядке, указанном в настройках их зависимостей.
	
______________________________________________
---------------- Установка -------------------

https://gradle.org/install/

Несколько команд:
gradle -v	- проверим версию
gradle tasks	- отображает задачи, которые доступны в текущей директории

______________________________________________
---------------- JAR -------------------------
1. создадим новый build.gradle в корневой папке (структура - src'тут'/main/java/пакеты)
2. пропишем там (подключим плагин)
	apply plugin: 'java'
   таким образом мы очень расширим список доступных нам комманд,
   что можно увидеть введя gradle tasks
3. $ gradle build	// Эта задача компилирует, тестирует и упаковывает код в JAR-файл.

build
	classes - Скомпилированные .class файлы
	reports - Отчеты в течении сборки(такие как отчеты о тестировании)
	libs - Библиотеки для сборки проекта(обычно в виде JAR и/или WAR файлов)

Можно добавить	 имя для нашего JAR артефакта:

jar {
    baseName = 'myName'
    version =  '1.0.0'
}

______________________________________________
---------------- Зависимости -----------------
1. объявим источники сторонних библиотек build.gradle:

repositories {
    mavenLocal()
    mavenCentral()
}

2. объявим библиотеку которую хотим добавить:

dependencies {
    compile "joda-time:joda-time:2.2"		// compile - это конфигурация
}

3. Нужен ещё вот этот плагин, чтобы сделать jar исполняемым
apply plugin: 'application'
mainClassName = 'hello.HelloWorld'

* добавить зависимости в jar
	compile fileTree(dir: 'libs', include: ['*.jar'])

______________________________________________
---------------- Задачи ----------------------
добавление операций аддитивным способом (будет исполнено на этапе исполнения)

Объявить задачу можно так:
task hello

Добавить операцию к коменда можно так:
hello << {
    print 'hello, '
}

К задаче можно добавить ещё одно операцию:
hello << {
    println 'world'
}

В сумме даст:
-> hello, world

И это тождественно: 
task hello << {
    println 'hello, world'
}
----------------------------------------------
Замыкание (~добавление блока конфигурации)

hello {
    println 'new hello'

----------------------------------------------
В описании таска можно прописать от чего он зависит:
dependsOn

----------------------------------------------
Используем проперти:
1. Создай градл.пропертис
X = "текст"

2. Билд градл
task printX {
	print X
}

----------------------------------------------
-В корневой директории создаём поддиректорию 'build sourse'
-В ней создаём градл проект (да, там есть build.gradle - зависимости)
-там сорцы, джава проект, логика таска
-наследуем НашТаск от ДефалтТаск
	- поля - это проперти
	- @Input - обязательный  проперти
	- @TaskAction - это наш таск
		- getProject.getProperties.get... // доступ к проперти

-прописывает таск
	task МойТаск(type: имяКласса){
		to = название проперти 
	}

-добавить таск в DSL
______________________________________________
---------------- wrapper ---------------------
Wrapper - это скрипт, который вызывает объявленную версию Gradle, загружая ее заранее, если это необходимо.

Можно создать коммандой:
-> gradle wrapper
После того, как задачи отработают, появится несколько новых файлов.
Два скрипта в корневом каталоге, а jar-файл и properties-файл оболочки будут в папке gradle/wrapper.

Затем нужно добавить task
task wrapper(type: Wrapper) {
    gradleVersion = '4.5.1'
}

А билдить теперь вот так:
./gradlew build

______________________________________________
---------------- модули ----------------------
1 gradle.build должен быть в каждом модуле, для установки каких-то уникальных для этого модуля настроек
2 В корневой папке должен находится root  - gradle.build (здесь могут находится общие настройки для всех модулей и враппер):

	
	subprojects {			//общие настройки для всех модулей 
	    apply plugin: 'java'
	    apply plugin: 'idea'

	    tasks.withType(JavaCompile) {
		sourceCompatibility = JavaVersion.VERSION_1_8
		targetCompatibility = JavaVersion.VERSION_1_8
	    }

	    repositories {
		mavenLocal()
		mavenCentral()
	    }
	}


3. В корневой папке должен находится settings.gradle, там мы установим зависимости:


	rootProject.name = 'gradle-example'

	include 'calculator', 'client', 'server'	// включить следующие модули:


прим. - это не единственный вариант создания многомодульного проекта

===================================================================================================
Евгений Борисов — Power of Gradle
--------------------------------------------
что входит в билд?
- vcs(git)
- CI scripts & different xml configurations
- Зависимости
- деплойдмент
- unut test + test
- doc
...

--------------------------------------------
Ещё раз
Императив - Ant (блоки, говорим как)
Декларатив - Maven (что)

--------------------------------------------
Плагин к maven делается на джава.

--------------------------------------------
GRADLE

+ Gradle не заточен под джава... всё зависит от плагина, который тащит DSL
+ Таски могут выполнятся паралельно.
+ Инкрементальная сборка (только те таски, которые нужны)

Конвенции:
- структура проекта

Конфигурации:
1 есть блок конфигурации
2 Каждая депенденси добавляется на какую-то конфигурацию
3 Каждый таск работает с какой-то конфигурацией.

--------------------------------------------
Работа:
- с чем работаем? (добавляем модуль, он тащит жизненный цикл)
- А какие есть зависимости? (dependencies)
	- каждая зависимость на свою конфигурацию
- А откуда тащить зависимости? (repositories)

Дальше можем работать с Buid task dependency graph.
- добавить/убрать dependency к существующему таску
build.dependsOn.remove('check')	// исключили зависимость от таска check
build.dependsOn.add('check')	// добавим зависимость

- добавить поведение
- настройки таска

ПРОБЛЕМЫ
- всё можно? проблема? да... поддержка
- мало плагинов (но только по сравнению с maven)


